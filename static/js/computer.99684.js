/*! For license information please see computer.99684.js.LICENSE.txt */
(self.webpackChunkrunmy=self.webpackChunkrunmy||[]).push([["computer"],{"./src/js/study/computer/index.tsx":function(t,e,n){"use strict";n.r(e),n.d(e,{default:function(){return $i}});var r=n("./node_modules/react-router/dist/index.js"),i=n("./src/js/util/utilfn.ts");function a(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function s(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}var o,c,l,h,u,p,d,f,m,_,g,v,y,x,C,$={autoSleep:120,force3D:"auto",nullTargetWarn:1,units:{lineHeight:""}},b={duration:.5,overwrite:!1,delay:0},T=1e8,w=1e-8,A=2*Math.PI,k=A/4,S=0,P=Math.sqrt,N=Math.cos,M=Math.sin,B=function(t){return"string"==typeof t},j=function(t){return"function"==typeof t},L=function(t){return"number"==typeof t},O=function(t){return void 0===t},R=function(t){return"object"==typeof t},U=function(t){return!1!==t},D=function(){return"undefined"!=typeof window},I=function(t){return j(t)||B(t)},E="function"==typeof ArrayBuffer&&ArrayBuffer.isView||function(){},q=Array.isArray,F=/(?:-?\.?\d|\.)+/gi,z=/[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,W=/[-+=.]*\d+[.e-]*\d*[a-z%]*/g,V=/[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,K=/[+-]=-?[.\d]+/,H=/[^,'"\[\]\s]+/gi,X=/^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,G={},Y={},Q=function(t){return(Y=wt(t,G))&&kn},J=function(t,e){return!e&&void 0},Z=function(t,e){return t&&(G[t]=e)&&Y&&(Y[t]=e)||G},tt=function(){return 0},et={suppressEvents:!0,isStart:!0,kill:!1},nt={suppressEvents:!0,kill:!1},rt={suppressEvents:!0},it={},at=[],st={},ot={},ct={},lt=30,ht=[],ut="",pt=function(t){var e,n,r=t[0];if(R(r)||j(r)||(t=[t]),!(e=(r._gsap||{}).harness)){for(n=ht.length;n--&&!ht[n].targetTest(r););e=ht[n]}for(n=t.length;n--;)t[n]&&(t[n]._gsap||(t[n]._gsap=new Ee(t[n],e)))||t.splice(n,1);return t},dt=function(t){return t._gsap||pt(re(t))[0]._gsap},ft=function(t,e,n){return(n=t[e])&&j(n)?t[e]():O(n)&&t.getAttribute&&t.getAttribute(e)||n},mt=function(t,e){return(t=t.split(",")).forEach(e)||t},_t=function(t){return Math.round(1e5*t)/1e5||0},gt=function(t){return Math.round(1e7*t)/1e7||0},vt=function(t,e){var n=e.charAt(0),r=parseFloat(e.substr(2));return t=parseFloat(t),"+"===n?t+r:"-"===n?t-r:"*"===n?t*r:t/r},yt=function(t,e){for(var n=e.length,r=0;t.indexOf(e[r])<0&&++r<n;);return r<n},xt=function(){var t,e,n=at.length,r=at.slice(0);for(st={},at.length=0,t=0;t<n;t++)(e=r[t])&&e._lazy&&(e.render(e._lazy[0],e._lazy[1],!0)._lazy=0)},Ct=function(t,e,n,r){at.length&&!c&&xt(),t.render(e,n,r||c&&e<0&&(t._initted||t._startAt)),at.length&&!c&&xt()},$t=function(t){var e=parseFloat(t);return(e||0===e)&&(t+"").match(H).length<2?e:B(t)?t.trim():t},bt=function(t){return t},Tt=function(t,e){for(var n in e)n in t||(t[n]=e[n]);return t},wt=function(t,e){for(var n in e)t[n]=e[n];return t},At=function t(e,n){for(var r in n)"__proto__"!==r&&"constructor"!==r&&"prototype"!==r&&(e[r]=R(n[r])?t(e[r]||(e[r]={}),n[r]):n[r]);return e},kt=function(t,e){var n,r={};for(n in t)n in e||(r[n]=t[n]);return r},St=function(t){var e,n=t.parent||h,r=t.keyframes?(e=q(t.keyframes),function(t,n){for(var r in n)r in t||"duration"===r&&e||"ease"===r||(t[r]=n[r])}):Tt;if(U(t.inherit))for(;n;)r(t,n.vars.defaults),n=n.parent||n._dp;return t},Pt=function(t,e,n,r,i){void 0===n&&(n="_first"),void 0===r&&(r="_last");var a,s=t[r];if(i)for(a=e[i];s&&s[i]>a;)s=s._prev;return s?(e._next=s._next,s._next=e):(e._next=t[n],t[n]=e),e._next?e._next._prev=e:t[r]=e,e._prev=s,e.parent=e._dp=t,e},Nt=function(t,e,n,r){void 0===n&&(n="_first"),void 0===r&&(r="_last");var i=e._prev,a=e._next;i?i._next=a:t[n]===e&&(t[n]=a),a?a._prev=i:t[r]===e&&(t[r]=i),e._next=e._prev=e.parent=null},Mt=function(t,e){t.parent&&(!e||t.parent.autoRemoveChildren)&&t.parent.remove&&t.parent.remove(t),t._act=0},Bt=function(t,e){if(t&&(!e||e._end>t._dur||e._start<0))for(var n=t;n;)n._dirty=1,n=n.parent;return t},jt=function(t,e,n,r){return t._startAt&&(c?t._startAt.revert(nt):t.vars.immediateRender&&!t.vars.autoRevert||t._startAt.render(e,!0,r))},Lt=function t(e){return!e||e._ts&&t(e.parent)},Ot=function(t){return t._repeat?Rt(t._tTime,t=t.duration()+t._rDelay)*t:0},Rt=function(t,e){var n=Math.floor(t/=e);return t&&n===t?n-1:n},Ut=function(t,e){return(t-e._start)*e._ts+(e._ts>=0?0:e._dirty?e.totalDuration():e._tDur)},Dt=function(t){return t._end=gt(t._start+(t._tDur/Math.abs(t._ts||t._rts||w)||0))},It=function(t,e){var n=t._dp;return n&&n.smoothChildTiming&&t._ts&&(t._start=gt(n._time-(t._ts>0?e/t._ts:((t._dirty?t.totalDuration():t._tDur)-e)/-t._ts)),Dt(t),n._dirty||Bt(n,t)),t},Et=function(t,e){var n;if((e._time||!e._dur&&e._initted||e._start<t._time&&(e._dur||!e.add))&&(n=Ut(t.rawTime(),e),(!e._dur||Jt(0,e.totalDuration(),n)-e._tTime>w)&&e.render(n,!0)),Bt(t,e)._dp&&t._initted&&t._time>=t._dur&&t._ts){if(t._dur<t.duration())for(n=t;n._dp;)n.rawTime()>=0&&n.totalTime(n._tTime),n=n._dp;t._zTime=-1e-8}},qt=function(t,e,n,r){return e.parent&&Mt(e),e._start=gt((L(n)?n:n||t!==h?Gt(t,n,e):t._time)+e._delay),e._end=gt(e._start+(e.totalDuration()/Math.abs(e.timeScale())||0)),Pt(t,e,"_first","_last",t._sort?"_start":0),Vt(e)||(t._recent=e),r||Et(t,e),t._ts<0&&It(t,t._tTime),t},Ft=function(t,e){return G.ScrollTrigger?G.ScrollTrigger.create(e,t):void 0},zt=function(t,e,n,r,i){return Xe(t,e,i),t._initted?!n&&t._pt&&!c&&(t._dur&&!1!==t.vars.lazy||!t._dur&&t.vars.lazy)&&m!==ke.frame?(at.push(t),t._lazy=[i,r],1):void 0:1},Wt=function t(e){var n=e.parent;return n&&n._ts&&n._initted&&!n._lock&&(n.rawTime()<0||t(n))},Vt=function(t){var e=t.data;return"isFromStart"===e||"isStart"===e},Kt=function(t,e,n,r){var i=t._repeat,a=gt(e)||0,s=t._tTime/t._tDur;return s&&!r&&(t._time*=a/t._dur),t._dur=a,t._tDur=i?i<0?1e10:gt(a*(i+1)+t._rDelay*i):a,s>0&&!r&&It(t,t._tTime=t._tDur*s),t.parent&&Dt(t),n||Bt(t.parent,t),t},Ht=function(t){return t instanceof Fe?Bt(t):Kt(t,t._dur)},Xt={_start:0,endTime:tt,totalDuration:tt},Gt=function t(e,n,r){var i,a,s,o=e.labels,c=e._recent||Xt,l=e.duration()>=T?c.endTime(!1):e._dur;return B(n)&&(isNaN(n)||n in o)?(a=n.charAt(0),s="%"===n.substr(-1),i=n.indexOf("="),"<"===a||">"===a?(i>=0&&(n=n.replace(/=/,"")),("<"===a?c._start:c.endTime(c._repeat>=0))+(parseFloat(n.substr(1))||0)*(s?(i<0?c:r).totalDuration()/100:1)):i<0?(n in o||(o[n]=l),o[n]):(a=parseFloat(n.charAt(i-1)+n.substr(i+1)),s&&r&&(a=a/100*(q(r)?r[0]:r).totalDuration()),i>1?t(e,n.substr(0,i-1),r)+a:l+a)):null==n?l:+n},Yt=function(t,e,n){var r,i,a=L(e[1]),s=(a?2:1)+(t<2?0:1),o=e[s];if(a&&(o.duration=e[1]),o.parent=n,t){for(r=o,i=n;i&&!("immediateRender"in r);)r=i.vars.defaults||{},i=U(i.vars.inherit)&&i.parent;o.immediateRender=U(r.immediateRender),t<2?o.runBackwards=1:o.startAt=e[s-1]}return new Ze(e[0],o,e[s+1])},Qt=function(t,e){return t||0===t?e(t):e},Jt=function(t,e,n){return n<t?t:n>e?e:n},Zt=function(t,e){return B(t)&&(e=X.exec(t))?e[1]:""},te=[].slice,ee=function(t,e){return t&&R(t)&&"length"in t&&(!e&&!t.length||t.length-1 in t&&R(t[0]))&&!t.nodeType&&t!==u},ne=function(t,e,n){return void 0===n&&(n=[]),t.forEach((function(t){var r;return B(t)&&!e||ee(t,1)?(r=n).push.apply(r,re(t)):n.push(t)}))||n},re=function(t,e,n){return l&&!e&&l.selector?l.selector(t):!B(t)||n||!p&&Se()?q(t)?ne(t,n):ee(t)?te.call(t,0):t?[t]:[]:te.call((e||d).querySelectorAll(t),0)},ie=function(t){return t=re(t)[0]||J()||{},function(e){var n=t.current||t.nativeElement||t;return re(e,n.querySelectorAll?n:n===t?J()||d.createElement("div"):t)}},ae=function(t){return t.sort((function(){return.5-Math.random()}))},se=function(t){if(j(t))return t;var e=R(t)?t:{each:t},n=Oe(e.ease),r=e.from||0,i=parseFloat(e.base)||0,a={},s=r>0&&r<1,o=isNaN(r)||s,c=e.axis,l=r,h=r;return B(r)?l=h={center:.5,edges:.5,end:1}[r]||0:!s&&o&&(l=r[0],h=r[1]),function(t,s,u){var p,d,f,m,_,g,v,y,x,C=(u||e).length,$=a[C];if(!$){if(!(x="auto"===e.grid?0:(e.grid||[1,T])[1])){for(v=-T;v<(v=u[x++].getBoundingClientRect().left)&&x<C;);x--}for($=a[C]=[],p=o?Math.min(x,C)*l-.5:r%x,d=x===T?0:o?C*h/x-.5:r/x|0,v=0,y=T,g=0;g<C;g++)f=g%x-p,m=d-(g/x|0),$[g]=_=c?Math.abs("y"===c?m:f):P(f*f+m*m),_>v&&(v=_),_<y&&(y=_);"random"===r&&ae($),$.max=v-y,$.min=y,$.v=C=(parseFloat(e.amount)||parseFloat(e.each)*(x>C?C-1:c?"y"===c?C/x:x:Math.max(x,C/x))||0)*("edges"===r?-1:1),$.b=C<0?i-C:i,$.u=Zt(e.amount||e.each)||0,n=n&&C<0?je(n):n}return C=($[t]-$.min)/$.max||0,gt($.b+(n?n(C):C)*$.v)+$.u}},oe=function(t){var e=Math.pow(10,((t+"").split(".")[1]||"").length);return function(n){var r=gt(Math.round(parseFloat(n)/t)*t*e);return(r-r%1)/e+(L(n)?0:Zt(n))}},ce=function(t,e){var n,r,i=q(t);return!i&&R(t)&&(n=i=t.radius||T,t.values?(t=re(t.values),(r=!L(t[0]))&&(n*=n)):t=oe(t.increment)),Qt(e,i?j(t)?function(e){return r=t(e),Math.abs(r-e)<=n?r:e}:function(e){for(var i,a,s=parseFloat(r?e.x:e),o=parseFloat(r?e.y:0),c=T,l=0,h=t.length;h--;)(i=r?(i=t[h].x-s)*i+(a=t[h].y-o)*a:Math.abs(t[h]-s))<c&&(c=i,l=h);return l=!n||c<=n?t[l]:e,r||l===e||L(e)?l:l+Zt(e)}:oe(t))},le=function(t,e,n,r){return Qt(q(t)?!e:!0===n?!!(n=0):!r,(function(){return q(t)?t[~~(Math.random()*t.length)]:(n=n||1e-5)&&(r=n<1?Math.pow(10,(n+"").length-2):1)&&Math.floor(Math.round((t-n/2+Math.random()*(e-t+.99*n))/n)*n*r)/r}))},he=function(t,e,n){return Qt(n,(function(n){return t[~~e(n)]}))},ue=function(t){for(var e,n,r,i,a=0,s="";~(e=t.indexOf("random(",a));)r=t.indexOf(")",e),i="["===t.charAt(e+7),n=t.substr(e+7,r-e-7).match(i?H:F),s+=t.substr(a,e-a)+le(i?n:+n[0],i?0:+n[1],+n[2]||1e-5),a=r+1;return s+t.substr(a,t.length-a)},pe=function(t,e,n,r,i){var a=e-t,s=r-n;return Qt(i,(function(e){return n+((e-t)/a*s||0)}))},de=function(t,e,n){var r,i,a,s=t.labels,o=T;for(r in s)(i=s[r]-e)<0==!!n&&i&&o>(i=Math.abs(i))&&(a=r,o=i);return a},fe=function(t,e,n){var r,i,a,s=t.vars,o=s[e],c=l,h=t._ctx;if(o)return r=s[e+"Params"],i=s.callbackScope||t,n&&at.length&&xt(),h&&(l=h),a=r?o.apply(i,r):o.call(i),l=c,a},me=function(t){return Mt(t),t.scrollTrigger&&t.scrollTrigger.kill(!!c),t.progress()<1&&fe(t,"onInterrupt"),t},_e=[],ge=function(t){if(D()&&t){var e=(t=!t.name&&t.default||t).name,n=j(t),r=e&&!n&&t.init?function(){this._props=[]}:t,i={init:tt,render:ln,add:Ke,kill:un,modifier:hn,rawVars:0},a={targetTest:0,get:0,getSetter:an,aliases:{},register:0};if(Se(),t!==r){if(ot[e])return;Tt(r,Tt(kt(t,i),a)),wt(r.prototype,wt(i,kt(t,a))),ot[r.prop=e]=r,t.targetTest&&(ht.push(r),it[e]=1),e=("css"===e?"CSS":e.charAt(0).toUpperCase()+e.substr(1))+"Plugin"}Z(e,r),t.register&&t.register(kn,r,fn)}else t&&_e.push(t)},ve=255,ye={aqua:[0,ve,ve],lime:[0,ve,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,ve],navy:[0,0,128],white:[ve,ve,ve],olive:[128,128,0],yellow:[ve,ve,0],orange:[ve,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[ve,0,0],pink:[ve,192,203],cyan:[0,ve,ve],transparent:[ve,ve,ve,0]},xe=function(t,e,n){return(6*(t+=t<0?1:t>1?-1:0)<1?e+(n-e)*t*6:t<.5?n:3*t<2?e+(n-e)*(2/3-t)*6:e)*ve+.5|0},Ce=function(t,e,n){var r,i,a,s,o,c,l,h,u,p,d=t?L(t)?[t>>16,t>>8&ve,t&ve]:0:ye.black;if(!d){if(","===t.substr(-1)&&(t=t.substr(0,t.length-1)),ye[t])d=ye[t];else if("#"===t.charAt(0)){if(t.length<6&&(r=t.charAt(1),i=t.charAt(2),a=t.charAt(3),t="#"+r+r+i+i+a+a+(5===t.length?t.charAt(4)+t.charAt(4):"")),9===t.length)return[(d=parseInt(t.substr(1,6),16))>>16,d>>8&ve,d&ve,parseInt(t.substr(7),16)/255];d=[(t=parseInt(t.substr(1),16))>>16,t>>8&ve,t&ve]}else if("hsl"===t.substr(0,3))if(d=p=t.match(F),e){if(~t.indexOf("="))return d=t.match(z),n&&d.length<4&&(d[3]=1),d}else s=+d[0]%360/360,o=+d[1]/100,r=2*(c=+d[2]/100)-(i=c<=.5?c*(o+1):c+o-c*o),d.length>3&&(d[3]*=1),d[0]=xe(s+1/3,r,i),d[1]=xe(s,r,i),d[2]=xe(s-1/3,r,i);else d=t.match(F)||ye.transparent;d=d.map(Number)}return e&&!p&&(r=d[0]/ve,i=d[1]/ve,a=d[2]/ve,c=((l=Math.max(r,i,a))+(h=Math.min(r,i,a)))/2,l===h?s=o=0:(u=l-h,o=c>.5?u/(2-l-h):u/(l+h),s=l===r?(i-a)/u+(i<a?6:0):l===i?(a-r)/u+2:(r-i)/u+4,s*=60),d[0]=~~(s+.5),d[1]=~~(100*o+.5),d[2]=~~(100*c+.5)),n&&d.length<4&&(d[3]=1),d},$e=function(t){var e=[],n=[],r=-1;return t.split(Te).forEach((function(t){var i=t.match(W)||[];e.push.apply(e,i),n.push(r+=i.length+1)})),e.c=n,e},be=function(t,e,n){var r,i,a,s,o="",c=(t+o).match(Te),l=e?"hsla(":"rgba(",h=0;if(!c)return t;if(c=c.map((function(t){return(t=Ce(t,e,1))&&l+(e?t[0]+","+t[1]+"%,"+t[2]+"%,"+t[3]:t.join(","))+")"})),n&&(a=$e(t),(r=n.c).join(o)!==a.c.join(o)))for(s=(i=t.replace(Te,"1").split(W)).length-1;h<s;h++)o+=i[h]+(~r.indexOf(h)?c.shift()||l+"0,0,0,0)":(a.length?a:c.length?c:n).shift());if(!i)for(s=(i=t.split(Te)).length-1;h<s;h++)o+=i[h]+c[h];return o+i[s]},Te=function(){var t,e="(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";for(t in ye)e+="|"+t+"\\b";return new RegExp(e+")","gi")}(),we=/hsl[a]?\(/,Ae=function(t){var e,n=t.join(" ");if(Te.lastIndex=0,Te.test(n))return e=we.test(n),t[1]=be(t[1],e),t[0]=be(t[0],e,$e(t[1])),!0},ke=function(){var t,e,n,r,i,a,s=Date.now,o=500,c=33,l=s(),h=l,m=1e3/240,_=m,v=[],y=function n(u){var p,d,f,g,y=s()-h,x=!0===u;if(y>o&&(l+=y-c),((p=(f=(h+=y)-l)-_)>0||x)&&(g=++r.frame,i=f-1e3*r.time,r.time=f/=1e3,_+=p+(p>=m?4:m-p),d=1),x||(t=e(n)),d)for(a=0;a<v.length;a++)v[a](f,i,g,u)};return r={time:0,frame:0,tick:function(){y(!0)},deltaRatio:function(t){return i/(1e3/(t||60))},wake:function(){f&&(!p&&D()&&(u=p=window,d=u.document||{},G.gsap=kn,(u.gsapVersions||(u.gsapVersions=[])).push(kn.version),Q(Y||u.GreenSockGlobals||!u.gsap&&u||{}),n=u.requestAnimationFrame,_e.forEach(ge)),t&&r.sleep(),e=n||function(t){return setTimeout(t,_-1e3*r.time+1|0)},g=1,y(2))},sleep:function(){(n?u.cancelAnimationFrame:clearTimeout)(t),g=0,e=tt},lagSmoothing:function(t,e){o=t||1/0,c=Math.min(e||33,o)},fps:function(t){m=1e3/(t||240),_=1e3*r.time+m},add:function(t,e,n){var i=e?function(e,n,a,s){t(e,n,a,s),r.remove(i)}:t;return r.remove(t),v[n?"unshift":"push"](i),Se(),i},remove:function(t,e){~(e=v.indexOf(t))&&v.splice(e,1)&&a>=e&&a--},_listeners:v}}(),Se=function(){return!g&&ke.wake()},Pe={},Ne=/^[\d.\-M][\d.\-,\s]/,Me=/["']/g,Be=function(t){for(var e,n,r,i={},a=t.substr(1,t.length-3).split(":"),s=a[0],o=1,c=a.length;o<c;o++)n=a[o],e=o!==c-1?n.lastIndexOf(","):n.length,r=n.substr(0,e),i[s]=isNaN(r)?r.replace(Me,"").trim():+r,s=n.substr(e+1).trim();return i},je=function(t){return function(e){return 1-t(1-e)}},Le=function t(e,n){for(var r,i=e._first;i;)i instanceof Fe?t(i,n):!i.vars.yoyoEase||i._yoyo&&i._repeat||i._yoyo===n||(i.timeline?t(i.timeline,n):(r=i._ease,i._ease=i._yEase,i._yEase=r,i._yoyo=n)),i=i._next},Oe=function(t,e){return t&&(j(t)?t:Pe[t]||function(t){var e,n,r,i,a=(t+"").split("("),s=Pe[a[0]];return s&&a.length>1&&s.config?s.config.apply(null,~t.indexOf("{")?[Be(a[1])]:(e=t,n=e.indexOf("(")+1,r=e.indexOf(")"),i=e.indexOf("(",n),e.substring(n,~i&&i<r?e.indexOf(")",r+1):r)).split(",").map($t)):Pe._CE&&Ne.test(t)?Pe._CE("",t):s}(t))||e},Re=function(t,e,n,r){void 0===n&&(n=function(t){return 1-e(1-t)}),void 0===r&&(r=function(t){return t<.5?e(2*t)/2:1-e(2*(1-t))/2});var i,a={easeIn:e,easeOut:n,easeInOut:r};return mt(t,(function(t){for(var e in Pe[t]=G[t]=a,Pe[i=t.toLowerCase()]=n,a)Pe[i+("easeIn"===e?".in":"easeOut"===e?".out":".inOut")]=Pe[t+"."+e]=a[e]})),a},Ue=function(t){return function(e){return e<.5?(1-t(1-2*e))/2:.5+t(2*(e-.5))/2}},De=function t(e,n,r){var i=n>=1?n:1,a=(r||(e?.3:.45))/(n<1?n:1),s=a/A*(Math.asin(1/i)||0),o=function(t){return 1===t?1:i*Math.pow(2,-10*t)*M((t-s)*a)+1},c="out"===e?o:"in"===e?function(t){return 1-o(1-t)}:Ue(o);return a=A/a,c.config=function(n,r){return t(e,n,r)},c},Ie=function t(e,n){void 0===n&&(n=1.70158);var r=function(t){return t?--t*t*((n+1)*t+n)+1:0},i="out"===e?r:"in"===e?function(t){return 1-r(1-t)}:Ue(r);return i.config=function(n){return t(e,n)},i};mt("Linear,Quad,Cubic,Quart,Quint,Strong",(function(t,e){var n=e<5?e+1:e;Re(t+",Power"+(n-1),e?function(t){return Math.pow(t,n)}:function(t){return t},(function(t){return 1-Math.pow(1-t,n)}),(function(t){return t<.5?Math.pow(2*t,n)/2:1-Math.pow(2*(1-t),n)/2}))})),Pe.Linear.easeNone=Pe.none=Pe.Linear.easeIn,Re("Elastic",De("in"),De("out"),De()),v=7.5625,x=1/(y=2.75),Re("Bounce",(function(t){return 1-C(1-t)}),C=function(t){return t<x?v*t*t:t<.7272727272727273?v*Math.pow(t-1.5/y,2)+.75:t<.9090909090909092?v*(t-=2.25/y)*t+.9375:v*Math.pow(t-2.625/y,2)+.984375}),Re("Expo",(function(t){return t?Math.pow(2,10*(t-1)):0})),Re("Circ",(function(t){return-(P(1-t*t)-1)})),Re("Sine",(function(t){return 1===t?1:1-N(t*k)})),Re("Back",Ie("in"),Ie("out"),Ie()),Pe.SteppedEase=Pe.steps=G.SteppedEase={config:function(t,e){void 0===t&&(t=1);var n=1/t,r=t+(e?0:1),i=e?1:0;return function(t){return((r*Jt(0,.99999999,t)|0)+i)*n}}},b.ease=Pe["quad.out"],mt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",(function(t){return ut+=t+","+t+"Params,"}));var Ee=function(t,e){this.id=S++,t._gsap=this,this.target=t,this.harness=e,this.get=e?e.get:ft,this.set=e?e.getSetter:an},qe=function(){function t(t){this.vars=t,this._delay=+t.delay||0,(this._repeat=t.repeat===1/0?-2:t.repeat||0)&&(this._rDelay=t.repeatDelay||0,this._yoyo=!!t.yoyo||!!t.yoyoEase),this._ts=1,Kt(this,+t.duration,1,1),this.data=t.data,l&&(this._ctx=l,l.data.push(this)),g||ke.wake()}var e=t.prototype;return e.delay=function(t){return t||0===t?(this.parent&&this.parent.smoothChildTiming&&this.startTime(this._start+t-this._delay),this._delay=t,this):this._delay},e.duration=function(t){return arguments.length?this.totalDuration(this._repeat>0?t+(t+this._rDelay)*this._repeat:t):this.totalDuration()&&this._dur},e.totalDuration=function(t){return arguments.length?(this._dirty=0,Kt(this,this._repeat<0?t:(t-this._repeat*this._rDelay)/(this._repeat+1))):this._tDur},e.totalTime=function(t,e){if(Se(),!arguments.length)return this._tTime;var n=this._dp;if(n&&n.smoothChildTiming&&this._ts){for(It(this,t),!n._dp||n.parent||Et(n,this);n&&n.parent;)n.parent._time!==n._start+(n._ts>=0?n._tTime/n._ts:(n.totalDuration()-n._tTime)/-n._ts)&&n.totalTime(n._tTime,!0),n=n.parent;!this.parent&&this._dp.autoRemoveChildren&&(this._ts>0&&t<this._tDur||this._ts<0&&t>0||!this._tDur&&!t)&&qt(this._dp,this,this._start-this._delay)}return(this._tTime!==t||!this._dur&&!e||this._initted&&Math.abs(this._zTime)===w||!t&&!this._initted&&(this.add||this._ptLookup))&&(this._ts||(this._pTime=t),Ct(this,t,e)),this},e.time=function(t,e){return arguments.length?this.totalTime(Math.min(this.totalDuration(),t+Ot(this))%(this._dur+this._rDelay)||(t?this._dur:0),e):this._time},e.totalProgress=function(t,e){return arguments.length?this.totalTime(this.totalDuration()*t,e):this.totalDuration()?Math.min(1,this._tTime/this._tDur):this.ratio},e.progress=function(t,e){return arguments.length?this.totalTime(this.duration()*(!this._yoyo||1&this.iteration()?t:1-t)+Ot(this),e):this.duration()?Math.min(1,this._time/this._dur):this.ratio},e.iteration=function(t,e){var n=this.duration()+this._rDelay;return arguments.length?this.totalTime(this._time+(t-1)*n,e):this._repeat?Rt(this._tTime,n)+1:1},e.timeScale=function(t){if(!arguments.length)return-1e-8===this._rts?0:this._rts;if(this._rts===t)return this;var e=this.parent&&this._ts?Ut(this.parent._time,this):this._tTime;return this._rts=+t||0,this._ts=this._ps||-1e-8===t?0:this._rts,this.totalTime(Jt(-Math.abs(this._delay),this._tDur,e),!0),Dt(this),function(t){for(var e=t.parent;e&&e.parent;)e._dirty=1,e.totalDuration(),e=e.parent;return t}(this)},e.paused=function(t){return arguments.length?(this._ps!==t&&(this._ps=t,t?(this._pTime=this._tTime||Math.max(-this._delay,this.rawTime()),this._ts=this._act=0):(Se(),this._ts=this._rts,this.totalTime(this.parent&&!this.parent.smoothChildTiming?this.rawTime():this._tTime||this._pTime,1===this.progress()&&Math.abs(this._zTime)!==w&&(this._tTime-=w)))),this):this._ps},e.startTime=function(t){if(arguments.length){this._start=t;var e=this.parent||this._dp;return e&&(e._sort||!this.parent)&&qt(e,this,t-this._delay),this}return this._start},e.endTime=function(t){return this._start+(U(t)?this.totalDuration():this.duration())/Math.abs(this._ts||1)},e.rawTime=function(t){var e=this.parent||this._dp;return e?t&&(!this._ts||this._repeat&&this._time&&this.totalProgress()<1)?this._tTime%(this._dur+this._rDelay):this._ts?Ut(e.rawTime(t),this):this._tTime:this._tTime},e.revert=function(t){void 0===t&&(t=rt);var e=c;return c=t,(this._initted||this._startAt)&&(this.timeline&&this.timeline.revert(t),this.totalTime(-.01,t.suppressEvents)),"nested"!==this.data&&!1!==t.kill&&this.kill(),c=e,this},e.globalTime=function(t){for(var e=this,n=arguments.length?t:e.rawTime();e;)n=e._start+n/(e._ts||1),e=e._dp;return!this.parent&&this._sat?this._sat.vars.immediateRender?-1/0:this._sat.globalTime(t):n},e.repeat=function(t){return arguments.length?(this._repeat=t===1/0?-2:t,Ht(this)):-2===this._repeat?1/0:this._repeat},e.repeatDelay=function(t){if(arguments.length){var e=this._time;return this._rDelay=t,Ht(this),e?this.time(e):this}return this._rDelay},e.yoyo=function(t){return arguments.length?(this._yoyo=t,this):this._yoyo},e.seek=function(t,e){return this.totalTime(Gt(this,t),U(e))},e.restart=function(t,e){return this.play().totalTime(t?-this._delay:0,U(e))},e.play=function(t,e){return null!=t&&this.seek(t,e),this.reversed(!1).paused(!1)},e.reverse=function(t,e){return null!=t&&this.seek(t||this.totalDuration(),e),this.reversed(!0).paused(!1)},e.pause=function(t,e){return null!=t&&this.seek(t,e),this.paused(!0)},e.resume=function(){return this.paused(!1)},e.reversed=function(t){return arguments.length?(!!t!==this.reversed()&&this.timeScale(-this._rts||(t?-1e-8:0)),this):this._rts<0},e.invalidate=function(){return this._initted=this._act=0,this._zTime=-1e-8,this},e.isActive=function(){var t,e=this.parent||this._dp,n=this._start;return!(e&&!(this._ts&&this._initted&&e.isActive()&&(t=e.rawTime(!0))>=n&&t<this.endTime(!0)-w))},e.eventCallback=function(t,e,n){var r=this.vars;return arguments.length>1?(e?(r[t]=e,n&&(r[t+"Params"]=n),"onUpdate"===t&&(this._onUpdate=e)):delete r[t],this):r[t]},e.then=function(t){var e=this;return new Promise((function(n){var r=j(t)?t:bt,i=function(){var t=e.then;e.then=null,j(r)&&(r=r(e))&&(r.then||r===e)&&(e.then=t),n(r),e.then=t};e._initted&&1===e.totalProgress()&&e._ts>=0||!e._tTime&&e._ts<0?i():e._prom=i}))},e.kill=function(){me(this)},t}();Tt(qe.prototype,{_time:0,_start:0,_end:0,_tTime:0,_tDur:0,_dirty:0,_repeat:0,_yoyo:!1,parent:null,_initted:!1,_rDelay:0,_ts:1,_dp:0,ratio:0,_zTime:-1e-8,_prom:0,_ps:!1,_rts:1});var Fe=function(t){function e(e,n){var r;return void 0===e&&(e={}),(r=t.call(this,e)||this).labels={},r.smoothChildTiming=!!e.smoothChildTiming,r.autoRemoveChildren=!!e.autoRemoveChildren,r._sort=U(e.sortChildren),h&&qt(e.parent||h,a(r),n),e.reversed&&r.reverse(),e.paused&&r.paused(!0),e.scrollTrigger&&Ft(a(r),e.scrollTrigger),r}s(e,t);var n=e.prototype;return n.to=function(t,e,n){return Yt(0,arguments,this),this},n.from=function(t,e,n){return Yt(1,arguments,this),this},n.fromTo=function(t,e,n,r){return Yt(2,arguments,this),this},n.set=function(t,e,n){return e.duration=0,e.parent=this,St(e).repeatDelay||(e.repeat=0),e.immediateRender=!!e.immediateRender,new Ze(t,e,Gt(this,n),1),this},n.call=function(t,e,n){return qt(this,Ze.delayedCall(0,t,e),n)},n.staggerTo=function(t,e,n,r,i,a,s){return n.duration=e,n.stagger=n.stagger||r,n.onComplete=a,n.onCompleteParams=s,n.parent=this,new Ze(t,n,Gt(this,i)),this},n.staggerFrom=function(t,e,n,r,i,a,s){return n.runBackwards=1,St(n).immediateRender=U(n.immediateRender),this.staggerTo(t,e,n,r,i,a,s)},n.staggerFromTo=function(t,e,n,r,i,a,s,o){return r.startAt=n,St(r).immediateRender=U(r.immediateRender),this.staggerTo(t,e,r,i,a,s,o)},n.render=function(t,e,n){var r,i,a,s,o,l,u,p,d,f,m,_,g=this._time,v=this._dirty?this.totalDuration():this._tDur,y=this._dur,x=t<=0?0:gt(t),C=this._zTime<0!=t<0&&(this._initted||!y);if(this!==h&&x>v&&t>=0&&(x=v),x!==this._tTime||n||C){if(g!==this._time&&y&&(x+=this._time-g,t+=this._time-g),r=x,d=this._start,l=!(p=this._ts),C&&(y||(g=this._zTime),(t||!e)&&(this._zTime=t)),this._repeat){if(m=this._yoyo,o=y+this._rDelay,this._repeat<-1&&t<0)return this.totalTime(100*o+t,e,n);if(r=gt(x%o),x===v?(s=this._repeat,r=y):((s=~~(x/o))&&s===x/o&&(r=y,s--),r>y&&(r=y)),f=Rt(this._tTime,o),!g&&this._tTime&&f!==s&&this._tTime-f*o-this._dur<=0&&(f=s),m&&1&s&&(r=y-r,_=1),s!==f&&!this._lock){var $=m&&1&f,b=$===(m&&1&s);if(s<f&&($=!$),g=$?0:x%y?y:x,this._lock=1,this.render(g||(_?0:gt(s*o)),e,!y)._lock=0,this._tTime=x,!e&&this.parent&&fe(this,"onRepeat"),this.vars.repeatRefresh&&!_&&(this.invalidate()._lock=1),g&&g!==this._time||l!==!this._ts||this.vars.onRepeat&&!this.parent&&!this._act)return this;if(y=this._dur,v=this._tDur,b&&(this._lock=2,g=$?y:-1e-4,this.render(g,!0),this.vars.repeatRefresh&&!_&&this.invalidate()),this._lock=0,!this._ts&&!l)return this;Le(this,_)}}if(this._hasPause&&!this._forcing&&this._lock<2&&(u=function(t,e,n){var r;if(n>e)for(r=t._first;r&&r._start<=n;){if("isPause"===r.data&&r._start>e)return r;r=r._next}else for(r=t._last;r&&r._start>=n;){if("isPause"===r.data&&r._start<e)return r;r=r._prev}}(this,gt(g),gt(r)),u&&(x-=r-(r=u._start))),this._tTime=x,this._time=r,this._act=!p,this._initted||(this._onUpdate=this.vars.onUpdate,this._initted=1,this._zTime=t,g=0),!g&&r&&!e&&!s&&(fe(this,"onStart"),this._tTime!==x))return this;if(r>=g&&t>=0)for(i=this._first;i;){if(a=i._next,(i._act||r>=i._start)&&i._ts&&u!==i){if(i.parent!==this)return this.render(t,e,n);if(i.render(i._ts>0?(r-i._start)*i._ts:(i._dirty?i.totalDuration():i._tDur)+(r-i._start)*i._ts,e,n),r!==this._time||!this._ts&&!l){u=0,a&&(x+=this._zTime=-1e-8);break}}i=a}else{i=this._last;for(var T=t<0?t:r;i;){if(a=i._prev,(i._act||T<=i._end)&&i._ts&&u!==i){if(i.parent!==this)return this.render(t,e,n);if(i.render(i._ts>0?(T-i._start)*i._ts:(i._dirty?i.totalDuration():i._tDur)+(T-i._start)*i._ts,e,n||c&&(i._initted||i._startAt)),r!==this._time||!this._ts&&!l){u=0,a&&(x+=this._zTime=T?-1e-8:w);break}}i=a}}if(u&&!e&&(this.pause(),u.render(r>=g?0:-1e-8)._zTime=r>=g?1:-1,this._ts))return this._start=d,Dt(this),this.render(t,e,n);this._onUpdate&&!e&&fe(this,"onUpdate",!0),(x===v&&this._tTime>=this.totalDuration()||!x&&g)&&(d!==this._start&&Math.abs(p)===Math.abs(this._ts)||this._lock||((t||!y)&&(x===v&&this._ts>0||!x&&this._ts<0)&&Mt(this,1),e||t<0&&!g||!x&&!g&&v||(fe(this,x===v&&t>=0?"onComplete":"onReverseComplete",!0),this._prom&&!(x<v&&this.timeScale()>0)&&this._prom())))}return this},n.add=function(t,e){var n=this;if(L(e)||(e=Gt(this,e,t)),!(t instanceof qe)){if(q(t))return t.forEach((function(t){return n.add(t,e)})),this;if(B(t))return this.addLabel(t,e);if(!j(t))return this;t=Ze.delayedCall(0,t)}return this!==t?qt(this,t,e):this},n.getChildren=function(t,e,n,r){void 0===t&&(t=!0),void 0===e&&(e=!0),void 0===n&&(n=!0),void 0===r&&(r=-T);for(var i=[],a=this._first;a;)a._start>=r&&(a instanceof Ze?e&&i.push(a):(n&&i.push(a),t&&i.push.apply(i,a.getChildren(!0,e,n)))),a=a._next;return i},n.getById=function(t){for(var e=this.getChildren(1,1,1),n=e.length;n--;)if(e[n].vars.id===t)return e[n]},n.remove=function(t){return B(t)?this.removeLabel(t):j(t)?this.killTweensOf(t):(Nt(this,t),t===this._recent&&(this._recent=this._last),Bt(this))},n.totalTime=function(e,n){return arguments.length?(this._forcing=1,!this._dp&&this._ts&&(this._start=gt(ke.time-(this._ts>0?e/this._ts:(this.totalDuration()-e)/-this._ts))),t.prototype.totalTime.call(this,e,n),this._forcing=0,this):this._tTime},n.addLabel=function(t,e){return this.labels[t]=Gt(this,e),this},n.removeLabel=function(t){return delete this.labels[t],this},n.addPause=function(t,e,n){var r=Ze.delayedCall(0,e||tt,n);return r.data="isPause",this._hasPause=1,qt(this,r,Gt(this,t))},n.removePause=function(t){var e=this._first;for(t=Gt(this,t);e;)e._start===t&&"isPause"===e.data&&Mt(e),e=e._next},n.killTweensOf=function(t,e,n){for(var r=this.getTweensOf(t,n),i=r.length;i--;)ze!==r[i]&&r[i].kill(t,e);return this},n.getTweensOf=function(t,e){for(var n,r=[],i=re(t),a=this._first,s=L(e);a;)a instanceof Ze?yt(a._targets,i)&&(s?(!ze||a._initted&&a._ts)&&a.globalTime(0)<=e&&a.globalTime(a.totalDuration())>e:!e||a.isActive())&&r.push(a):(n=a.getTweensOf(i,e)).length&&r.push.apply(r,n),a=a._next;return r},n.tweenTo=function(t,e){e=e||{};var n,r=this,i=Gt(r,t),a=e,s=a.startAt,o=a.onStart,c=a.onStartParams,l=a.immediateRender,h=Ze.to(r,Tt({ease:e.ease||"none",lazy:!1,immediateRender:!1,time:i,overwrite:"auto",duration:e.duration||Math.abs((i-(s&&"time"in s?s.time:r._time))/r.timeScale())||w,onStart:function(){if(r.pause(),!n){var t=e.duration||Math.abs((i-(s&&"time"in s?s.time:r._time))/r.timeScale());h._dur!==t&&Kt(h,t,0,1).render(h._time,!0,!0),n=1}o&&o.apply(h,c||[])}},e));return l?h.render(0):h},n.tweenFromTo=function(t,e,n){return this.tweenTo(e,Tt({startAt:{time:Gt(this,t)}},n))},n.recent=function(){return this._recent},n.nextLabel=function(t){return void 0===t&&(t=this._time),de(this,Gt(this,t))},n.previousLabel=function(t){return void 0===t&&(t=this._time),de(this,Gt(this,t),1)},n.currentLabel=function(t){return arguments.length?this.seek(t,!0):this.previousLabel(this._time+w)},n.shiftChildren=function(t,e,n){void 0===n&&(n=0);for(var r,i=this._first,a=this.labels;i;)i._start>=n&&(i._start+=t,i._end+=t),i=i._next;if(e)for(r in a)a[r]>=n&&(a[r]+=t);return Bt(this)},n.invalidate=function(e){var n=this._first;for(this._lock=0;n;)n.invalidate(e),n=n._next;return t.prototype.invalidate.call(this,e)},n.clear=function(t){void 0===t&&(t=!0);for(var e,n=this._first;n;)e=n._next,this.remove(n),n=e;return this._dp&&(this._time=this._tTime=this._pTime=0),t&&(this.labels={}),Bt(this)},n.totalDuration=function(t){var e,n,r,i=0,a=this,s=a._last,o=T;if(arguments.length)return a.timeScale((a._repeat<0?a.duration():a.totalDuration())/(a.reversed()?-t:t));if(a._dirty){for(r=a.parent;s;)e=s._prev,s._dirty&&s.totalDuration(),(n=s._start)>o&&a._sort&&s._ts&&!a._lock?(a._lock=1,qt(a,s,n-s._delay,1)._lock=0):o=n,n<0&&s._ts&&(i-=n,(!r&&!a._dp||r&&r.smoothChildTiming)&&(a._start+=n/a._ts,a._time-=n,a._tTime-=n),a.shiftChildren(-n,!1,-Infinity),o=0),s._end>i&&s._ts&&(i=s._end),s=e;Kt(a,a===h&&a._time>i?a._time:i,1,1),a._dirty=0}return a._tDur},e.updateRoot=function(t){if(h._ts&&(Ct(h,Ut(t,h)),m=ke.frame),ke.frame>=lt){lt+=$.autoSleep||120;var e=h._first;if((!e||!e._ts)&&$.autoSleep&&ke._listeners.length<2){for(;e&&!e._ts;)e=e._next;e||ke.sleep()}}},e}(qe);Tt(Fe.prototype,{_lock:0,_hasPause:0,_forcing:0});var ze,We,Ve=function(t,e,n,r,i,a,s){var o,c,l,h,u,p,d,f,m=new fn(this._pt,t,e,0,1,cn,null,i),_=0,g=0;for(m.b=n,m.e=r,n+="",(d=~(r+="").indexOf("random("))&&(r=ue(r)),a&&(a(f=[n,r],t,e),n=f[0],r=f[1]),c=n.match(V)||[];o=V.exec(r);)h=o[0],u=r.substring(_,o.index),l?l=(l+1)%5:"rgba("===u.substr(-5)&&(l=1),h!==c[g++]&&(p=parseFloat(c[g-1])||0,m._pt={_next:m._pt,p:u||1===g?u:",",s:p,c:"="===h.charAt(1)?vt(p,h)-p:parseFloat(h)-p,m:l&&l<4?Math.round:0},_=V.lastIndex);return m.c=_<r.length?r.substring(_,r.length):"",m.fp=s,(K.test(r)||d)&&(m.e=0),this._pt=m,m},Ke=function(t,e,n,r,i,a,s,o,c,l){j(r)&&(r=r(i||0,t,a));var h,u=t[e],p="get"!==n?n:j(u)?c?t[e.indexOf("set")||!j(t["get"+e.substr(3)])?e:"get"+e.substr(3)](c):t[e]():u,d=j(u)?c?nn:en:tn;if(B(r)&&(~r.indexOf("random(")&&(r=ue(r)),"="===r.charAt(1)&&((h=vt(p,r)+(Zt(p)||0))||0===h)&&(r=h)),!l||p!==r||We)return isNaN(p*r)||""===r?Ve.call(this,t,e,p,r,d,o||$.stringFilter,c):(h=new fn(this._pt,t,e,+p||0,r-(p||0),"boolean"==typeof u?on:sn,0,d),c&&(h.fp=c),s&&h.modifier(s,this,t),this._pt=h)},He=function(t,e,n,r,i,a){var s,o,c,l;if(ot[t]&&!1!==(s=new ot[t]).init(i,s.rawVars?e[t]:function(t,e,n,r,i){if(j(t)&&(t=Ye(t,i,e,n,r)),!R(t)||t.style&&t.nodeType||q(t)||E(t))return B(t)?Ye(t,i,e,n,r):t;var a,s={};for(a in t)s[a]=Ye(t[a],i,e,n,r);return s}(e[t],r,i,a,n),n,r,a)&&(n._pt=o=new fn(n._pt,i,t,0,1,s.render,s,0,s.priority),n!==_))for(c=n._ptLookup[n._targets.indexOf(i)],l=s._props.length;l--;)c[s._props[l]]=o;return s},Xe=function t(e,n,r){var i,a,s,l,u,p,d,f,m,_,g,v,y,x=e.vars,C=x.ease,$=x.startAt,A=x.immediateRender,k=x.lazy,S=x.onUpdate,P=x.onUpdateParams,N=x.callbackScope,M=x.runBackwards,B=x.yoyoEase,j=x.keyframes,L=x.autoRevert,O=e._dur,R=e._startAt,D=e._targets,I=e.parent,E=I&&"nested"===I.data?I.vars.targets:D,q="auto"===e._overwrite&&!o,F=e.timeline;if(F&&(!j||!C)&&(C="none"),e._ease=Oe(C,b.ease),e._yEase=B?je(Oe(!0===B?C:B,b.ease)):0,B&&e._yoyo&&!e._repeat&&(B=e._yEase,e._yEase=e._ease,e._ease=B),e._from=!F&&!!x.runBackwards,!F||j&&!x.stagger){if(v=(f=D[0]?dt(D[0]).harness:0)&&x[f.prop],i=kt(x,it),R&&(R._zTime<0&&R.progress(1),n<0&&M&&A&&!L?R.render(-1,!0):R.revert(M&&O?nt:et),R._lazy=0),$){if(Mt(e._startAt=Ze.set(D,Tt({data:"isStart",overwrite:!1,parent:I,immediateRender:!0,lazy:!R&&U(k),startAt:null,delay:0,onUpdate:S,onUpdateParams:P,callbackScope:N,stagger:0},$))),e._startAt._dp=0,e._startAt._sat=e,n<0&&(c||!A&&!L)&&e._startAt.revert(nt),A&&O&&n<=0&&r<=0)return void(n&&(e._zTime=n))}else if(M&&O&&!R)if(n&&(A=!1),s=Tt({overwrite:!1,data:"isFromStart",lazy:A&&!R&&U(k),immediateRender:A,stagger:0,parent:I},i),v&&(s[f.prop]=v),Mt(e._startAt=Ze.set(D,s)),e._startAt._dp=0,e._startAt._sat=e,n<0&&(c?e._startAt.revert(nt):e._startAt.render(-1,!0)),e._zTime=n,A){if(!n)return}else t(e._startAt,w,w);for(e._pt=e._ptCache=0,k=O&&U(k)||k&&!O,a=0;a<D.length;a++){if(d=(u=D[a])._gsap||pt(D)[a]._gsap,e._ptLookup[a]=_={},st[d.id]&&at.length&&xt(),g=E===D?a:E.indexOf(u),f&&!1!==(m=new f).init(u,v||i,e,g,E)&&(e._pt=l=new fn(e._pt,u,m.name,0,1,m.render,m,0,m.priority),m._props.forEach((function(t){_[t]=l})),m.priority&&(p=1)),!f||v)for(s in i)ot[s]&&(m=He(s,i,e,g,u,E))?m.priority&&(p=1):_[s]=l=Ke.call(e,u,s,"get",i[s],g,E,0,x.stringFilter);e._op&&e._op[a]&&e.kill(u,e._op[a]),q&&e._pt&&(ze=e,h.killTweensOf(u,_,e.globalTime(n)),y=!e.parent,ze=0),e._pt&&k&&(st[d.id]=1)}p&&dn(e),e._onInit&&e._onInit(e)}e._onUpdate=S,e._initted=(!e._op||e._pt)&&!y,j&&n<=0&&F.render(T,!0,!0)},Ge=function(t,e,n,r){var i,a,s=e.ease||r||"power1.inOut";if(q(e))a=n[t]||(n[t]=[]),e.forEach((function(t,n){return a.push({t:n/(e.length-1)*100,v:t,e:s})}));else for(i in e)a=n[i]||(n[i]=[]),"ease"===i||a.push({t:parseFloat(t),v:e[i],e:s})},Ye=function(t,e,n,r,i){return j(t)?t.call(e,n,r,i):B(t)&&~t.indexOf("random(")?ue(t):t},Qe=ut+"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",Je={};mt(Qe+",id,stagger,delay,duration,paused,scrollTrigger",(function(t){return Je[t]=1}));var Ze=function(t){function e(e,n,r,i){var s;"number"==typeof n&&(r.duration=n,n=r,r=null);var c,l,u,p,d,f,m,_,g=(s=t.call(this,i?n:St(n))||this).vars,v=g.duration,y=g.delay,x=g.immediateRender,C=g.stagger,b=g.overwrite,T=g.keyframes,w=g.defaults,A=g.scrollTrigger,k=g.yoyoEase,S=n.parent||h,P=(q(e)||E(e)?L(e[0]):"length"in n)?[e]:re(e);if(s._targets=P.length?pt(P):J(0,!$.nullTargetWarn)||[],s._ptLookup=[],s._overwrite=b,T||C||I(v)||I(y)){if(n=s.vars,(c=s.timeline=new Fe({data:"nested",defaults:w||{},targets:S&&"nested"===S.data?S.vars.targets:P})).kill(),c.parent=c._dp=a(s),c._start=0,C||I(v)||I(y)){if(p=P.length,m=C&&se(C),R(C))for(d in C)~Qe.indexOf(d)&&(_||(_={}),_[d]=C[d]);for(l=0;l<p;l++)(u=kt(n,Je)).stagger=0,k&&(u.yoyoEase=k),_&&wt(u,_),f=P[l],u.duration=+Ye(v,a(s),l,f,P),u.delay=(+Ye(y,a(s),l,f,P)||0)-s._delay,!C&&1===p&&u.delay&&(s._delay=y=u.delay,s._start+=y,u.delay=0),c.to(f,u,m?m(l,f,P):0),c._ease=Pe.none;c.duration()?v=y=0:s.timeline=0}else if(T){St(Tt(c.vars.defaults,{ease:"none"})),c._ease=Oe(T.ease||n.ease||"none");var N,M,B,j=0;if(q(T))T.forEach((function(t){return c.to(P,t,">")})),c.duration();else{for(d in u={},T)"ease"===d||"easeEach"===d||Ge(d,T[d],u,T.easeEach);for(d in u)for(N=u[d].sort((function(t,e){return t.t-e.t})),j=0,l=0;l<N.length;l++)(B={ease:(M=N[l]).e,duration:(M.t-(l?N[l-1].t:0))/100*v})[d]=M.v,c.to(P,B,j),j+=B.duration;c.duration()<v&&c.to({},{duration:v-c.duration()})}}v||s.duration(v=c.duration())}else s.timeline=0;return!0!==b||o||(ze=a(s),h.killTweensOf(P),ze=0),qt(S,a(s),r),n.reversed&&s.reverse(),n.paused&&s.paused(!0),(x||!v&&!T&&s._start===gt(S._time)&&U(x)&&Lt(a(s))&&"nested"!==S.data)&&(s._tTime=-1e-8,s.render(Math.max(0,-y)||0)),A&&Ft(a(s),A),s}s(e,t);var n=e.prototype;return n.render=function(t,e,n){var r,i,a,s,o,l,h,u,p,d=this._time,f=this._tDur,m=this._dur,_=t<0,g=t>f-w&&!_?f:t<w?0:t;if(m){if(g!==this._tTime||!t||n||!this._initted&&this._tTime||this._startAt&&this._zTime<0!==_){if(r=g,u=this.timeline,this._repeat){if(s=m+this._rDelay,this._repeat<-1&&_)return this.totalTime(100*s+t,e,n);if(r=gt(g%s),g===f?(a=this._repeat,r=m):((a=~~(g/s))&&a===g/s&&(r=m,a--),r>m&&(r=m)),(l=this._yoyo&&1&a)&&(p=this._yEase,r=m-r),o=Rt(this._tTime,s),r===d&&!n&&this._initted)return this._tTime=g,this;a!==o&&(u&&this._yEase&&Le(u,l),!this.vars.repeatRefresh||l||this._lock||(this._lock=n=1,this.render(gt(s*a),!0).invalidate()._lock=0))}if(!this._initted){if(zt(this,_?t:r,n,e,g))return this._tTime=0,this;if(d!==this._time)return this;if(m!==this._dur)return this.render(t,e,n)}if(this._tTime=g,this._time=r,!this._act&&this._ts&&(this._act=1,this._lazy=0),this.ratio=h=(p||this._ease)(r/m),this._from&&(this.ratio=h=1-h),r&&!d&&!e&&!a&&(fe(this,"onStart"),this._tTime!==g))return this;for(i=this._pt;i;)i.r(h,i.d),i=i._next;u&&u.render(t<0?t:!r&&l?-1e-8:u._dur*u._ease(r/this._dur),e,n)||this._startAt&&(this._zTime=t),this._onUpdate&&!e&&(_&&jt(this,t,0,n),fe(this,"onUpdate")),this._repeat&&a!==o&&this.vars.onRepeat&&!e&&this.parent&&fe(this,"onRepeat"),g!==this._tDur&&g||this._tTime!==g||(_&&!this._onUpdate&&jt(this,t,0,!0),(t||!m)&&(g===this._tDur&&this._ts>0||!g&&this._ts<0)&&Mt(this,1),e||_&&!d||!(g||d||l)||(fe(this,g===f?"onComplete":"onReverseComplete",!0),this._prom&&!(g<f&&this.timeScale()>0)&&this._prom()))}}else!function(t,e,n,r){var i,a,s,o=t.ratio,l=e<0||!e&&(!t._start&&Wt(t)&&(t._initted||!Vt(t))||(t._ts<0||t._dp._ts<0)&&!Vt(t))?0:1,h=t._rDelay,u=0;if(h&&t._repeat&&(u=Jt(0,t._tDur,e),a=Rt(u,h),t._yoyo&&1&a&&(l=1-l),a!==Rt(t._tTime,h)&&(o=1-l,t.vars.repeatRefresh&&t._initted&&t.invalidate())),l!==o||c||r||t._zTime===w||!e&&t._zTime){if(!t._initted&&zt(t,e,r,n,u))return;for(s=t._zTime,t._zTime=e||(n?w:0),n||(n=e&&!s),t.ratio=l,t._from&&(l=1-l),t._time=0,t._tTime=u,i=t._pt;i;)i.r(l,i.d),i=i._next;e<0&&jt(t,e,0,!0),t._onUpdate&&!n&&fe(t,"onUpdate"),u&&t._repeat&&!n&&t.parent&&fe(t,"onRepeat"),(e>=t._tDur||e<0)&&t.ratio===l&&(l&&Mt(t,1),n||c||(fe(t,l?"onComplete":"onReverseComplete",!0),t._prom&&t._prom()))}else t._zTime||(t._zTime=e)}(this,t,e,n);return this},n.targets=function(){return this._targets},n.invalidate=function(e){return(!e||!this.vars.runBackwards)&&(this._startAt=0),this._pt=this._op=this._onUpdate=this._lazy=this.ratio=0,this._ptLookup=[],this.timeline&&this.timeline.invalidate(e),t.prototype.invalidate.call(this,e)},n.resetTo=function(t,e,n,r){g||ke.wake(),this._ts||this.play();var i=Math.min(this._dur,(this._dp._time-this._start)*this._ts);return this._initted||Xe(this,i),function(t,e,n,r,i,a,s){var o,c,l,h,u=(t._pt&&t._ptCache||(t._ptCache={}))[e];if(!u)for(u=t._ptCache[e]=[],l=t._ptLookup,h=t._targets.length;h--;){if((o=l[h][e])&&o.d&&o.d._pt)for(o=o.d._pt;o&&o.p!==e&&o.fp!==e;)o=o._next;if(!o)return We=1,t.vars[e]="+=0",Xe(t,s),We=0,1;u.push(o)}for(h=u.length;h--;)(o=(c=u[h])._pt||c).s=!r&&0!==r||i?o.s+(r||0)+a*o.c:r,o.c=n-o.s,c.e&&(c.e=_t(n)+Zt(c.e)),c.b&&(c.b=o.s+Zt(c.b))}(this,t,e,n,r,this._ease(i/this._dur),i)?this.resetTo(t,e,n,r):(It(this,0),this.parent||Pt(this._dp,this,"_first","_last",this._dp._sort?"_start":0),this.render(0))},n.kill=function(t,e){if(void 0===e&&(e="all"),!(t||e&&"all"!==e))return this._lazy=this._pt=0,this.parent?me(this):this;if(this.timeline){var n=this.timeline.totalDuration();return this.timeline.killTweensOf(t,e,ze&&!0!==ze.vars.overwrite)._first||me(this),this.parent&&n!==this.timeline.totalDuration()&&Kt(this,this._dur*this.timeline._tDur/n,0,1),this}var r,i,a,s,o,c,l,h=this._targets,u=t?re(t):h,p=this._ptLookup,d=this._pt;if((!e||"all"===e)&&function(t,e){for(var n=t.length,r=n===e.length;r&&n--&&t[n]===e[n];);return n<0}(h,u))return"all"===e&&(this._pt=0),me(this);for(r=this._op=this._op||[],"all"!==e&&(B(e)&&(o={},mt(e,(function(t){return o[t]=1})),e=o),e=function(t,e){var n,r,i,a,s=t[0]?dt(t[0]).harness:0,o=s&&s.aliases;if(!o)return e;for(r in n=wt({},e),o)if(r in n)for(i=(a=o[r].split(",")).length;i--;)n[a[i]]=n[r];return n}(h,e)),l=h.length;l--;)if(~u.indexOf(h[l]))for(o in i=p[l],"all"===e?(r[l]=e,s=i,a={}):(a=r[l]=r[l]||{},s=e),s)(c=i&&i[o])&&("kill"in c.d&&!0!==c.d.kill(o)||Nt(this,c,"_pt"),delete i[o]),"all"!==a&&(a[o]=1);return this._initted&&!this._pt&&d&&me(this),this},e.to=function(t,n){return new e(t,n,arguments[2])},e.from=function(t,e){return Yt(1,arguments)},e.delayedCall=function(t,n,r,i){return new e(n,0,{immediateRender:!1,lazy:!1,overwrite:!1,delay:t,onComplete:n,onReverseComplete:n,onCompleteParams:r,onReverseCompleteParams:r,callbackScope:i})},e.fromTo=function(t,e,n){return Yt(2,arguments)},e.set=function(t,n){return n.duration=0,n.repeatDelay||(n.repeat=0),new e(t,n)},e.killTweensOf=function(t,e,n){return h.killTweensOf(t,e,n)},e}(qe);Tt(Ze.prototype,{_targets:[],_lazy:0,_startAt:0,_op:0,_onInit:0}),mt("staggerTo,staggerFrom,staggerFromTo",(function(t){Ze[t]=function(){var e=new Fe,n=te.call(arguments,0);return n.splice("staggerFromTo"===t?5:4,0,0),e[t].apply(e,n)}}));var tn=function(t,e,n){return t[e]=n},en=function(t,e,n){return t[e](n)},nn=function(t,e,n,r){return t[e](r.fp,n)},rn=function(t,e,n){return t.setAttribute(e,n)},an=function(t,e){return j(t[e])?en:O(t[e])&&t.setAttribute?rn:tn},sn=function(t,e){return e.set(e.t,e.p,Math.round(1e6*(e.s+e.c*t))/1e6,e)},on=function(t,e){return e.set(e.t,e.p,!!(e.s+e.c*t),e)},cn=function(t,e){var n=e._pt,r="";if(!t&&e.b)r=e.b;else if(1===t&&e.e)r=e.e;else{for(;n;)r=n.p+(n.m?n.m(n.s+n.c*t):Math.round(1e4*(n.s+n.c*t))/1e4)+r,n=n._next;r+=e.c}e.set(e.t,e.p,r,e)},ln=function(t,e){for(var n=e._pt;n;)n.r(t,n.d),n=n._next},hn=function(t,e,n,r){for(var i,a=this._pt;a;)i=a._next,a.p===r&&a.modifier(t,e,n),a=i},un=function(t){for(var e,n,r=this._pt;r;)n=r._next,r.p===t&&!r.op||r.op===t?Nt(this,r,"_pt"):r.dep||(e=1),r=n;return!e},pn=function(t,e,n,r){r.mSet(t,e,r.m.call(r.tween,n,r.mt),r)},dn=function(t){for(var e,n,r,i,a=t._pt;a;){for(e=a._next,n=r;n&&n.pr>a.pr;)n=n._next;(a._prev=n?n._prev:i)?a._prev._next=a:r=a,(a._next=n)?n._prev=a:i=a,a=e}t._pt=r},fn=function(){function t(t,e,n,r,i,a,s,o,c){this.t=e,this.s=r,this.c=i,this.p=n,this.r=a||sn,this.d=s||this,this.set=o||tn,this.pr=c||0,this._next=t,t&&(t._prev=this)}return t.prototype.modifier=function(t,e,n){this.mSet=this.mSet||this.set,this.set=pn,this.m=t,this.mt=n,this.tween=e},t}();mt(ut+"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",(function(t){return it[t]=1})),G.TweenMax=G.TweenLite=Ze,G.TimelineLite=G.TimelineMax=Fe,h=new Fe({sortChildren:!1,defaults:b,autoRemoveChildren:!0,id:"root",smoothChildTiming:!0}),$.stringFilter=Ae;var mn=[],_n={},gn=[],vn=0,yn=0,xn=function(t){return(_n[t]||gn).map((function(t){return t()}))},Cn=function(){var t=Date.now(),e=[];t-vn>2&&(xn("matchMediaInit"),mn.forEach((function(t){var n,r,i,a,s=t.queries,o=t.conditions;for(r in s)(n=u.matchMedia(s[r]).matches)&&(i=1),n!==o[r]&&(o[r]=n,a=1);a&&(t.revert(),i&&e.push(t))})),xn("matchMediaRevert"),e.forEach((function(t){return t.onMatch(t)})),vn=t,xn("matchMedia"))},$n=function(){function t(t,e){this.selector=e&&ie(e),this.data=[],this._r=[],this.isReverted=!1,this.id=yn++,t&&this.add(t)}var e=t.prototype;return e.add=function(t,e,n){j(t)&&(n=e,e=t,t=j);var r=this,i=function(){var t,i=l,a=r.selector;return i&&i!==r&&i.data.push(r),n&&(r.selector=ie(n)),l=r,t=e.apply(r,arguments),j(t)&&r._r.push(t),l=i,r.selector=a,r.isReverted=!1,t};return r.last=i,t===j?i(r):t?r[t]=i:i},e.ignore=function(t){var e=l;l=null,t(this),l=e},e.getTweens=function(){var e=[];return this.data.forEach((function(n){return n instanceof t?e.push.apply(e,n.getTweens()):n instanceof Ze&&!(n.parent&&"nested"===n.parent.data)&&e.push(n)})),e},e.clear=function(){this._r.length=this.data.length=0},e.kill=function(t,e){var n=this;if(t){var r=this.getTweens();this.data.forEach((function(t){"isFlip"===t.data&&(t.revert(),t.getChildren(!0,!0,!1).forEach((function(t){return r.splice(r.indexOf(t),1)})))})),r.map((function(t){return{g:t.globalTime(0),t:t}})).sort((function(t,e){return e.g-t.g||-1/0})).forEach((function(e){return e.t.revert(t)})),this.data.forEach((function(e){return!(e instanceof Ze)&&e.revert&&e.revert(t)})),this._r.forEach((function(e){return e(t,n)})),this.isReverted=!0}else this.data.forEach((function(t){return t.kill&&t.kill()}));if(this.clear(),e)for(var i=mn.length;i--;)mn[i].id===this.id&&mn.splice(i,1)},e.revert=function(t){this.kill(t||{})},t}(),bn=function(){function t(t){this.contexts=[],this.scope=t}var e=t.prototype;return e.add=function(t,e,n){R(t)||(t={matches:t});var r,i,a,s=new $n(0,n||this.scope),o=s.conditions={};for(i in l&&!s.selector&&(s.selector=l.selector),this.contexts.push(s),e=s.add("onMatch",e),s.queries=t,t)"all"===i?a=1:(r=u.matchMedia(t[i]))&&(mn.indexOf(s)<0&&mn.push(s),(o[i]=r.matches)&&(a=1),r.addListener?r.addListener(Cn):r.addEventListener("change",Cn));return a&&e(s),this},e.revert=function(t){this.kill(t||{})},e.kill=function(t){this.contexts.forEach((function(e){return e.kill(t,!0)}))},t}(),Tn={registerPlugin:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];e.forEach((function(t){return ge(t)}))},timeline:function(t){return new Fe(t)},getTweensOf:function(t,e){return h.getTweensOf(t,e)},getProperty:function(t,e,n,r){B(t)&&(t=re(t)[0]);var i=dt(t||{}).get,a=n?bt:$t;return"native"===n&&(n=""),t?e?a((ot[e]&&ot[e].get||i)(t,e,n,r)):function(e,n,r){return a((ot[e]&&ot[e].get||i)(t,e,n,r))}:t},quickSetter:function(t,e,n){if((t=re(t)).length>1){var r=t.map((function(t){return kn.quickSetter(t,e,n)})),i=r.length;return function(t){for(var e=i;e--;)r[e](t)}}t=t[0]||{};var a=ot[e],s=dt(t),o=s.harness&&(s.harness.aliases||{})[e]||e,c=a?function(e){var r=new a;_._pt=0,r.init(t,n?e+n:e,_,0,[t]),r.render(1,r),_._pt&&ln(1,_)}:s.set(t,o);return a?c:function(e){return c(t,o,n?e+n:e,s,1)}},quickTo:function(t,e,n){var r,i=kn.to(t,wt(((r={})[e]="+=0.1",r.paused=!0,r),n||{})),a=function(t,n,r){return i.resetTo(e,t,n,r)};return a.tween=i,a},isTweening:function(t){return h.getTweensOf(t,!0).length>0},defaults:function(t){return t&&t.ease&&(t.ease=Oe(t.ease,b.ease)),At(b,t||{})},config:function(t){return At($,t||{})},registerEffect:function(t){var e=t.name,n=t.effect,r=t.plugins,i=t.defaults,a=t.extendTimeline;(r||"").split(",").forEach((function(t){return t&&!ot[t]&&!G[t]&&J()})),ct[e]=function(t,e,r){return n(re(t),Tt(e||{},i),r)},a&&(Fe.prototype[e]=function(t,n,r){return this.add(ct[e](t,R(n)?n:(r=n)&&{},this),r)})},registerEase:function(t,e){Pe[t]=Oe(e)},parseEase:function(t,e){return arguments.length?Oe(t,e):Pe},getById:function(t){return h.getById(t)},exportRoot:function(t,e){void 0===t&&(t={});var n,r,i=new Fe(t);for(i.smoothChildTiming=U(t.smoothChildTiming),h.remove(i),i._dp=0,i._time=i._tTime=h._time,n=h._first;n;)r=n._next,!e&&!n._dur&&n instanceof Ze&&n.vars.onComplete===n._targets[0]||qt(i,n,n._start-n._delay),n=r;return qt(h,i,0),i},context:function(t,e){return t?new $n(t,e):l},matchMedia:function(t){return new bn(t)},matchMediaRefresh:function(){return mn.forEach((function(t){var e,n,r=t.conditions;for(n in r)r[n]&&(r[n]=!1,e=1);e&&t.revert()}))||Cn()},addEventListener:function(t,e){var n=_n[t]||(_n[t]=[]);~n.indexOf(e)||n.push(e)},removeEventListener:function(t,e){var n=_n[t],r=n&&n.indexOf(e);r>=0&&n.splice(r,1)},utils:{wrap:function t(e,n,r){var i=n-e;return q(e)?he(e,t(0,e.length),n):Qt(r,(function(t){return(i+(t-e)%i)%i+e}))},wrapYoyo:function t(e,n,r){var i=n-e,a=2*i;return q(e)?he(e,t(0,e.length-1),n):Qt(r,(function(t){return e+((t=(a+(t-e)%a)%a||0)>i?a-t:t)}))},distribute:se,random:le,snap:ce,normalize:function(t,e,n){return pe(t,e,0,1,n)},getUnit:Zt,clamp:function(t,e,n){return Qt(n,(function(n){return Jt(t,e,n)}))},splitColor:Ce,toArray:re,selector:ie,mapRange:pe,pipe:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return function(t){return e.reduce((function(t,e){return e(t)}),t)}},unitize:function(t,e){return function(n){return t(parseFloat(n))+(e||Zt(n))}},interpolate:function t(e,n,r,i){var a=isNaN(e+n)?0:function(t){return(1-t)*e+t*n};if(!a){var s,o,c,l,h,u=B(e),p={};if(!0===r&&(i=1)&&(r=null),u)e={p:e},n={p:n};else if(q(e)&&!q(n)){for(c=[],l=e.length,h=l-2,o=1;o<l;o++)c.push(t(e[o-1],e[o]));l--,a=function(t){t*=l;var e=Math.min(h,~~t);return c[e](t-e)},r=n}else i||(e=wt(q(e)?[]:{},e));if(!c){for(s in n)Ke.call(p,e,s,"get",n[s]);a=function(t){return ln(t,p)||(u?e.p:e)}}}return Qt(r,a)},shuffle:ae},install:Q,effects:ct,ticker:ke,updateRoot:Fe.updateRoot,plugins:ot,globalTimeline:h,core:{PropTween:fn,globals:Z,Tween:Ze,Timeline:Fe,Animation:qe,getCache:dt,_removeLinkedListItem:Nt,reverting:function(){return c},context:function(t){return t&&l&&(l.data.push(t),t._ctx=l),l},suppressOverwrites:function(t){return o=t}}};mt("to,from,fromTo,delayedCall,set,killTweensOf",(function(t){return Tn[t]=Ze[t]})),ke.add(Fe.updateRoot),_=Tn.to({},{duration:0});var wn=function(t,e){for(var n=t._pt;n&&n.p!==e&&n.op!==e&&n.fp!==e;)n=n._next;return n},An=function(t,e){return{name:t,rawVars:1,init:function(t,n,r){r._onInit=function(t){var r,i;if(B(n)&&(r={},mt(n,(function(t){return r[t]=1})),n=r),e){for(i in r={},n)r[i]=e(n[i]);n=r}!function(t,e){var n,r,i,a=t._targets;for(n in e)for(r=a.length;r--;)(i=t._ptLookup[r][n])&&(i=i.d)&&(i._pt&&(i=wn(i,n)),i&&i.modifier&&i.modifier(e[n],t,a[r],n))}(t,n)}}}},kn=Tn.registerPlugin({name:"attr",init:function(t,e,n,r,i){var a,s,o;for(a in this.tween=n,e)o=t.getAttribute(a)||"",(s=this.add(t,"setAttribute",(o||0)+"",e[a],r,i,0,0,a)).op=a,s.b=o,this._props.push(a)},render:function(t,e){for(var n=e._pt;n;)c?n.set(n.t,n.p,n.b,n):n.r(t,n.d),n=n._next}},{name:"endArray",init:function(t,e){for(var n=e.length;n--;)this.add(t,n,t[n]||0,e[n],0,0,0,0,0,1)}},An("roundProps",oe),An("modifiers"),An("snap",ce))||Tn;Ze.version=Fe.version=kn.version="3.12.2",f=1,D()&&Se();Pe.Power0,Pe.Power1,Pe.Power2,Pe.Power3,Pe.Power4,Pe.Linear,Pe.Quad,Pe.Cubic,Pe.Quart,Pe.Quint,Pe.Strong,Pe.Elastic,Pe.Back,Pe.SteppedEase,Pe.Bounce,Pe.Sine,Pe.Expo,Pe.Circ;var Sn,Pn,Nn,Mn,Bn,jn,Ln,On,Rn={},Un=180/Math.PI,Dn=Math.PI/180,In=Math.atan2,En=/([A-Z])/g,qn=/(left|right|width|margin|padding|x)/i,Fn=/[\s,\(]\S/,zn={autoAlpha:"opacity,visibility",scale:"scaleX,scaleY",alpha:"opacity"},Wn=function(t,e){return e.set(e.t,e.p,Math.round(1e4*(e.s+e.c*t))/1e4+e.u,e)},Vn=function(t,e){return e.set(e.t,e.p,1===t?e.e:Math.round(1e4*(e.s+e.c*t))/1e4+e.u,e)},Kn=function(t,e){return e.set(e.t,e.p,t?Math.round(1e4*(e.s+e.c*t))/1e4+e.u:e.b,e)},Hn=function(t,e){var n=e.s+e.c*t;e.set(e.t,e.p,~~(n+(n<0?-.5:.5))+e.u,e)},Xn=function(t,e){return e.set(e.t,e.p,t?e.e:e.b,e)},Gn=function(t,e){return e.set(e.t,e.p,1!==t?e.b:e.e,e)},Yn=function(t,e,n){return t.style[e]=n},Qn=function(t,e,n){return t.style.setProperty(e,n)},Jn=function(t,e,n){return t._gsap[e]=n},Zn=function(t,e,n){return t._gsap.scaleX=t._gsap.scaleY=n},tr=function(t,e,n,r,i){var a=t._gsap;a.scaleX=a.scaleY=n,a.renderTransform(i,a)},er=function(t,e,n,r,i){var a=t._gsap;a[e]=n,a.renderTransform(i,a)},nr="transform",rr=nr+"Origin",ir=function t(e,n){var r=this,i=this.target,a=i.style;if(e in Rn&&a){if(this.tfm=this.tfm||{},"transform"===e)return zn.transform.split(",").forEach((function(e){return t.call(r,e,n)}));if(~(e=zn[e]||e).indexOf(",")?e.split(",").forEach((function(t){return r.tfm[t]=$r(i,t)})):this.tfm[e]=i._gsap.x?i._gsap[e]:$r(i,e),this.props.indexOf(nr)>=0)return;i._gsap.svg&&(this.svgo=i.getAttribute("data-svg-origin"),this.props.push(rr,n,"")),e=nr}(a||n)&&this.props.push(e,n,a[e])},ar=function(t){t.translate&&(t.removeProperty("translate"),t.removeProperty("scale"),t.removeProperty("rotate"))},sr=function(){var t,e,n=this.props,r=this.target,i=r.style,a=r._gsap;for(t=0;t<n.length;t+=3)n[t+1]?r[n[t]]=n[t+2]:n[t+2]?i[n[t]]=n[t+2]:i.removeProperty("--"===n[t].substr(0,2)?n[t]:n[t].replace(En,"-$1").toLowerCase());if(this.tfm){for(e in this.tfm)a[e]=this.tfm[e];a.svg&&(a.renderTransform(),r.setAttribute("data-svg-origin",this.svgo||"")),(t=Ln())&&t.isStart||i[nr]||(ar(i),a.uncache=1)}},or=function(t,e){var n={target:t,props:[],revert:sr,save:ir};return t._gsap||kn.core.getCache(t),e&&e.split(",").forEach((function(t){return n.save(t)})),n},cr=function(t,e){var n=Pn.createElementNS?Pn.createElementNS((e||"http://www.w3.org/1999/xhtml").replace(/^https/,"http"),t):Pn.createElement(t);return n.style?n:Pn.createElement(t)},lr=function t(e,n,r){var i=getComputedStyle(e);return i[n]||i.getPropertyValue(n.replace(En,"-$1").toLowerCase())||i.getPropertyValue(n)||!r&&t(e,ur(n)||n,1)||""},hr="O,Moz,ms,Ms,Webkit".split(","),ur=function(t,e,n){var r=(e||Bn).style,i=5;if(t in r&&!n)return t;for(t=t.charAt(0).toUpperCase()+t.substr(1);i--&&!(hr[i]+t in r););return i<0?null:(3===i?"ms":i>=0?hr[i]:"")+t},pr=function(){"undefined"!=typeof window&&window.document&&(Sn=window,Pn=Sn.document,Nn=Pn.documentElement,Bn=cr("div")||{style:{}},cr("div"),nr=ur(nr),rr=nr+"Origin",Bn.style.cssText="border-width:0;line-height:0;position:absolute;padding:0",On=!!ur("perspective"),Ln=kn.core.reverting,Mn=1)},dr=function t(e){var n,r=cr("svg",this.ownerSVGElement&&this.ownerSVGElement.getAttribute("xmlns")||"http://www.w3.org/2000/svg"),i=this.parentNode,a=this.nextSibling,s=this.style.cssText;if(Nn.appendChild(r),r.appendChild(this),this.style.display="block",e)try{n=this.getBBox(),this._gsapBBox=this.getBBox,this.getBBox=t}catch(t){}else this._gsapBBox&&(n=this._gsapBBox());return i&&(a?i.insertBefore(this,a):i.appendChild(this)),Nn.removeChild(r),this.style.cssText=s,n},fr=function(t,e){for(var n=e.length;n--;)if(t.hasAttribute(e[n]))return t.getAttribute(e[n])},mr=function(t){var e;try{e=t.getBBox()}catch(n){e=dr.call(t,!0)}return e&&(e.width||e.height)||t.getBBox===dr||(e=dr.call(t,!0)),!e||e.width||e.x||e.y?e:{x:+fr(t,["x","cx","x1"])||0,y:+fr(t,["y","cy","y1"])||0,width:0,height:0}},_r=function(t){return!(!t.getCTM||t.parentNode&&!t.ownerSVGElement||!mr(t))},gr=function(t,e){if(e){var n=t.style;e in Rn&&e!==rr&&(e=nr),n.removeProperty?("ms"!==e.substr(0,2)&&"webkit"!==e.substr(0,6)||(e="-"+e),n.removeProperty(e.replace(En,"-$1").toLowerCase())):n.removeAttribute(e)}},vr=function(t,e,n,r,i,a){var s=new fn(t._pt,e,n,0,1,a?Gn:Xn);return t._pt=s,s.b=r,s.e=i,t._props.push(n),s},yr={deg:1,rad:1,turn:1},xr={grid:1,flex:1},Cr=function t(e,n,r,i){var a,s,o,c,l=parseFloat(r)||0,h=(r+"").trim().substr((l+"").length)||"px",u=Bn.style,p=qn.test(n),d="svg"===e.tagName.toLowerCase(),f=(d?"client":"offset")+(p?"Width":"Height"),m=100,_="px"===i,g="%"===i;return i===h||!l||yr[i]||yr[h]?l:("px"!==h&&!_&&(l=t(e,n,r,"px")),c=e.getCTM&&_r(e),!g&&"%"!==h||!Rn[n]&&!~n.indexOf("adius")?(u[p?"width":"height"]=m+(_?h:i),s=~n.indexOf("adius")||"em"===i&&e.appendChild&&!d?e:e.parentNode,c&&(s=(e.ownerSVGElement||{}).parentNode),s&&s!==Pn&&s.appendChild||(s=Pn.body),(o=s._gsap)&&g&&o.width&&p&&o.time===ke.time&&!o.uncache?_t(l/o.width*m):((g||"%"===h)&&!xr[lr(s,"display")]&&(u.position=lr(e,"position")),s===e&&(u.position="static"),s.appendChild(Bn),a=Bn[f],s.removeChild(Bn),u.position="absolute",p&&g&&((o=dt(s)).time=ke.time,o.width=s[f]),_t(_?a*l/m:a&&l?m/a*l:0))):(a=c?e.getBBox()[p?"width":"height"]:e[f],_t(g?l/a*m:l/100*a)))},$r=function(t,e,n,r){var i;return Mn||pr(),e in zn&&"transform"!==e&&~(e=zn[e]).indexOf(",")&&(e=e.split(",")[0]),Rn[e]&&"transform"!==e?(i=jr(t,r),i="transformOrigin"!==e?i[e]:i.svg?i.origin:Lr(lr(t,rr))+" "+i.zOrigin+"px"):(!(i=t.style[e])||"auto"===i||r||~(i+"").indexOf("calc("))&&(i=Ar[e]&&Ar[e](t,e,n)||lr(t,e)||ft(t,e)||("opacity"===e?1:0)),n&&!~(i+"").trim().indexOf(" ")?Cr(t,e,i,n)+n:i},br=function(t,e,n,r){if(!n||"none"===n){var i=ur(e,t,1),a=i&&lr(t,i,1);a&&a!==n?(e=i,n=a):"borderColor"===e&&(n=lr(t,"borderTopColor"))}var s,o,c,l,h,u,p,d,f,m,_,g=new fn(this._pt,t.style,e,0,1,cn),v=0,y=0;if(g.b=n,g.e=r,n+="","auto"===(r+="")&&(t.style[e]=r,r=lr(t,e)||r,t.style[e]=n),Ae(s=[n,r]),r=s[1],c=(n=s[0]).match(W)||[],(r.match(W)||[]).length){for(;o=W.exec(r);)p=o[0],f=r.substring(v,o.index),h?h=(h+1)%5:"rgba("!==f.substr(-5)&&"hsla("!==f.substr(-5)||(h=1),p!==(u=c[y++]||"")&&(l=parseFloat(u)||0,_=u.substr((l+"").length),"="===p.charAt(1)&&(p=vt(l,p)+_),d=parseFloat(p),m=p.substr((d+"").length),v=W.lastIndex-m.length,m||(m=m||$.units[e]||_,v===r.length&&(r+=m,g.e+=m)),_!==m&&(l=Cr(t,e,u,m)||0),g._pt={_next:g._pt,p:f||1===y?f:",",s:l,c:d-l,m:h&&h<4||"zIndex"===e?Math.round:0});g.c=v<r.length?r.substring(v,r.length):""}else g.r="display"===e&&"none"===r?Gn:Xn;return K.test(r)&&(g.e=0),this._pt=g,g},Tr={top:"0%",bottom:"100%",left:"0%",right:"100%",center:"50%"},wr=function(t,e){if(e.tween&&e.tween._time===e.tween._dur){var n,r,i,a=e.t,s=a.style,o=e.u,c=a._gsap;if("all"===o||!0===o)s.cssText="",r=1;else for(i=(o=o.split(",")).length;--i>-1;)n=o[i],Rn[n]&&(r=1,n="transformOrigin"===n?rr:nr),gr(a,n);r&&(gr(a,nr),c&&(c.svg&&a.removeAttribute("transform"),jr(a,1),c.uncache=1,ar(s)))}},Ar={clearProps:function(t,e,n,r,i){if("isFromStart"!==i.data){var a=t._pt=new fn(t._pt,e,n,0,0,wr);return a.u=r,a.pr=-10,a.tween=i,t._props.push(n),1}}},kr=[1,0,0,1,0,0],Sr={},Pr=function(t){return"matrix(1, 0, 0, 1, 0, 0)"===t||"none"===t||!t},Nr=function(t){var e=lr(t,nr);return Pr(e)?kr:e.substr(7).match(z).map(_t)},Mr=function(t,e){var n,r,i,a,s=t._gsap||dt(t),o=t.style,c=Nr(t);return s.svg&&t.getAttribute("transform")?"1,0,0,1,0,0"===(c=[(i=t.transform.baseVal.consolidate().matrix).a,i.b,i.c,i.d,i.e,i.f]).join(",")?kr:c:(c!==kr||t.offsetParent||t===Nn||s.svg||(i=o.display,o.display="block",(n=t.parentNode)&&t.offsetParent||(a=1,r=t.nextElementSibling,Nn.appendChild(t)),c=Nr(t),i?o.display=i:gr(t,"display"),a&&(r?n.insertBefore(t,r):n?n.appendChild(t):Nn.removeChild(t))),e&&c.length>6?[c[0],c[1],c[4],c[5],c[12],c[13]]:c)},Br=function(t,e,n,r,i,a){var s,o,c,l=t._gsap,h=i||Mr(t,!0),u=l.xOrigin||0,p=l.yOrigin||0,d=l.xOffset||0,f=l.yOffset||0,m=h[0],_=h[1],g=h[2],v=h[3],y=h[4],x=h[5],C=e.split(" "),$=parseFloat(C[0])||0,b=parseFloat(C[1])||0;n?h!==kr&&(o=m*v-_*g)&&(c=$*(-_/o)+b*(m/o)-(m*x-_*y)/o,$=$*(v/o)+b*(-g/o)+(g*x-v*y)/o,b=c):($=(s=mr(t)).x+(~C[0].indexOf("%")?$/100*s.width:$),b=s.y+(~(C[1]||C[0]).indexOf("%")?b/100*s.height:b)),r||!1!==r&&l.smooth?(y=$-u,x=b-p,l.xOffset=d+(y*m+x*g)-y,l.yOffset=f+(y*_+x*v)-x):l.xOffset=l.yOffset=0,l.xOrigin=$,l.yOrigin=b,l.smooth=!!r,l.origin=e,l.originIsAbsolute=!!n,t.style[rr]="0px 0px",a&&(vr(a,l,"xOrigin",u,$),vr(a,l,"yOrigin",p,b),vr(a,l,"xOffset",d,l.xOffset),vr(a,l,"yOffset",f,l.yOffset)),t.setAttribute("data-svg-origin",$+" "+b)},jr=function(t,e){var n=t._gsap||new Ee(t);if("x"in n&&!e&&!n.uncache)return n;var r,i,a,s,o,c,l,h,u,p,d,f,m,_,g,v,y,x,C,b,T,w,A,k,S,P,N,M,B,j,L,O,R=t.style,U=n.scaleX<0,D="px",I="deg",E=getComputedStyle(t),q=lr(t,rr)||"0";return r=i=a=c=l=h=u=p=d=0,s=o=1,n.svg=!(!t.getCTM||!_r(t)),E.translate&&("none"===E.translate&&"none"===E.scale&&"none"===E.rotate||(R[nr]=("none"!==E.translate?"translate3d("+(E.translate+" 0 0").split(" ").slice(0,3).join(", ")+") ":"")+("none"!==E.rotate?"rotate("+E.rotate+") ":"")+("none"!==E.scale?"scale("+E.scale.split(" ").join(",")+") ":"")+("none"!==E[nr]?E[nr]:"")),R.scale=R.rotate=R.translate="none"),_=Mr(t,n.svg),n.svg&&(n.uncache?(S=t.getBBox(),q=n.xOrigin-S.x+"px "+(n.yOrigin-S.y)+"px",k=""):k=!e&&t.getAttribute("data-svg-origin"),Br(t,k||q,!!k||n.originIsAbsolute,!1!==n.smooth,_)),f=n.xOrigin||0,m=n.yOrigin||0,_!==kr&&(x=_[0],C=_[1],b=_[2],T=_[3],r=w=_[4],i=A=_[5],6===_.length?(s=Math.sqrt(x*x+C*C),o=Math.sqrt(T*T+b*b),c=x||C?In(C,x)*Un:0,(u=b||T?In(b,T)*Un+c:0)&&(o*=Math.abs(Math.cos(u*Dn))),n.svg&&(r-=f-(f*x+m*b),i-=m-(f*C+m*T))):(O=_[6],j=_[7],N=_[8],M=_[9],B=_[10],L=_[11],r=_[12],i=_[13],a=_[14],l=(g=In(O,B))*Un,g&&(k=w*(v=Math.cos(-g))+N*(y=Math.sin(-g)),S=A*v+M*y,P=O*v+B*y,N=w*-y+N*v,M=A*-y+M*v,B=O*-y+B*v,L=j*-y+L*v,w=k,A=S,O=P),h=(g=In(-b,B))*Un,g&&(v=Math.cos(-g),L=T*(y=Math.sin(-g))+L*v,x=k=x*v-N*y,C=S=C*v-M*y,b=P=b*v-B*y),c=(g=In(C,x))*Un,g&&(k=x*(v=Math.cos(g))+C*(y=Math.sin(g)),S=w*v+A*y,C=C*v-x*y,A=A*v-w*y,x=k,w=S),l&&Math.abs(l)+Math.abs(c)>359.9&&(l=c=0,h=180-h),s=_t(Math.sqrt(x*x+C*C+b*b)),o=_t(Math.sqrt(A*A+O*O)),g=In(w,A),u=Math.abs(g)>2e-4?g*Un:0,d=L?1/(L<0?-L:L):0),n.svg&&(k=t.getAttribute("transform"),n.forceCSS=t.setAttribute("transform","")||!Pr(lr(t,nr)),k&&t.setAttribute("transform",k))),Math.abs(u)>90&&Math.abs(u)<270&&(U?(s*=-1,u+=c<=0?180:-180,c+=c<=0?180:-180):(o*=-1,u+=u<=0?180:-180)),e=e||n.uncache,n.x=r-((n.xPercent=r&&(!e&&n.xPercent||(Math.round(t.offsetWidth/2)===Math.round(-r)?-50:0)))?t.offsetWidth*n.xPercent/100:0)+D,n.y=i-((n.yPercent=i&&(!e&&n.yPercent||(Math.round(t.offsetHeight/2)===Math.round(-i)?-50:0)))?t.offsetHeight*n.yPercent/100:0)+D,n.z=a+D,n.scaleX=_t(s),n.scaleY=_t(o),n.rotation=_t(c)+I,n.rotationX=_t(l)+I,n.rotationY=_t(h)+I,n.skewX=u+I,n.skewY=p+I,n.transformPerspective=d+D,(n.zOrigin=parseFloat(q.split(" ")[2])||0)&&(R[rr]=Lr(q)),n.xOffset=n.yOffset=0,n.force3D=$.force3D,n.renderTransform=n.svg?qr:On?Er:Rr,n.uncache=0,n},Lr=function(t){return(t=t.split(" "))[0]+" "+t[1]},Or=function(t,e,n){var r=Zt(e);return _t(parseFloat(e)+parseFloat(Cr(t,"x",n+"px",r)))+r},Rr=function(t,e){e.z="0px",e.rotationY=e.rotationX="0deg",e.force3D=0,Er(t,e)},Ur="0deg",Dr="0px",Ir=") ",Er=function(t,e){var n=e||this,r=n.xPercent,i=n.yPercent,a=n.x,s=n.y,o=n.z,c=n.rotation,l=n.rotationY,h=n.rotationX,u=n.skewX,p=n.skewY,d=n.scaleX,f=n.scaleY,m=n.transformPerspective,_=n.force3D,g=n.target,v=n.zOrigin,y="",x="auto"===_&&t&&1!==t||!0===_;if(v&&(h!==Ur||l!==Ur)){var C,$=parseFloat(l)*Dn,b=Math.sin($),T=Math.cos($);$=parseFloat(h)*Dn,C=Math.cos($),a=Or(g,a,b*C*-v),s=Or(g,s,-Math.sin($)*-v),o=Or(g,o,T*C*-v+v)}m!==Dr&&(y+="perspective("+m+Ir),(r||i)&&(y+="translate("+r+"%, "+i+"%) "),(x||a!==Dr||s!==Dr||o!==Dr)&&(y+=o!==Dr||x?"translate3d("+a+", "+s+", "+o+") ":"translate("+a+", "+s+Ir),c!==Ur&&(y+="rotate("+c+Ir),l!==Ur&&(y+="rotateY("+l+Ir),h!==Ur&&(y+="rotateX("+h+Ir),u===Ur&&p===Ur||(y+="skew("+u+", "+p+Ir),1===d&&1===f||(y+="scale("+d+", "+f+Ir),g.style[nr]=y||"translate(0, 0)"},qr=function(t,e){var n,r,i,a,s,o=e||this,c=o.xPercent,l=o.yPercent,h=o.x,u=o.y,p=o.rotation,d=o.skewX,f=o.skewY,m=o.scaleX,_=o.scaleY,g=o.target,v=o.xOrigin,y=o.yOrigin,x=o.xOffset,C=o.yOffset,$=o.forceCSS,b=parseFloat(h),T=parseFloat(u);p=parseFloat(p),d=parseFloat(d),(f=parseFloat(f))&&(d+=f=parseFloat(f),p+=f),p||d?(p*=Dn,d*=Dn,n=Math.cos(p)*m,r=Math.sin(p)*m,i=Math.sin(p-d)*-_,a=Math.cos(p-d)*_,d&&(f*=Dn,s=Math.tan(d-f),i*=s=Math.sqrt(1+s*s),a*=s,f&&(s=Math.tan(f),n*=s=Math.sqrt(1+s*s),r*=s)),n=_t(n),r=_t(r),i=_t(i),a=_t(a)):(n=m,a=_,r=i=0),(b&&!~(h+"").indexOf("px")||T&&!~(u+"").indexOf("px"))&&(b=Cr(g,"x",h,"px"),T=Cr(g,"y",u,"px")),(v||y||x||C)&&(b=_t(b+v-(v*n+y*i)+x),T=_t(T+y-(v*r+y*a)+C)),(c||l)&&(s=g.getBBox(),b=_t(b+c/100*s.width),T=_t(T+l/100*s.height)),s="matrix("+n+","+r+","+i+","+a+","+b+","+T+")",g.setAttribute("transform",s),$&&(g.style[nr]=s)},Fr=function(t,e,n,r,i){var a,s,o=360,c=B(i),l=parseFloat(i)*(c&&~i.indexOf("rad")?Un:1)-r,h=r+l+"deg";return c&&("short"===(a=i.split("_")[1])&&(l%=o)!==l%180&&(l+=l<0?o:-360),"cw"===a&&l<0?l=(l+36e9)%o-~~(l/o)*o:"ccw"===a&&l>0&&(l=(l-36e9)%o-~~(l/o)*o)),t._pt=s=new fn(t._pt,e,n,r,l,Vn),s.e=h,s.u="deg",t._props.push(n),s},zr=function(t,e){for(var n in e)t[n]=e[n];return t},Wr=function(t,e,n){var r,i,a,s,o,c,l,h=zr({},n._gsap),u=n.style;for(i in h.svg?(a=n.getAttribute("transform"),n.setAttribute("transform",""),u[nr]=e,r=jr(n,1),gr(n,nr),n.setAttribute("transform",a)):(a=getComputedStyle(n)[nr],u[nr]=e,r=jr(n,1),u[nr]=a),Rn)(a=h[i])!==(s=r[i])&&"perspective,force3D,transformOrigin,svgOrigin".indexOf(i)<0&&(o=Zt(a)!==(l=Zt(s))?Cr(n,i,a,l):parseFloat(a),c=parseFloat(s),t._pt=new fn(t._pt,r,i,o,c-o,Wn),t._pt.u=l||0,t._props.push(i));zr(r,h)};mt("padding,margin,Width,Radius",(function(t,e){var n="Top",r="Right",i="Bottom",a="Left",s=(e<3?[n,r,i,a]:[n+a,n+r,i+r,i+a]).map((function(n){return e<2?t+n:"border"+n+t}));Ar[e>1?"border"+t:t]=function(t,e,n,r,i){var a,o;if(arguments.length<4)return a=s.map((function(e){return $r(t,e,n)})),5===(o=a.join(" ")).split(a[0]).length?a[0]:o;a=(r+"").split(" "),o={},s.forEach((function(t,e){return o[t]=a[e]=a[e]||a[(e-1)/2|0]})),t.init(e,o,i)}}));var Vr,Kr,Hr,Xr={name:"css",register:pr,targetTest:function(t){return t.style&&t.nodeType},init:function(t,e,n,r,i){var a,s,o,c,l,h,u,p,d,f,m,_,g,v,y,x,C,b,T,w,A=this._props,k=t.style,S=n.vars.startAt;for(u in Mn||pr(),this.styles=this.styles||or(t),x=this.styles.props,this.tween=n,e)if("autoRound"!==u&&(s=e[u],!ot[u]||!He(u,e,n,r,t,i)))if(l=typeof s,h=Ar[u],"function"===l&&(l=typeof(s=s.call(n,r,t,i))),"string"===l&&~s.indexOf("random(")&&(s=ue(s)),h)h(this,t,u,s,n)&&(y=1);else if("--"===u.substr(0,2))a=(getComputedStyle(t).getPropertyValue(u)+"").trim(),s+="",Te.lastIndex=0,Te.test(a)||(p=Zt(a),d=Zt(s)),d?p!==d&&(a=Cr(t,u,a,d)+d):p&&(s+=p),this.add(k,"setProperty",a,s,r,i,0,0,u),A.push(u),x.push(u,0,k[u]);else if("undefined"!==l){if(S&&u in S?(a="function"==typeof S[u]?S[u].call(n,r,t,i):S[u],B(a)&&~a.indexOf("random(")&&(a=ue(a)),Zt(a+"")||(a+=$.units[u]||Zt($r(t,u))||""),"="===(a+"").charAt(1)&&(a=$r(t,u))):a=$r(t,u),c=parseFloat(a),(f="string"===l&&"="===s.charAt(1)&&s.substr(0,2))&&(s=s.substr(2)),o=parseFloat(s),u in zn&&("autoAlpha"===u&&(1===c&&"hidden"===$r(t,"visibility")&&o&&(c=0),x.push("visibility",0,k.visibility),vr(this,k,"visibility",c?"inherit":"hidden",o?"inherit":"hidden",!o)),"scale"!==u&&"transform"!==u&&~(u=zn[u]).indexOf(",")&&(u=u.split(",")[0])),m=u in Rn)if(this.styles.save(u),_||((g=t._gsap).renderTransform&&!e.parseTransform||jr(t,e.parseTransform),v=!1!==e.smoothOrigin&&g.smooth,(_=this._pt=new fn(this._pt,k,nr,0,1,g.renderTransform,g,0,-1)).dep=1),"scale"===u)this._pt=new fn(this._pt,g,"scaleY",g.scaleY,(f?vt(g.scaleY,f+o):o)-g.scaleY||0,Wn),this._pt.u=0,A.push("scaleY",u),u+="X";else{if("transformOrigin"===u){x.push(rr,0,k[rr]),b=void 0,T=void 0,w=void 0,b=(C=s).split(" "),T=b[0],w=b[1]||"50%","top"!==T&&"bottom"!==T&&"left"!==w&&"right"!==w||(C=T,T=w,w=C),b[0]=Tr[T]||T,b[1]=Tr[w]||w,s=b.join(" "),g.svg?Br(t,s,0,v,0,this):((d=parseFloat(s.split(" ")[2])||0)!==g.zOrigin&&vr(this,g,"zOrigin",g.zOrigin,d),vr(this,k,u,Lr(a),Lr(s)));continue}if("svgOrigin"===u){Br(t,s,1,v,0,this);continue}if(u in Sr){Fr(this,g,u,c,f?vt(c,f+s):s);continue}if("smoothOrigin"===u){vr(this,g,"smooth",g.smooth,s);continue}if("force3D"===u){g[u]=s;continue}if("transform"===u){Wr(this,s,t);continue}}else u in k||(u=ur(u)||u);if(m||(o||0===o)&&(c||0===c)&&!Fn.test(s)&&u in k)o||(o=0),(p=(a+"").substr((c+"").length))!==(d=Zt(s)||(u in $.units?$.units[u]:p))&&(c=Cr(t,u,a,d)),this._pt=new fn(this._pt,m?g:k,u,c,(f?vt(c,f+o):o)-c,m||"px"!==d&&"zIndex"!==u||!1===e.autoRound?Wn:Hn),this._pt.u=d||0,p!==d&&"%"!==d&&(this._pt.b=a,this._pt.r=Kn);else if(u in k)br.call(this,t,u,a,f?f+s:s);else if(u in t)this.add(t,u,a||t[u],f?f+s:s,r,i);else if("parseTransform"!==u)continue;m||(u in k?x.push(u,0,k[u]):x.push(u,1,a||t[u])),A.push(u)}y&&dn(this)},render:function(t,e){if(e.tween._time||!Ln())for(var n=e._pt;n;)n.r(t,n.d),n=n._next;else e.styles.revert()},get:$r,aliases:zn,getSetter:function(t,e,n){var r=zn[e];return r&&r.indexOf(",")<0&&(e=r),e in Rn&&e!==rr&&(t._gsap.x||$r(t,"x"))?n&&jn===n?"scale"===e?Zn:Jn:(jn=n||{})&&("scale"===e?tr:er):t.style&&!O(t.style[e])?Yn:~e.indexOf("-")?Qn:an(t,e)},core:{_removeProperty:gr,_getMatrix:Mr}};kn.utils.checkPrefix=ur,kn.core.getStyleSaver=or,Hr=mt((Vr="x,y,z,scale,scaleX,scaleY,xPercent,yPercent")+","+(Kr="rotation,rotationX,rotationY,skewX,skewY")+",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",(function(t){Rn[t]=1})),mt(Kr,(function(t){$.units[t]="deg",Sr[t]=1})),zn[Hr[13]]=Vr+","+Kr,mt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",(function(t){var e=t.split(":");zn[e[1]]=Hr[e[0]]})),mt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",(function(t){$.units[t]="px"})),kn.registerPlugin(Xr);var Gr=kn.registerPlugin(Xr)||kn,Yr=(Gr.core.Tween,n("./node_modules/react/index.js")),Qr=n("./node_modules/react-router-dom/dist/index.js");const Jr=[{name:"笔记",url:"notes",children:[{name:"考试",url:"exame"},{name:"世界开发语言示例",url:"language"}]},{name:"C/C++",url:"cpp",children:[{name:"项目基础",url:"basic"},{name:"数据类型",url:"dataType"},{name:"高阶编程",url:"advance"}]},{name:"前端",url:"js",children:[{name:"Js",url:"basic"},{name:"TypeScript",url:"ts"},{name:"NodeJs",url:"node"},{name:"Svg",url:"svg"},{name:"Vim",url:"vim"},{name:"css",url:"css"},{name:"正则",url:"reg"},{name:"各种工具",url:"utilPack"}]},{name:"数据结构",url:"structure",children:[{name:"基础",url:"basic"},{name:"复杂类型",url:"complex"},{name:"树与二叉树",url:"treeBinary"},{name:"图及其算法",url:"graph"},{name:"查找和排序",url:"searchSort"}]},{name:"计算机组成原理",url:"consist",children:[{name:"概论",url:"basic"},{name:"数据的表示和运算",url:"num"},{name:"存储器层次结构",url:"memorizer"},{name:"软件系统",url:"software"},{name:"硬件系统",url:"hardware"}]},{name:"操作系统",url:"system",children:[{name:"概念",url:"basic"},{name:"进程管理",url:"process"},{name:"内存管理",url:"memory"},{name:"文件管理",url:"file"},{name:"设备管理",url:"equipment"}]},{name:"计算机网络",url:"network",children:[{name:"基础",url:"basic"},{name:"数据链路层",url:"transformData"},{name:"网络层",url:"forwardData"}]}];var Zr=n("./node_modules/react/jsx-runtime.js");const ti=()=>{const t=(0,Yr.useRef)(null),[e,n]=(0,Yr.useState)(0),r=e=>{const r=+e.currentTarget.dataset.index;n(+r),Gr.fromTo(t.current,{opacity:0,y:`-${100*r}vh`},{ease:"sine",duration:.6,opacity:1})};return(0,Zr.jsxs)(Zr.Fragment,{children:[(0,Zr.jsx)("div",{className:"point-box",children:new Array(7).fill("").map(((t,n)=>(0,Zr.jsx)("div",{"data-index":n,onClick:r,className:"item "+(e===n?"active":""),children:n+1},n)))}),(0,Zr.jsx)("div",{className:"box",id:"pageBox",ref:t,onWheel:e=>{const r=e.deltaY,i=r>0?-1:1,a=r>0,s=t.current;if(Gr.isTweening(s))return;const o=Gr.getProperty(s,"y");if(a&&-600==o||!a&&0==o)return;const c=o+100*i;n(Math.abs(c)/100),Gr.to(s,{y:`${c}vh`,ease:"M0,0 C0.126,0.382 0.252,0.72 0.41,0.868 0.602,1.048 0.818,1.001 1,1 ",duration:.8})},children:Jr.map((({url:t,name:e,children:n},r)=>(0,Zr.jsx)("div",{className:`page-item ${t}`,children:(0,Zr.jsxs)("div",{className:"pointer-bg menu-box",children:[(0,Zr.jsxs)("p",{className:"nav",children:[(0,Zr.jsx)("span",{className:`title tit${r+3}`})," ",(0,Zr.jsxs)("span",{children:[" ",e]})]}),null==n?void 0:n.map(((n,r)=>(0,Zr.jsx)("div",{className:"list",children:(0,Zr.jsx)("div",{className:"item",children:(0,Zr.jsxs)(Qr.OL,{to:`${t}/${n.url}`,state:e+"#"+n.name,children:[i.Y$[r],". ",n.name]})})},n.url)))]})},t)))})]})};n("./src/css/computer.scss");var ei=n("./node_modules/@s-ekin/web/lib/index.js"),ni=n("./src/js/util/utilCom.tsx");var ri=({children:t,articleData:e})=>{const n=(0,r.TH)(),[a,s]=(0,Yr.useState)(!1),[o,c]=(0,Yr.useState)([]);return(0,Zr.jsxs)(Zr.Fragment,{children:[(0,Zr.jsxs)("div",{className:"header",children:[(0,Zr.jsxs)("div",{className:"menu-list",children:[(0,Zr.jsx)("div",{className:"j-button",children:(0,Zr.jsx)(ei.SvgIcon,{className:"program"})}),(0,Zr.jsx)("div",{className:"router-menu",children:(0,Zr.jsx)(ei.ScrollBox,{className:"menu-wrap",children:(0,Zr.jsx)("div",{children:Jr.map((({url:t,name:e,children:n})=>(0,Zr.jsxs)("div",{className:"item",children:[(0,Zr.jsxs)("p",{className:"tit",children:[(0,Zr.jsx)(ei.SvgIcon,{className:"study"})," ",(0,Zr.jsx)("span",{children:e})]}),null==n?void 0:n.map((n=>(0,Zr.jsx)("div",{className:"list",children:(0,Zr.jsx)("div",{className:"nav-item",children:(0,Zr.jsx)(Qr.OL,{to:`/study/computer/${t}/${n.url}`,state:e+"#"+n.name,children:n.name})})},n.url)))]},t)))})})})]}),(0,Zr.jsx)("div",{className:"theme",children:n.state}),(0,Zr.jsxs)("div",{className:"menu-list",children:[(0,Zr.jsx)(ei.Search,{width:280,field:"mathSerch",searchHandle:t=>{const r=t.includes("，")?t.split("，"):t.split(","),a=n.pathname.split("/");a.pop();const o=a.pop();let l={};Jr.find((t=>{if(t.url==o)return t.children&&t.children.map((t=>{l[t.url]=t.name})),!0}));let h=[];const u=t.includes("，")?"every":"some";if(Array.isArray(e)){const t=(0,i.r$)(e,r,u);t.length&&h.push({chapter:"笔记",data:[{tit:"",arr:t}]})}else Object.keys(e).map(((t,n)=>{const a=l[t],s=e[t].article.map((({tit:t,note:e,compare:n,explain:a},s)=>{const o=[];if(n){const t=(0,i.r$)(n[0][1],r,u);if(t.length&&o.push({tit:n[0][0],arr:t}),n[1]){const t=(0,i.r$)(n[1][1],r,u);t.length&&o.push({tit:n[1][0],arr:t})}}if(a){const t=(0,i.r$)(a[0][1],r,u);if(t.length&&o.push({tit:a[0][0],arr:t}),a[1]){const t=(0,i.r$)(a[1][1],r,u);t.length&&o.push({tit:a[1][0],arr:t})}}if(e){const t=(0,i.r$)(e,r,u);t.length&&o.push({tit:"笔记",arr:t})}return{tit:`第${(0,i.aK)(s)}节、${t}`,arr:o}})).filter((t=>t.arr.length)),o={chapter:`第${(0,i.aK)(n)}章 ${a}`,data:s};s.length&&h.push(o)}));h.length?(c(h),s(!0)):ei.notice.add("搜索不到结果!","warn")}}),t]})]}),(0,Zr.jsx)(ei.Modal,{className:"search-modal",toggleFn:(t,e)=>s(e),show:a,tit:"搜索结果",field:"search",children:(0,Zr.jsx)("div",{className:"search-box",children:o.map((t=>{const{chapter:e,data:n}=t;return(0,Zr.jsxs)("div",{className:"item",children:[(0,Zr.jsx)("p",{className:"chapter-tip",children:e}),(0,Zr.jsx)("div",{className:"list",children:n.map(((t,e)=>(0,Zr.jsxs)("div",{className:"section-box",children:[(0,Zr.jsx)("p",{className:"bar tit-txt",children:t.tit}),(0,Zr.jsx)("div",{className:"res-box",children:(0,Zr.jsx)(ni.CZ,{data:t.arr,lev:0,parseType:"code"})})]},e)))})]},e)}))})})]})};var ii=({dataObj:t})=>{const e=(0,r.UO)(),n=(0,Yr.useRef)(null),[a,s]=(0,Yr.useState)([]),o=t[e.id],c=t=>{const e=t.currentTarget.dataset.id;s((t=>t.includes(e)?t.filter((t=>t!=e)):t.concat(e)))};if(!o)return(0,Zr.jsx)(ei.Empty,{});const{top:l,article:h}=o;return(0,Zr.jsxs)(Zr.Fragment,{children:[(0,Zr.jsx)(ri,{articleData:t}),(0,Zr.jsx)("div",{className:"wrap-box",ref:n,children:(0,Zr.jsxs)("div",{className:"layout-box paper-bg",children:[(0,Zr.jsx)("div",{className:"eq-3",style:{marginTop:0},id:"top",children:l.map(((t,e)=>(0,Zr.jsxs)("div",{className:"item",children:[(0,Zr.jsx)("div",{className:"tit",children:(0,Zr.jsx)("span",{children:t[0]})}),(0,Zr.jsx)(ni.CZ,{data:t.slice(1),lev:2,parseType:"code"})]},e)))}),h.map(((t,e)=>{const{note:n,compare:r,explain:s,tit:o,compare1:l,compare2:h,explain1:u,explain2:p}=t,d=[r,l,h],f=[s,u,p];return(0,Zr.jsxs)("div",{className:"acticle-item",children:[(0,Zr.jsxs)("div",{className:"chapter",children:["第",(0,i.aK)(e),"节、",o]}),f.map(((t,n)=>t?(0,Zr.jsx)("div",{className:"block_2_1",children:null==t?void 0:t.map(((t,r)=>{const i=`${e}-explain-${n}`;return(0,Zr.jsx)("div",{className:["left-box bg1","right-box"][r],children:t?(0,Zr.jsx)(ni.Bk,{parseType:"code",className:"title tit"+(6+n%2),data:t,id:i,slide:a.includes(i),setSlideFn:c}):null},r)}))},n):null)),d.map(((t,n)=>t?(0,Zr.jsx)("div",{className:"eq_2-box bg1",children:t.map(((t,r)=>{const i=`${e}-compare-${n}`;return t?(0,Zr.jsx)("div",{className:"item diamond ",children:(0,Zr.jsx)(ni.Bk,{parseType:"code",className:"title tit"+(2+(n+1)%2),data:t,id:i,slide:a.includes(i),setSlideFn:c})},r):null}))},n):null)),(0,Zr.jsx)("div",{className:"note-box bg1",children:n?(0,Zr.jsxs)(Zr.Fragment,{children:[(0,Zr.jsx)("div",{className:"note-tit",children:(0,Zr.jsx)(ei.SvgIcon,{className:"read-book"})}),(0,Zr.jsx)("div",{className:"note-content",children:(0,Zr.jsx)(ni.CZ,{data:n,lev:1,parseType:"code"})})]}):null})]},e)}))]})})]})};const ai=(t,e,n)=>`** <a target="__blank" href="https://github.com/S-Ekin/arithmetic/blob/main/include/${t}/${e}.cpp"><svg class="icon normal middle" aria-hidden="true"><use xlink:href="#sekin-github"></use></svg> ${n||e}-源码</a>`,si=(t,e,n,r)=>`\\img{${t}/${e}}[${n||"100"}${"number"==typeof n?"em":"%"}${r?"left":""}]`;var oi={basic:{top:[["环境配置","编辑器和编译器及环境变量设置","如何编译运行"],["项目结构","文件分类存放","引用其他文件里变量、函数"],["复合数据类型识别","结构体","指针"]],article:[{tit:"运行环境",explain:[["环境配置和运行",[["直接cmd运行","编译器[mingw64]","安装之后，改变[bin]目录下的[mingw32-make]为[make],这样可以直接使用简单命令名称[make]","然后，可以直接再项目下的cmd上使用[make clean run],清理和运行项目。"],["使用vscode的启动配置","直接[点击]vscode[工具栏]的那个操作按钮，出现[选择调试配置]，选择有[g++]的那个","会自动生成[task.json]和[launch.json]，也就是启动配置，和任务配置","这样可以[打断点]，直接使用vscode的debug按钮。比之前自己在网上复制的那些配置更适合，更好用。","要是启动失败，就直接在命令行使用[make clean]先清除一下再编译。其实以前自己也用过这样的一套流程，好久不用，不知道了。今天又摸索了一遍，并且记下来。免得每次长时间不用，就不知道怎么配置了，也搞不懂配置了。","只要是含有$int main()$函数的文件，都可以启动[debug]"],["关于[vscode多文件]编译的问题","在文件里通过[头文件]引用[其他文件]的函数时，出现引用失败，其实就是[多文件]编译失败的问题","通过vscdoe生成的配置[tasks.josn]里,默认是[{file}]编译单文件的，对于通过[头文件]去引用其他的文件，编译器是不知道去哪找头文件里声明的函数的定义是在哪，因此就不会编译,导致引用找不到，但是编辑器的提示是没有问题的。","虽然可以通过[{fileDirname}\\\\*.cpp]来指定编译当前文件[所属的目录]下所有的源文件，但是不灵活，得把[所有相关]的文件放[同一目录]下。并且会编译所有。",'其实有两种解决办法，一种就是直接引入源文件$#include "xx.cpp"$，这就相当于用不到[头文件],如果引入的文件很多的话，就得一个个引入，不能通过一个头文件解决。其实这是个小问题，js的模块不就是这样的。',"另外一种是使用[cmakelist]文件来指定当前文件所依赖的文件，这样就可以一起编译了，就是更麻烦了，老是要写[cmakelist]文件，还不如直接引入，反正都要指定",'$@json@\n              {\n                "tasks": [\n                    {\n                      "type": "cppbuild",\n                      "label": "vsdebug",\n                      "command": "D:\\mingw64\\bin\\g++.exe",\n                      "args": [\n                          "-fdiagnostics-color=always",\n                          "-g",\n                          "-fexec-charset=GBK", // 处理mingw中文编码问题\n                          "-finput-charset=UTF-8",// 处理mingw中文编码问题\n                          "${file}",\n                          // "{fileDirname}\\\\*.cpp", // 编译当前文件所属的文件夹下的所有 .cpp 文件。\n                          "-o",\n                          "${fileDirname}\\\\${fileBasenameNoExtension}.exe"\n                      ],\n                      "options": {\n                          "cwd": "{fileDirname}"\n                      },\n                      "problemMatcher": [\n                          "$gcc"\n                      ],\n                      "group": "build",\n                      "detail": "调试器生成的任务。"\n                  }\n                ],\n                "version": "2.0.0"\n              }$']]],["编译工具",["*.[make/makefile/cmake/nmake]",["gcc","也可以简单认为是编译器,我们的程序只有一个源文件时，直接就可以用gcc命令编译它。可是，如果我们的程序包含很多个源文件时，所以出现了下面make工具。"],["make","[make]工具可以看成是一个智能的[批处理]工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用[makefile]文件中用户指定的命令来进行编译和链接的。"],["makefile","简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。","makefile在一些简单的工程完全可以人工拿下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改，这时候就出现了下面的Cmake这个工具。"],["cmake","cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他更牛X功能，就是可以跨平台生成对应平台能用的makefile，我们就不用再自己去修改了。"],["CMakeList.txt","是你自己手写的",si("cpp",1,24)],["源码到可执行文件过程",si("cpp",3,"80",!0),"*.参考《程序是怎样跑起来》第八章"]]]],note:["单引号：字符常量, 双引号：字符串常量","字符串：每个字符串后面自动加一个\0,它是一个字符类型数组","字符是一个[数]，是可以四则运算的。例如[a]是[97]"]},{tit:"项目结构",compare:[["导入内置和自定义",[["导入内置的东西","命名空间$namespace$","常量定义$#define$","使用[C里面的库]需要导入[stdlib.h]","$\n                // 使用C里面的 NULL 、free、malloc\n                #include <stdlib.h> \n                using namespace std; // 用了 std，才能使用 cin;\n                using std::cin; // 第二种\n                int main(int argc, char *argv[]) {\n                  int a;\n                  cin >> a ; \n                  return 0;\n                }\n              $",["$#include$命令","是来自[C语言]的宏命令，他在编译器进行[编译之前]，即在[预编译]的时候就会起作用。","作用就是把它后面的那个文件的内容，完完整整的，一字不改地[包含到]当前的文件中来。它本身是没有其他任何作用与副功能的，它的作用就是把每一个它出现的地方，替换成 它后面文件的内容，就是简单的[文本替换]，别无其他，仅此而已。","如果文件名用尖括号[<>]括起来，表明这个文件是一个[C++标准库]中的头文件，编译器会在预定的[系统目录]中查找该文件。",'果文件名用双引号[" "]括起来，表明这个文件是[用户自己提供]的头文件，预编译器会先在当前文件所在的目录中查找，如果找不到，则继续到系统目录中查找。']],{tit:"头文件",arr:[["头文件是什么","通常，在一个[C++]程序中，只包含两类文件—— [.cpp]文件和[.h]文件。","其中[.cpp]文件被称作[C++]源文件，里面放的都是[C++]的源代码","而[.h]文件则被称作[C++]头文件，里面放的也是[C++ ]的源代码。但头文件不用被编译。","C++ 语言支持[分别编译],也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的[.cpp]文件里。","[.cpp]文件里的东西都是[相对独立]的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做[一次链接（link）]就行了。比如，在文件[a.cpp]中定义了一个全局函数$void a(){}$，而在文件[b.cpp]中需要调用这个函数。即使这样，文件[a.cpp]和文件[b.cpp]并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。","这是怎么实现的呢？从写程序的角度来讲，很简单。在文件[b.cpp]中，在调用$void a()$函数之前，先声明一下这个函数 $void a();$，就可以了。","这是因为编译器在编译[b.cpp]的时候会生成一个[符号表（symbol table）]，像$ void a()$这样的[看不到]定义的符号，就会被存放在这个表中。","再进行链接的时候，编译器就会在[别的]目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。"],["头文件中应该写什么","*.头文件中应该只放变量和函数的[声明]，而不能放它们的[定义]。因为一个头文件的内容实际上是会被引入到多个不同的[.cpp]文件中的，并且它们都会被编译。",["头文件中可以写$const$对象的定义。","因为全局的$const$对象默认是没有$extern$的声明的，所以它只在当前文件中有效。","把这样的对象写进头文件中，即使它被包含到其他多个[.cpp]文件中，这个对象也都只在[包含它]的那个文件中有效，对其他文件来说是不可见的，所以便不会导致[多重定义]。","同时，因为这些[.cpp]文件中的该对象都是从一个头文件中包含进去的，这样也就保证了这些[.cpp]文件中的这个$const$对象的值是相同的，可谓一举两得。同理，$static$对象的定义也可以放进头文件。"],["头文件中可以写[内联函数inline]的定义。","因为[inline函数]是需要[编译器]在遇到它的地方根据它的定义把它[内联展开]的，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在[编译时]看到内联函数的完整定义才行。","如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义","但是，如果我在其他的文件中还使用到了这个函数那怎么办呢？这几乎没什么太好的解决办法","因此C++ 规定，[内联函数]可以在程序中[定义多次]，只要内联函数在一个[.cpp]文件中只出现一次，并且在所有的[.cpp]文件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。"],["头文件中可以写[类class]的定义。","因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟[内联函数]是基本一样的。所以把类的定义放进头文件，在使用到这个类的[.cpp]文件中去包含这个头文件，是一个很好的做法。","在这里，值得一提的是，类的定义中包含着[数据成员]和[函数成员]。数据成员是要等到具体的[对象被创建时]才会被定义（分配空间），但[函数成员]却是需要在[一开始]就被定义的，这也就是我们通常所说的[类的实现]。","一般，我们的做法是，把[类的定义]放在头文件中，而把[函数成员]的实现代码放在一个[.cpp]文件中。这是可以的，也是很好的办法。","不过，还有另一种办法。那就是直接把[函数成员]的实现代码也[写进]类定义里面。在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为[内联的]。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。","注意一下，如果把函数成员的定义写在类定义的[头文件]中，而[没有]写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被[重定义]了。"]],["头文件中的保护措施","考虑一下，如果头文件中只包含声明语句的话，它被同一个[.cpp]文件包含再多次都没问题——因为声明语句的出现是[不受限制]的。","一旦一个头文件中出现了上面三个例外中的任何一个，它再被一个[.cpp]包含[多次]的话，问题就大了。因为这三个例外中的语法元素虽然[可以定义在多个源文件中]，但是[在一个源文件中只能出现一次]。","设想一下，如果[ a.h ]中含有类 [A] 的定义，[b.h ]中含有类 [B ]的定义，由于类[B]的定义依赖了类 [A]，所以 [b.h ]中也 $#include a.h$。","现在有一个源文件，它同时用到了类[A]和类[B]，于是程序员在这个源文件中既把[ a.h] 包含进来了，也把 [b.h ]包含进来了。这时，问题就来了：类[A]的定义在这个源文件中出现了[两]次！于是整个程序就不能通过编译了。你也许会认为这是程序员的失误——他应该知道[b.h]包含了[a.h ]——但事实上他不应该知道。 ","使用$#define$配合[条件编译]可以很好地解决这个问题。在一个头文件中，通过 #define 定义一个名字，并且通过条件编译 $#ifndef...#endif $使得编译器可以根据这个名字是否被定义，再决定要不要继续编译该头文中后续的内容。这个方法虽然简单，但是写头文件时[一定]记得写进去。","$\n                    // 第一种\n                    #pagram once\n                    #define MaxSize 34000 //定义常量\n\n                    // 第二种\n                    #ifndef \n                      #define maxSize 50;\n                    #endif;\n                  $"],["C++头文件和源文件的区别",["[源文件]如何根据 $#include $来[关联]头文件","[系统自带]的头文件用[尖括号]括起来，这样编译器会在系统文件目录下查找。","用户[自定义]的文件用[双引号]括起来，编译器首先会在用户目录下查找，然后在到 C++ 安装目录（比如 VC 中可以指定和修改库文件查找路径，Unix 和 Linux 中可以通过环境变量来设定）中查找，最后在系统文件中查找。"],["[头文件]如何来[关联]源文件",'这个问题实际上是说，已知头文件[a.h]声明了一系列函数，[b.cpp] 中实现了这些函数，那么如果我想在 [c.cpp]中使用[a.h]中声明的这些在[b.cpp]中实现的函数，通常都是在 [c.cpp]中使用 $#include "a.h"$，那么[c.cpp]是怎样找到[b.cpp]中的实现呢？',"其实 [.cpp] 和 [.h]文件名称[没有]任何直接关系，很多编译器都可以接受其他扩展名。比如偶现在看到偶们公司的源代码，[.cpp] 文件由 [.cc] 文件替代了。",'谭浩强老师的《C 程序设计》一书中提到，编译器预处理时，要对$ #include $命令进行[文件包含处理]：将[file2.c] 的全部内容复制到 $#include "file2.c"$处。',"这也正说明了，为什么很多编译器并不[care]到底这个文件的后缀名是什么----因为 $#include$ 预处理就是完成了一个[复制并插入代码]的工作",'编译的时候，[并不会]去找[b.cpp]文件中的[函数实现]，只有在[link]的时候才进行这个工作。我们在 [b.cpp] 或 [c.cpp] 中用 $#include "a.h" $实际上是[引入]相关声明，使得[编译]可以通过，程序并不关心[实现]是在哪里，是[怎么]实现的。',"源文件编译后成生了[目标文件]（.o 或 .obj 文件），目标文件中，这些函数和变量就视作一个个[符号]。在 [link] 的时候，需要在 [makefile] 里面说明需要连接哪个[ .o] 或 [.obj] 文件（在这里是 b.cpp 生成的 .o 或 .obj 文件），此时，连接器会去这个 [.o] 或 [.obj ]文件中找在 [b.cpp] 中实现的函数，再把他们 [build] 到 [makefile] 中指定的那个可以执行文件中。","在Unix下，甚至可以[不在]源文件中包括头文件，只需要在[ makefile] 中指名即可（不过这样大大降低了程序可读性，是个不好的习惯哦^_^）。在 VC 中，一帮情况下不需要自己写[ makefile]，只需要将需要的文件都包括在 [project]中，[VC] 会自动帮你把 [makefile] 写好。","通常，C++ 编译器会在每个 [.o] 或 [.obj ]文件中都去找一下所需要的[符号]，而不是[只在]某个文件中找或者说找到一个就不找了。因此，如果在几个不同文件中实现了同一个函数，或者定义了[同一个]全局变量，链接的时候就会提示 $redefined$"]],["总结",["[.h]文件中能包含：","类成员数据的声明，但不能赋值","*类静态数据成员的声明","类的成员函数的声明","非类成员函数的声明","常数的定义：如：$const int a=5;$","静态函数的定义","类的内联函数的定义"],["不能包含：","所有非静态变量（不是类的数据成员）的声明","*类静态数据成员的定义和赋值，","默认命名空间声明不要放在头文件，$using namespace std;$等应放在[.cpp]中，在 [.h] 文件中使用 $std::string$"]]]}]],["输入和输出",[["C","关于[printf、scanf]",'$\n                #include <stdio.h>\n                int main()\n                {\n                  char ch = \'A\';\n                  char str[20] = "www.runoob.com";\n                  float flt = 10\\.234;\n                  int no = 150;\n                  double dbl = 20.123456;\n                  printf("字符为 %c \\n", ch);\n                  printf("字符串为 %s \\n", str);\n                  printf("ASCII 值 = %d, 字符 = %c\\n", no , ch );\n                  return 0;\n                }\n              $'],["C++","关于[cin、cout]"]]]]},{tit:"类型定义",compare:[["结构体",[{tit:"*.结构体构造",arr:["$\n                  typedef struct {\n                    int a;\n                    chart b;\n                  } TypeA;\n\n                  typedef struct Node {\n                    int data;\n                    struct Node *next;\n                  } Node;\n\n                  typedef struct BTNode {\n                    int data;\n                    struct BTNode *lchildren;\n                    struct BTNode *rchildren;\n                  } BTNode, *btnode;\n                  \n                  typedef struct BTNode\n                  {\n                    int data;\n                    struct BTNode *lchild;\n                    struct BTNode *rchild;\n                    // 赋值初始值\n                    BTNode():data(),lchild(nullptr), rchild(nullptr){}\n                  } BTNode;\n                $"]},["结构体解释","Node: 这个结构型的名字为[Node]，因为组成此[结构体]的成员中有一个是指向和自己类型相同的变量的[指针]，内部要用[自己]来定义这个指针，所以写成$struct Node *next$","如果结构体内没有[指向自己]类型的[指针]，可以不用在$typedef struct$后加名称，例如$TypeA$","这里的写$*btnode$是为了让$btnode p$等价$BTNode * p$,其实没必要这样写。少写一个[*]号使表达式看起来更加不具可读性。","*.不写$typedef$，一些纯[C]编译器不能通过！","[@\\href{https://blog.csdn.net/zpf1813763637/article/details/130022626}{什么是结构体的声明、定义、初始化}]"],{tit:"*.实例化对象",arr:[["$\n                    BTNode BT; \n                    BTNode *BT2;\n                    // 一次申请一个节点空间\n                    BT2 = (BTNode*) malloc(sizeof(BTNode));\n                    // 一次申请n个节点空间\n                    int *pi\n                    p= (int *)malloc (n * sizeof (int));\n                  $",["[BTNode]类型和[BTNode指针]类型","第二种先定义一个结点的[指针BT]，然后用函数$malloc()$来申请一个结点的[内存空间]，最后让指针$BT$指向这片内存空间","$BT2$是个[指针型变量]，用它来存储[刚]制作好的结点的地址。因$BT2$是变量，虽然现在$BT2$指向了刚生成的结点，但是在以后必要的时候$BT2$可以离开这个结点转而[指向其他结点]。","而$BT$则不行，$BT$就是某个结点的名字，一旦定义好，它就不能[脱离]这个结点了","从这里就看到$BT2$比$BT$更灵活，因此$BT2$用得多，并且$BT2$完全可以取代$BT$ （$BT2$的值不改变就相当于$BT$）"],"*在真实环境上，[函数外]只能定义[全局变量]或者[对象] ，而[不能]执行语句及调用函数 。"]]},["关于$typedef$ 和 $#define$",["对于$typedef$","$typedef$可以理解为给现有的数据类型起一个新名字，如$typedef struct{} TypeA$即给$struct {}$起了一个名字$TypeA$","$\n                  typedef int A;\n                  // 两者等价\n                  int a;\n                   A a;\n                 $"]]]],["声明和定义",[["变量的声明和定义",["声明","声明是用来告诉[编译器]变量的[名称]和[类型]，而[不分配]内存。","$\n                  extern int var; // 声明\n                  extern int ble =10; // 定义\n                  typedef int INT; // 声明\n                  struct Node; // 声明\n                $","上面代码中，语句$extern int var$表示$var$在别的文件中[已经定义]，提示[编译器遇]到此变量时在[其它模块]中寻找其定义。","语句$extern int ble = 10；$表示定义了变量 $ble$，这一点需要注意。","注意：即使是$extern$，如果给变量[赋值]了，就是[定义]了。"],["定义","[定义]是为了给[变量]分配[内存]，可以为变量[赋]初值。","注意：[全局变量]或[静态]变量初始值为[]0，[局部变量]初始化为[随机值]。","在[C/C++]中，[变量]的声明和定义区别并不大，定义和声明往往是[同时]发生","变量定义时，会根据变量类型分配空间，如下所示：","$\n                  int value ; //声明 + 定义\n                  struct Node { // 声明 + 定义\n                      int left;\n                      int right;\n                      char str;\n                  }; \n                  // 定义结构体并初始化\n                    Node myStruct = {1, 2, 'a'};\n                $"],["区分定义和声明","通常变量的定义和声明是[同时发生]的，注意：[extern 变量类型 变量名]仅是声明。"],["*类型符号的理解","[C或C++]的[编译器]被设计成按照[从右向左]的顺序来处理函数调用中的变元。但是编译器[扫描变元]的顺序却是[从左向右]的","同理，想要弄清楚变量定义，使用[从右向左]的顺序理解[类型符号]","*但是[数组]要特别理解，[由内向外]阅读要比[从右向左]好多了。由内向外的顺序可帮助我们更好地理解[Parray]的含义","首先是圆括号括起来的部分，$*Pazrray$意味着$Parray$是个[指针]，接下来观察[右边]，可知道$arr$是个指向大小为10的数组的[指针]，最后观察左边，知道数组中的元素是int。","$\n                  int *ptrs[10]; // ptrs 是含有10个整型指针的数组 \n                  tnt &cefs[10] = /wx ?+*/; // 错误 : 不存在引用的数组 \n                  int (*Parray) [101] &arr; // Partray 指向一个含有10个整数的数组 \n                  int (&arrRef) [10] = arr; // arrRef 引用一个含有10个整数\n                $"]],["函数的声明和定义",["函数声明","函数的声明是[通知]编译器函数名称、参数数量和类型以及函数返回类型，例如：","$int Max(int x, int y);$"],["函数定义","函数的定义是为函数分配内存","$\n                  int Max(int x, int y) {\n                    return x > y ? x : y;\n                  }\n                $","函数定义包含了函数的具体实现"],["函数声明和定义区分","函数只要有实现（存在函数体 ）即为[定义]，否则为[声明]。","可以这样理解：函数声明是说明函数[是什么]，函数定义是说明函数[做什么]。"]],["声明和定义的区别","声明/定义次数: 变量/函数可以[声明]多次，变量/函数的[定义]只能一次。","分配内存: 声明[不会]分配内存，[定义]会分配内存。","做了什么: 声明是告诉编译器变量或函数的类型和名称等，定义是告诉编译器变量的[值]，函数具体干什么。"],["初始化值和默认值","[全局变量]默认的就是0，","[局部变量]是在栈上临时申请的，是一个随机值。。。",'$\n                int i1; // 0\n                int main(){\n                  int i2; // 随机值\n                  cout << i1 << ""<< i2 << endl;\n                }\n              $']]]],compare1:[["限定符",[["常量$const$","因为[const]对象一旦建立了就[_不能修改_]，所以[const]对象必须初始化","[const量]的内存值均可[通过-指针-的方式进行^修改^]","性质为[_常变量_的-const量-]，其值与内存值相关联，在编译阶段，需要去[内存中寻址取值]","*性质为[_常量_的-const量-]，其值与内存值无关，等于初始化值，在编译阶段，类似文本替换一样；在编译阶段，[_不再_去内存中寻址取值]，即使修改了对应内存中的值，也对其使用值无影响；","[|C语言|]，[-const量-]无论其初始化方式，都是被当作[常变量]处理；在[|C++|]，根据其初始值的不同，[-const量-]可表现为[常量]，也可表现为[常变量]；","$\n                int main() {\n                  int a = 9;\n                  const int n = a;//not initialized with a constant expression;此时n为常变量\n                  const int n2 = 9;//initialized with a constant expression;此时n2为常量、常量表达式\n                  return 0;\n                }\n              $","[@\\href{https://blog.csdn.net/KingOfMyHeart/article/details/114334878}{常量和常变量}]",'$\n              int main() {\n                  const int n = 100;\n                  int* p = (int*)&n; // 注意要强制转化为int * ,因为不能用 const int * 去初始化 int *\n                  *p = 60;\n                  printf("%d %d %d\\n", n, *p, *(&n)); //100 60 100\n                  return 0;\n              }\n              $'],["其他类型","字面值类型","常量表达式","[顶层]const和[底层]const"]]],["类型别名",[["$typedef$"]]]]},{tit:"指针",explain:[["指针和地址",[["概念","[内存单元]的地址就是[指针]，也就是说[_指针_就是-地址-],指向的就是[内容]，也就是[^地址^和^内容^]的关系","[指针变量]：$int *p1,*p2;$，存放[-地址(指针)-]的变量称为指针变量","[地址]：[内存单元的|编号|]也叫做地址。","[变量]：[-内存空间-的^名称^]","*各种类型的指针都有地址，通过[-地址(指针)-或_变量名_访问变量]"],["变量的[_声明_、_定义_和_初始化_的区别]","*.[@\\href{https://mp.weixin.qq.com/s/nNIP5zDfCPuGgpOwLwm_fQ}{图解C/C++灵魂：指针变量}]","[变量定义]：用于为变量[分配_存储空间_]，还可为变量指定[-初始值-]。程序中，变量[有且仅有_一个_定义]。","[变量声明]：用于向程序[^表明^变量的|类型|和|名字|]。","[变量初始化]：就是给变量[^赋值^]。",["定义的详解","[-定义-也是^声明^]，$extern$是声明[不是定义]，[-变量-在_使用前_就要|被定义|或者|声明|]。","在一个程序中，变量只能[^定义一次^]，却可以[声明多次]。","**[-定义-分配|存储空间|]，而声明不会。定义完之后才能初始化，所以[-初始化-]的时候已经分配内存","$\n                   extern int i; // 声明 i 而非定义 i\n                   int j; // 声明并且定义，只不过是没有给初始值。 \n                   extern double pi = 3.1415; // 成为定义              \n                $","任何包含了[^显式初始化^的-声明-]即成为[|定义|]","当[|声明|一个-指针变量-]，没有初始化时，指针变量只获得了其[^自身^的内存空间]，而其[指向还_没有确定_]，"]],["一些和指针搭配的特别用法",["引用、传值、传地址","$\n                  int *a = 3;\n                  int *b;\n                  int c = 4;\n                  int d;\n                  d = *a; // 取值\n                  b = &c; // 取地址，也可以叫改变指向\n                $"],["申请和释放[指针]","$\n                #include <stdlib.h> //因为 free malloc 是C里面的\n                int * a;\n                free(a);\n                int * c = (int *)malloc(sizeof int);\n                $"],["解引用指针(间接访问)、指针的强制转化.","[@\\href{https://blog.csdn.net/xierhacker/article/details/52516742}{深度长文教你彻底掌握C++/C指针(一):基石}]"],["二级指针和一级指针","本质：通过[二级]指针[^修改^一级]指针所指向的[-内存-]"]]]],["问题",[["[变量]是在[需要]时,还是[一开始]就创建？","$\n                LNode *p;\n                // LNode * q;\n                if (p->next !=NULL) {\n                  //我自己更倾向于需要时\n                  LNode * q; \n                  q = p->next;\n                }\n              $"],["什么时候用[指针]，什么时候用[引用]","[-引用-]本来就是用来[改变]参数所[^代表^的那个值]，这样就不需要用[函数返回]这个值了，就可以把[函数的返回值]用来[代表]是否执行顺利。"],["指针在什么时候需要申请内存空间？","$\n                // 1\n                int *q;\n                *q = 1;\n                // 错误！q没有指向一块内存空间，不能直接存放数据。\n                \n                // 2\n                int *q, a = 1;\n                q = &a;\n                *q = 4; //解引用做左值,改变了 a的值\n                // 正确，两次q的地址不一样。\n                q=&a; //q指向变量a所在的内存空间，变量a是一个int型，\n                //在内存中有大小为int类型的内存空间。算是间接地给q分配了空间吧。\n              $"],["别把指针当作[JS]里的对象类型",'$\n              void test(){\n                int num = 1;\n                int num1 = 2;\n                int *p= &num ;\n                int *p2 =p; \n                p = &num1; // 指针就算一个字符串类型的地址，赋值给别的指针后，当改变自己时，别人不会变的\n                cout << *p2 << "  " << *p << endl;\n                // 1 2  \n              }\n              $']]]],compare:[["内存",[["内存分配方式","*.[@\\href{https://smartkeyerror.com/c-pointers-and-memory}{指针和内存讲解}]","*.C++有两种分配内存的方式：[静态内存分配] 和 [动态内存分配]",["[静态]内存分配","在[编译阶段]就分配好存储单元空间","在程序运行过程中，这些空间的大小是[不可更改的]，也无需对这些空间进行管理。不能手动释放，只能等待系统释放","编译时已将管理这些空间的代码加入目标程序，在[_作用域_结束]之后，[_自动_将空间归还给系统]。也就是说，静态分配的变量在该函数内运行的时候有效，当静态分配的变量所在函数运行完之后，该内存会自动释放","静态分配的内存，是[_在栈中_分配]的。静态分配[不能^跨函数^调用]，就是无法在另一个函数中，来管理一个函数中的内存。静态分配，只在当前函数有效，当静态分配所在的函数运行完之后，该变量就不能被其他的函数所调用。"],["[动态]分配空间","指在[程序语句中_通过内存分配函数_或者_内存分配运算符_取得的存储空间]","这样得到的空间的大小，[编译器]是不知道的，完全由动态运行中的[程序的当时的情况]来决定","这些空间在使用完毕后，必须[由程序语句^显示^的将其释放归还系统]，否则会使得系统分配和利用的内存空间不断减少，直至枯竭，导致系统无法工作。","动态分配和释放内存有两种方法：一是利用标准函数，如[-malloc-和-free-]，它们的原型在头文件[|stdlib.h|或|alloc.h|]中，这是从[_C语言_]中保留下来的方法；另外一种是用[-new-和-delete-运算符]，这是[_C++_]的方法。"]],["关于[malloc]与[new]的区别","malloc free等为[_函数_]，而new、delete为[_操作符_]","*malloc不会初始化,不会调用构造函数，而new可以初始化,会调用构造函数","malloc需要[计算类型大小]，new只需传[数据类型]","malloc返回值需强转，new不需要","malloc失败时返回NULL，而new是抛异常","malloc只会申请空间，而new则还会调用构造","*.[@\\href{https://blog.csdn.net/sinat_29957455/article/details/60883355}{malloc的用法及详解}]"]]]]}]},dataType:{top:[["基本类型","字符串","数字"],["定义","常量定义","结构体、类定义","函数定义"],["复合类型","数组、指针、引用"]],article:[{tit:"语言核心与代码工程",explain:[["结构",[si("cpp",2,"60")]],["基础核心概念",[["相关文章","[@\\href{https://mp.weixin.qq.com/s/lQoH4UF36_zKrw-Jbp2ylw}{C++知识体系总结：语言核心与代码工程}]"]]]]},{tit:"字符串与字符",compare:[["字符串",["*.注意对串的赋值操作，首先[先释放]原空间。$free(str)$",["定义","[定长]顺序存储表示的结构体","$\n              typedef struct\n              {\n                char str[maxSize];\n                int length;\n              } Str;\n            $","[变长]分配存储表示","$\n            typedef struct\n            {\n              char * ch; // 指向动态分配存储区首地址的字符指针\n              int length;\n            } Str;\n            $",["标准库类型$string$：表示可变长的字符序列","$\n              #include <string>;\n              string s1 = \"12321\";\n              string s4(5, 'c'); // ccccc\n\n              // string 类型的可以用使用 以空字符结尾的字符数组来代替，反之不行\n              char char_s = {'a','b','c','\\0'}; // 注意以空字符结尾\n              string str = char_s;\n              // string 通过成员函数 c_str 转为 char 字符数组\n              const char *charStr = str.c_str();\n            $"]]]],["字符",[["定义"]]]]},{tit:"数组",compare:[["数组",[["基础操作","*与[普通变量]赋值操作不同，将一个[数组]的值赋给另一个[数组]，直接用[=]是不可行的，必须对数组中的[每个元素]进行逐一赋值操作","不能对数组赋值，只能对数组元素初始化或赋值。","*初始化列表仅在[初始化期间]可用。","使用数组的时候，编译器一般会把它转换为[指针]，并且指向数组的[首元素]"],["关于数组的引用和引用的数组","*.就像[指针]的[数组]和[数组]的[指针]一样耐人寻味","引用的数组","$\n          //array首先向右结合，所以这个相当于 \n          // (int&)array[] array是个数组，其中的元素是引用\n          int &array[]\n        $","数组的引用","$\n          //array首先和&结合，\n          //所以array是引用，引用的对象是数组\n          int (&array)[10] \n        $"],{tit:"引用的数组",arr:[["*.引用的数组是不能当函数的参数的。再者要说明，这种方式是非法的",["原因：从引用的本质说","首先，引用必须被[初始化]，这没得说，而[数组]并不能被另一个数组初始化[或]被另一个数组赋值这是其一，并且其中的每一个引用，你没有办法给他一下子初始化","再次，引用它[不支持]传统意义的复制，它[不占]用新的空间","再再次，他没有意义，它可以用[指针数组]实现，完全可以代替","再再再次，不好实现，因为编译器[不知道]应该分多大的内存给引用的数组。"],"$\n                    int i,j;\n                    int *a[5] = {&i, &j};\n                    a[0]; // point to i\n                    a[1]; // point to j\n                  $"]]},{tit:"数组的引用",arr:[["$\n                  int n3[3] = {2, 4, 6};\n                  int (&rn3)[3] = n3;     //数组的引用\n                  $","*.数组的引用的应用",'$\n                  void Test(int (&array)[5])\n                  {\n                    cout << "size:"<< sizeof(array) << endl;\n                    for (int i = 0; i < sizeof(array)/4; i++)\n                    {\n                    cout << array[i] << "";\n                    }\n                  }\n                  int main()\n                  {\n                    int  array[5] = {1,2,3,4,5};\n                    Test(array);\n                    return 0;\n                  }\n                  $']]}]],["二维素组",[]]]},{tit:"函数",compare:[["函数基础",[{tit:"参数",arr:["*.注意传[值]和传[引用]、传[地址(指针)]",["*传引用，[C]没有引用类型，通过传[地址]来改变值","$\n                    int a;\n                    void f(int &x){\n                      x++;\n                    }\n                    f(a);\n                    // 传指针引用\n                    int *c = &a;\n                    void f2(int *&x){\n                      x++;\n                    }\n                    f2(c);\n                  $"],["**传数组","$\n                  // 一般都要有参数 n，作为要操作的数组的长度\n                  // C里面的数组操作\n                  void f(int arr[], int n){\n                    int first = *(arr);\n                    int two = *(arr+1);\n                  }\n                  \n                  // C++里面的数组操作\n                  void f(int arr[], int n){\n                    int first = arr[0];\n                    int two = arr[1];\n                  }\n                  // 二维数组，第二维要指明长度，第一维不用\n                  void f2(int[][MaxSize], int n){\n                  }\n                  $","传入数组时，[不要考虑_引用_或是_传值_的问题]，因为始终记住使用数组的名字时，会被替换为[指向数组^首元素^的-指针-]","在[C]编译器里，在函数里面对于[数组参数]，要按照[指针]的方式操作，不能直接进行数组那样的取值操作","[C]语言不能直接传[数组]","[C++]编译器里，可直接对数组参数进行取值，当数组用。但是[数组参数名]还是一个[指针]。改变[参数数组]的内容，[原数组]也变了。","不能传[数组的引用]$void f(int &arr[]) // 错误$"]]},{tit:"返回值",arr:[["不要返回[局部]对象的[引用]或[指针]","函数[完成]后，它所占用的存储空间也随之被[释放]掉。因此，函数终止意味着局部变量的[引用]将指向[不再有效]的内存区域","同样，返回[局部对象]的[指针]也是错误的。一且函数完成，局部对象被释放，[指针]将指向一个[不存在]的对象。",'$\n                    // 严重错误: 这个函数试图返回局部对象的引用 \n                    const string &manip () \n                    { \n                      string ret;\n                      // 以某种方式改变一下 ret \n                      if (!ret.empty()) \n                        return ret;  // 错误 : 返回局部对象的引用 ! \n                      else \n                        return "Empty"; // 错误 : "Empty" 是一个局部临时量 \n                    }\n                  $']]},["函数之间指针值的传递","[函数内定义-局部变量-]（如下例的a）保存在一个函数的[栈帧上]","当一个函数执行完毕后，另一个函数,如下例的$stackFrame_reuse()$执行时，该空间会被$stackFrame_reuse()$[^重复使用^]","[-a-]所使用的[空间]将不复存在，所以当一个[_指针变量_指向_局部变量_的内存空间时]，其地址值传递给主调函数时，并不是一个有效值。",'$\n                #include <stdio.h>\n                void funcForSpace(int **iptr) {   \n                  int a = 10;  \n                  *iptr = &a;\n                }\n                void stackFrame_reuse() {  \n                  int a[1024] = {0};\n                }\n                int main() {   \n                  int *pNew;  \n                  funcForSpace(&pNew);   \n                  printf("%d\\n",*pNew); // 10，此时栈帧还未被重复使用 \n                  stackFrame_reuse();  \n                  printf("%d\\n",*pNew); // -858993460，垃圾值  \n                  while(1);  \n                  return 0;\n                }\n              $']]]],compare1:[["特殊的函数使用",[{tit:"*.根据[前序]和[中序]数组，[非递归]构造二叉树",arr:['$\n                  // 非递归构造二叉树\n                  void nonReCreateBTByTravasel(BTNode *& tree){\n                    int leg = 8;\n                    int preArr[leg] = {1,2,4,9,5,3,7,14};\n                    cout << "1 2 4 9 5 3 7 14" <<endl;\n                    int midArr[leg] = {4,9,2,5,1,3,14,7};\n                    tree->data = preArr[0];\n\n                    int top = -1;\n                    int stackList[MaxSize][3]= {};\n                    BTNode *stackBTList[MaxSize]= {};\n                    ++top;\n                    stackList[top][0] = 0;\n                    stackList[top][1] = leg - 1;\n                    stackList[top][2] = 0;\n                    stackBTList[top] = tree;\n\n                    while (top > -1)\n                    {\n                      int *indexArrs = stackList[top];\n                      int start = indexArrs[0];\n                      int end = indexArrs[1];\n                      int preParIndex = indexArrs[2];\n                      BTNode * parNode = stackBTList[top];\n                      top--;\n\n                      int parVal = preArr[preParIndex];\n                      int leftChildNum =0;\n                        int midParIndex = 0;\n                      for (size_t i = start; i <= end; i++)\n                      {\n                        int item = midArr[i];\n                        if(item == parVal){\n                          midParIndex = i;\n                          break;\n                        } else {\n                          leftChildNum++;\n                        }\n                      }\n                      \n                      if(end - midParIndex > 0){// 存在右子树\n                        BTNode * right = new BTNode();\n                        int rightIndex = preParIndex + 1 + leftChildNum;\n                        right->data=preArr[rightIndex];\n                        parNode->rchild = right;\n                        \n                        top++;\n                        stackList[top][0] = midParIndex + 1;\n                        stackList[top][1] = end;\n                        stackList[top][2] = rightIndex;\n                        stackBTList[top] = right;\n                      }\n\n                      if(midParIndex - start > 0){ // 存在左子树\n                        BTNode * left = new BTNode();\n                        int leftIndex = preParIndex + 1;\n                        left->data=preArr[leftIndex];\n                        parNode->lchild = left;\n                        top++;\n                        stackList[top][0] = start;\n                        stackList[top][1] = midParIndex - 1;\n                        stackList[top][2] = leftIndex;\n                        stackBTList[top] = left;\n                      }\n                    }\n                  }\n                  $']},["递归与非递归之间的转化，重要的几点","必须使用[栈]来模拟","[-栈-保存的_对象_]就是[递归函数的_参数_]。注意多个参数的情况"]]],["递归",[{tit:"*.根据[前序]和[后序], [递归]构造二叉树",arr:[['$\n                    void mapTree(int start,int end, int midArr[],int preArr[],int preParIndex,BTNode *& parNode) {\n                      if(end - start < 1){\n                        return;\n                      }\n\n                      int leftChildNum = 0, midParIndex = -1;\n                      int parVal = preArr[preParIndex];\n\n                      // 中序里找到父节点\n                      for (size_t i = start; i <= end; i++)\n                      {\n                        int item = midArr[i];\n                        if(item == parVal){\n                          midParIndex = i;\n                          break;\n                        } else {\n                          leftChildNum++;\n                        }\n                      }\n\n                      if(midParIndex - start > 0){ // 存在左子树\n                        BTNode * left = new BTNode();\n                        int leftIndex = preParIndex + 1;\n                        left->data=preArr[leftIndex];\n                        parNode->lchild = left;\n                        mapTree(start, midParIndex - 1, midArr, preArr, leftIndex, left);\n                      }\n\n                      if(end - midParIndex > 0){// 存在右子树\n                        BTNode * right = new BTNode();\n                        int rightIndex = preParIndex + 1 + leftChildNum;\n                        right->data=preArr[rightIndex];\n                        parNode->rchild = right;\n                        mapTree(midParIndex + 1, end, midArr, preArr, rightIndex, right);\n                      }\n                    }\n\n                    // 根据 前序和中序数组 递归构造二叉树\n                    void createBTByTravasel(BTNode *& tree){\n                        int leg = 8;\n                      int preArr[leg] = {1,2,4,9,5,3,7,14};\n                      cout << "原前序：1 2 4 9 5 3 7 14" <<endl;\n                      int midArr[leg] = {4,9,2,5,1,3,14,7};\n                      cout << "原中序：4 9 2 5 1 3 14 7" <<endl;\n\n                      tree->data = preArr[0];\n                      mapTree(0, leg - 1, midArr, preArr, 0, tree);\n                    }\n                  $']]}]]]}]},advance:{top:[["编程思想","面向对象","泛型编程",""],["第三方库使用"],["新特性",""]],article:[{tit:"新特性",compare:[["难点",[["C++[右值引用]和$std::move$","*.[@\\href{https://zhuanlan.zhihu.com/p/335994370}{一文读懂C++右值引用和std::move}]","[有地址]的变量就是[左值]，没有地址的[字面值、临时值]就是[右值]",["左值引用","[引用]是变量的别名，由于[右值没有地址]，没法被修改，所以左值引用[无法]指向右值。","[const左值引用]不会修改指向值，因此可以指向右值","$\n                int a = 5;\n                int &ref_a = a; // 左值引用指向左值，编译通过\n                int &ref_a = 5; // 左值引用指向了右值，会编译失败\n                const int &ref_a = 5;  // 编译通过\n              $"],["右值引用","右值引用的标志是$&&$，可以指向右值，不能指向左值","$\n                  int &&ref_a_right = 5; // ok\n                  int a = 5;\n                  int &&ref_a_left = a; // 编译不过，右值引用不可以指向左值\n                  ref_a_right = 6; // 右值引用的用途：可以修改右值\n                $"],["右值引用有办法指向左值吗?","$\n                int a = 5; // a是个左值\n                int &ref_a_left = a; // 左值引用指向左值\n                int &&ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向\n                \n                cout << a; // 打印结果：5\n                $"],["总结","被声明出来的[左、右值引用]都是[左值]。 因为被声明出的左右值引用是[有地址的]，也位于[等号左边]","右值引用既可以是左值也可以是右值，如果[有名称]则为左值，否则是[右值]","作为[函数返回值]的$&&$是右值，[直接声明]出来的$&&$是左值"]]]]]},{tit:"面向对象",explain:[["类",[["基础概念","[@\\href{https://mp.weixin.qq.com/s/cPtL7o_tQWktLRWc8xrymg}{漫谈 C++：良好的编程习惯与编程要点}]"]]]]},{tit:"泛型",compare:[["字符串",["*.注意对串的赋值操作，首先[先释放]原空间。$free(str)$",["定义","[定长]顺序存储表示的结构体","$\n              typedef struct\n              {\n                char str[maxSize];\n                int length;\n              } Str;\n            $","[变长]分配存储表示","$\n            typedef struct\n            {\n              char * ch; // 指向动态分配存储区首地址的字符指针\n              int length;\n            } Str;\n            $",["标准库类型$string$：表示可变长的字符序列","$\n              #include <string>;\n              string s1 = \"12321\";\n              string s4(5, 'c'); // ccccc\n\n              // string 类型的可以用使用 以空字符结尾的字符数组来代替，反之不行\n              char char_s = {'a','b','c','\\0'}; // 注意以空字符结尾\n              string str = char_s;\n              // string 通过成员函数 c_str 转为 char 字符数组\n              const char *charStr = str.c_str();\n            $"]]]]]},{tit:"第三方库使用",explain:[["",[]]]}]}};var ci={basic:{top:[["考点","***冯·诺依曼计算机的[基本特点]与[指令执行过程]","**计算机的各种[性能指标]"],["题型","寻址范围的两种题型"],["内容","计算机系统层次结构","计算机系统的工作原理","计算机性能指标"]],article:[{tit:"计算机系统概述",explain:[["五大部件",[["*.硬件的基本组成",si("consist",4,"80"),"计算机硬件主要由[控制器、存储器、运算器、输入设备和输出设备]组成，它们之间的关系如图"],{tit:"存储器",arr:[["存储器的基本结构",si("consist",5,"80"),"存储器分为[主存储器]〈简称主存，也称为内存储器)和[辅助存储器]〈简称辅存，也称为外存储磺)。","[CPU]能够[直接]访问的存储器是[主存储器]。主存储器是存放[程序]和[数据]的部件，是计算机实现[存储程序控制]的基础","辅助存储器是用于帮助主存储器记忆更多的信息，辅助存储器中的信息[必须调入主存]后，才能被[CPU]访问"],["存储器结构解释","[存储体]用于存放[二进制]信息。","地址寄存器[MAR]存放[访存地址]，经过[地址译码器]译码后[找到]所选的存储单元。","数据寄存器[MDR]用于[暂存]从主存中读或写的信息。 ","*.注意：地址寄存器[MAR]与数据寄存器[MDR]虽然是存储器的一部分,但是在现代计算机中存在于[CPU]中。"],["*有关[存储]的概念总结",si("consist",21,"70"),["*.如图为一个简单的挂三极管的存储器","每[一行]的[_线_]代表是[地址线的一个_状态_],一个地址线相当于二进制数的一位，有[^两个状态^]，例如两个地址线就可以代表4个数[00、01、10、11]，就是4个地址。这个图有两行，就是[2]个状态，只需要[一条]地址线","每[一列]的[_线_]代表是[数据线]，","当前图的地址选中第二条线，左端为[0:低电位]的行[不读]，只读为[1:高电位]的行","[一行]就是一个[存储单元]，代表的是存储字长，","每个交叉口[红点]就代表着[一位]二进制","红点[不挂]三极管就是代表直接与高电位相连，恒为[1]","红点[挂]三级管的就是被三极管控制，三极管[闭合]的就是红点与地线相连为低电位[0]，否则就是与最上面的高电位相连为[1]","则该图所读出的数据为[0101]"],"[存储元]: 也可称为存储元件和存储基元，用来存放[一位]二进制信息","[存储单元]: 由[若干个]地址码相同的存储元组成，能存放多位二进制信息。也就是一个[字节]，每个单元有一个[地址]，是一个整数编码，可以表示为二进制整数，程序中的变量和主存储器的存储单元相对应。","[存储体]: 许多[存储单元]可组成存储体（存储矩阵）","[存储字]: 存储单元中[二进制代码]的组合即为存储字，可代表数值、指令和地址等。","[MAR位数]: 存储单元的最大[个数],是用来表示可映射多少个地址的，不是表示地址的长度。",["[MDR位数]: 存储字长。","[存储字长]: 全部存储单元中二进制代码的[位数]就是存储字长","从[存储器]中取出的信息要先存放在[数据寄存器]，","因此数据寄存器的[位数]应该和一个存储单元的[大小]一致（如果小于存储单元，则放不下；如果大于存储单元，则浪费）","即数据寄存器的[位数]和存储[字长]要相等。"],"计算机的位数，即[机器字长]，也就是计算机一次能处理的二进制数的长度。要注意的是，[操作系统的位数],如32位的操作系统，是操作系统可寻址的位数，它与机器字长不同。一般情况下可通过[寄存器]的位数来判断机器字长。","数据字长：是[数据总线]一次能[并行]传送信息的位数，它可以不等于[MDR]的位数。",["存储字长","[存储体]由许多[存储单元]组成，每个[存储单元]又包含[若干]存储元件，每个[存储元件]能寄存[一位]二进制代码[0]或[1]","一个[存储单元]可存储[一串]二进制代码，称这串二进制代码为一个[存储字]，称这串二进制代码的[位数]为存储字长。"],"[字地址]: 按[字节]编址时，一个[字]可能[占用]几个[存储单元]，字地址就是这[几个连续]存储单元地址中的[最小值]。比如字长为32位，现有地址为[0,1,2,3]的连续地址的4个字节，且这4个字节组成了一个字，则这个字的地址就是第一个字节的地址[0]",["字节、字、位","[位bit]: 表示二进制位。位是计算机内部[数据储存]的最小单位","[字节byte]: 习惯上用大写的[“B”]表示，字节是计算机中[数据处理]的基本单位。计算机中以[字节]为单位[存储]和[解释]信息，[@ 1Byte=8bit]。一个[存储单元]就是一个[字节]","[字]:计算机进行数据处理时，[一次]存取、加工和传送的数据长度称为[字word]。在计算机中，一串数码作为一个整体来处理或运算的，称为一个计算机字，简称“字”。计算机系统的字长有：8位、16位、32位、64位等。[一个]字可以包含[多个]字节.","[@1B = 8 bit\\quad 1KB=1024B\\quad 1MB=1024KB=1024\\times 1024B \\\\ 1GB=1024MB=2^{30}B]"],["*主存储器","主存储器由许多[存储单元]组成，每个存储单元包括多个[存储元]，每个存储元存储一位[二进制代码]“0”或“1”。","故而[存储单元]可存储[一串]二进制代码，称这串代码为[存储字]。这串代码的[位数]称为[存储字长]","存储字长一般为[一个]字节[8 bit]或字节的[偶数倍]","许多[存储单元]共同构成了一个[存储体]"],si("consist",93,"76")]]},["运算器",["定义","运算器包括若干[通用寄存器]，用于暂存操作数和中间结果","如累加器(ACC)、乘商寄存器〈MQ)、操作数寄存器〈(X)、变址寄存器〈IX)、基址寄存器〈BR)等，其中前三个寄存器是必须有的。另外还有程序状态字寄存器(PSW7，用来保留各类运算指令或测试指令结果的各类[状态信息]以表征系统运行状态。"],["考研大纲基本上没有涉及逻辑运算，讨论的都是[算术运算]","计算机需要[逻辑运算、算数运算、存储功能]","逻辑运算：用数数字来代表具体的状态，比如0：灯灭，1：灯亮","逻辑运算：与或非"],["寄存器","累加器(ACC)","乘商寄存器(MQ)","操作数寄存器(X)","变址寄存器(IX)","基址寄存器(BR)","程序状态字寄存器(PSW)","程序计数器(PC)","指令寄存器(IR)"]],["控制器",["功能结构","使计算机各个部件自动协调工作。计算机中有两种信息在流动:一种是[控制信息]另一种是[数据信息]","控制器由程序计数器[PC]、指令寄存器[IR]和控制单元[CU]组成。","[PC]用来存放当前[预执行]指令的地址，可以自动[+1]形成下一条指令的地址，它与主存的MAR之间有一条下接通路。","[IR]用来存放当前的[指令]，其内容来自主存的[MDR]。指令中的操作码字段[OP]送至[CU]，用以[分析]指令并发出各种[微操作命令序列]","指令中的地址码字段[Ad〈IR)]送往[MAR]来取操作数。"],["可能疑问点:计算机如何判断取出的[是数据]还[是指令]?因为数据和指令需要过往不同的地方?",["通常[完成]一条指令可分为[取指]阶段和[执行]阶段。","在取指阶段，通过[访问]存储器可将[指令取出]","在执行阶段，通过[访问]存储器可以将[操作数取出]。","这样，虽然指令和数据都是以二进制代码形式存放在存储器中,但[CPU]可以判断在[取指阶段]访问存储器取出的二进制代码是[指令]，而在[执行阶段]访问存储器取出的二进制代码是[数据]。"],["[指令寄存器]的操作码送入[操作码译码器]进行译码","然后[时钟和节拍脉冲发生器]合作产生一个[时序控制信号]","并且和[操作码译码器]的结果一起送入[微操作控制器]。","很明显，每次都是把[一个操作+一个时间]送入微操作控制器，说明秩序非常好。"],["[指令的地址码]需要送入[地址形成部件]。","若是[转移地址]，则送入[PC]","若是[操作数地址]，则送入存储器的[地址译码器去]取操作数","取出的操作数先放在数据寄存器，然后送往运算器进行运算。"],"每读取一条指令，[PC]的内容自动[加1]","重复前4个步骤，直至打印出结果，最后执行[停机指令]，机器便自动停机。"]],["输入设备","输入设备是将人们所熟悉的信息形式转换成[计算机]可以接收并识别的信息形式的设备","如键盘，当按下一个键时，此键被翻译成[ASCII]码传输给计算机，而[ASCII]码就是计算机可以接收并识别的信息形式。"],["输出设备","输出设备可将[二进制信息]转换成人类或其他设备可以接收或识别的信息，如显示器。"],["*.五大部件之间的关系",si("consist",6),"通过与[控制器]之间的[信号请求]，输入设备[首先]输入信息给[存储器]","*.这里的信息一定是包含[数据和程序两者](如果只包含数据，则不知道如何操作;若只包含程序，则计算机不知道对谁操作，所以两者缺一不可)。","[控制器]调用相应的指令来[运行程序]，然后发出相应的[操作命令]给运算器(如果需要使用运算器)，控制器给出[操作数]的地址，使用该地址从存储器调用[操作数]给运算器进行运算。","运算结果返回给存储器，若需要打印，则通过输出设备与控制器之间的信号请求，打印结果"]]],["基础",[si("consist",3,"",!0),["发展",["硬件发展","从第一代到第四代，计算机的体系结构都是相同的","即都计算机硬件主要由[控制器、存储器、运算器、输入设备和输出设备]组成，称为[冯.诺依曼体系结构]。","其中，运算器+控制器=[CPU]， CPU+主存储器=[主机]， I/O设备又称为[外部设备]。",["计算机按照指令和数据流可以分为分类","[单指令流单数据流（SISD）]，即传统的冯·诺依曼体系结构。","[单指令流多数据流（SIMD）]，包括阵列处理器和向量处理器系统。","[多指令流单数据流（MISD）]，这种计算机实际上不存在。","[多指令流多数据流（MIMD）]，包括多处理器和多计算机系统。"],["硬件的更新换代","摩尔定律。","半导体存储器的发展。","微处理器的发展。"]],["软件发展","*计算机软件（Software，也称软件）是指计算机系统中的[程序]及其[文档]","计算机语言的发展主要从面向机器的[机器语言和汇编语言]，到面向问题的[高级语言]过渡。","系统软件：又称为系统程序，主要用来管理整个计算机系统,使[系统资源]得到合理的调度，高效运行，例如操作系统、编译程序、文件系统等都是系统软件。","应用软件：又称为应用程序，它是用户根据任务需要所编写的各种程序，如QQ、Word等都是应用软件","机器语言：用二进制代码[0]或[1]描述不同的指令，编程人员需要记忆每一条指令的二进制编码。机器语言的优点是计算机可以直接识别和执行。","汇编语言：实质和机器语言是相同的，都是[直接]对硬件操作，只不过指令采用了英文缩与的标识待，更容易识别和记忆。汇编语言的程序必须经过一个称为[汇编程序]的系统软件翻详，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。","高级语言(如C、C++、Java等)：需要经过[编译程序]编译成汇编语言程序，然后经过汇编程序得到机器语言程序，或者直接由高级语言程序翻译成机器语言程序。高级语言的优点十方便编程人员写出解决问题的处理方案和解题过程。"]],["计算机的工作过程","不断地从[存储器]取出指令，然后送至[控制器]，经分析后由[CPU]发出各种操作命令，指挥各部件完成各种操作，直至程序中[全部指令]执行结束。",["[存储程序]工作方式","基本思想是: 将事先编制好的程序和原始数据送入主存后才能执行","一旦程序被启动执行，就无须操作人员的干预，计算机会自动[逐条]执行指令，直至程序执行结束。",si("consist",35,"50",!0)]],["计算机系统的层次结构","*.它通常由[5]个不同的层次组成，在每一层上都能够进行程序设计","第1级 微程序机器级。微指令由硬件直接执行","第2级 传统机器级〈机器语言)。它用微程序解释机器指令系统。","第3级 操作系统级。用机器语言程序解释作业控制语句。","第4级 汇编语言机器级。用汇编程序翻译成机器语言程序。","第5级 高级语言机器级。有或直接翻译成机器语言。",si("consist",23,"",!0)],{tit:"计算机性能指标",arr:[["吞吐量","吞吐量是指信息流入、处理和流出系统的速率。","它取决于CPU能够多快地[取指令]，数据能够多快地从内存取出或存入，以及所得结果能够多快地从内存送到输出设备。","这些决定因素中的任一步骤都与[主存]紧密相关，因此吞吐量主要取决于主存的存取周期。"],["响应时间","响应时间是指从[提交]作业到该作业得到[CPU响应]所经历的时间","响应时间越短，吞吐量越大"],["主频","主频是指机器内部[主时钟]的频率，是衡量机器速度的重要参数，其常用单位为[Hz、MHz]等。","如果主频为[8MHz],则可以计算出时钟周期为[@\\dfrac{1}{8}\\times 10^{-6}s=0.125\\mu s](即每秒有[8M]个时钟周期)。"],["CPU周期","CPU周期又称为机器周期，通常用从内存读取[一条]指令字的最短时间来定义。","一个指令周期常由[若干]个CPU周期构成。"],["CPU时钟周期","主频的倒数，是CPU中最小的时间单位。"],["CPI、MIPS和FLOPS(三者为衡量运算速度的指标)","[CPI]-ClockCyclePerInstmuction: 执行[一条]指令所需要的[时钟周期]数。","[MIPS]-MillionInstructionsPerSecond): [每秒]可执行[百万]条指令数，如某机器每秒可以执行800万条指令，则记作[8MIPS]","[FLOPS]-Floating-pointOperationsPerSecond: 每秒执行的[浮点]运算次数。","MFLOPS〈MillionFloating-pointOperationsPerSecond): 每秒[百万]次浮点运算，与MIPS类似。","[GFLOPS]-GiligaFloating-pointOperationsPerSecond): 每秒十亿次浮点运算。","[TFLOPS]-TeraFloating-pointOperationsPerSecond): 每秒万亿次浮点运算。","[PFLOPS]-PetaFloating-pointOperationsPerSecond): 每秒千万亿次浮点运算。","补充:[IPC]-InstructionsPerClockCycle): CPU的每一个时钟周期内所执行的指令数。"],["CPU执行时间","CPU执行时间指CPU对某特定程序的执行时间","例如，对于程序A和程序B，CPU执行程序A和程序B分别使用了2s和4s,，则对于程序A和程序B而言，CPU执行时间分别是2s和4s。"]]}]]],compare:[["题型",[{tit:"寻址范围的概念和数据寄存器的位数",arr:[["直接给出存储器的[容量]和[字长]，然后[按字节、半字、字、双字]寻址。","例如[地址线]20根，[数据线]16根，按[字节]寻址为什么是[1MB]，而不是[2MB]？按[字]寻址为什么是[512KB]，而不是1MB？","提问如后者的考生思维方式基本都是在算寻址范围时马上将数据线的位数算进去。其实按字节寻址时和数据线没有任何关系（仅当按字寻址时才考虑数据线，通过数据线来判断字长），只和[地址线]有关。","寻址范围的概念怎么理解？","按[字节]寻址的[寻址范围],就是说按直接来算，一共有多少个字节，就是在总的容量下，把字节当作单位，一共有多少个。","所以说寻址范围的单位一定不含[B]和[bit]等，因为在计算的时候约掉了。而且表示的是[数量]"],["[不给]出存储器的容量，只给出[地址线]和[数据线]的位数。","假设[CPU]有[20]根地址线和[32]根数据线，试问按字节和字寻址，寻址范围分别是多少?","解答这类题目时首先要清楚[地址线]的位数对应的都是按[字节]寻址，如果是[按字]寻址，则需要拿出[地址线]来做[字内]字节寻址",si("consist",22,16),"假设现在按[字节]寻址,[20]根地址线的寻址范围应该是[@2^{20}=1MB]，然后因为是[按字节]寻址，所以每个[寻址单元]已经是[最小的]，[不需]要字内寻址。",["如果是[按字]寻址","那么还有没有[20]位的[地址线]来寻址?[没有]，因为每个字有[4个]字节。这4个字节的区分，如图所示","字号为0的字里面有0号、1号、2号、3号共4个字节，只能从[20]根地址线里拿出[两根]来作为[字内寻址]。","两根地址线的信号分别为[00、01、10、11]，分别代表字内的0号、1号、2号、3号字节。这样，[只剩18根地址线]来寻址，按字寻址的寻址范围是[@2^{18}=256K]"]]]}]]],note:[["软硬件在[逻辑上]是[等效]的","[解释] 对于某一功能来说，既可以用[硬件]实现也可以用[软件]实现，则称为软硬件在逻辑上是[等效]的。","一般来说，用硬件实现的[效率更高]，但是成本远高于软件；使用软件可以[提高灵活性]，但是效率远不如硬件。"],["解释程序与编译程序","[解释程序]是高级语言翻译程序的一种，它将源语言书写的源程序作为输入，[解释]一句就提交给计算机[执行]一句，并[不形成]目标程序。","[编译程序]把高级语言源程序作为输入，进行翻译转换，产生出机器语言的目标程序，然后让计算机去执行这个目标程序，得到计算结果。",si("consist",34,35),"编译编程序与解释程序最大的区别在于:前者生成目标代码，而后者不生成。此外，编译程序产生目标代码的[执行速度]比解释程序的执行速度快(遇过到循环程序，解释序要不断的重复解释，而编译程序只需执行一次即可)。"]]},{tit:"辅助知识",compare:[["专业知识",[{tit:"门电路",arr:["*.假：0 真：1, 图中[小圈]表示[取反]","与门——有假即假",si("consist",24,15),"或门——有真即真",si("consist",25,15),"非门——取反运算, 输入[1]，输出[0]",si("consist",26,15),"或非门——和或门一样，只是将结果[取反]",si("consist",27,15),"与非门——和与门一样，只是将结果[取反]",si("consist",28,15),"异或门——输出电平相同为[0],如[@(1,1)、(0,0)\\rightarrow 0],不同为[1]",si("consist",29,15),["*三态门",si("consist",30,15),"逻辑门的输出端除有[高、低]电平两种状态外，还有第三种状态——[高阻态](电路图参考图)。","高阻态相当于[隔断状态](因为实际电路中不可能去[断开]它，所以设置这样一个状态，使它处于隔断状态)。","例如，内存中的一个存储单元，当读写控制线处于[低]电平时，存储单元被打开，可以[写入]数据,当处于[高]电平时，可以[读出]数据;","当[不读不写]时，就要用高阻态，就像把该存储单元隔离开来一样。","更直白的解释是;高阻态就是一个开关，当处于高阻态时，逻辑门什么也不能做。","说明:当[A]为[高]电平时，[@C\\rightarrow B]导通;当[A]为[低]电平时，[@C\\rightarrow B]不导通，此时为[高阻态]。"]]},{tit:"片选译码器",arr:["主要介绍最常用的[3-8译码器](或称[74138译码器]，属于存储器与[CPU]连接中的片选译码器)，其他译码器的〈如2-4译码器、4-16译码器)原理都相似",si("consist",31,"40"),si("consist",32),"先记住一句话，只要[头上有杠]的信号，不管是输入端还是输出端都应该加[小圈]，表示[低]电平有效。","由于[@\\overline{Y_i}]的[头上有杠]，因此输出端必须要加[小圈](若某个[@\\overline{Y_i}]被选中，则输出低电平，即[0]),遇到门电路时再用[小圈]恢复","[@G_1]端、[@\\overline{G_{2A}}]端、[@\\overline{G_{2B}}]端分别表示[高电平]有效、[低电平]有效、[低电平]有效，才能使[译码器]正常工作，其实只需要一个访存控制信号[@\\overline{MREQ}]就可以了",si("consist",33,"70"),si("consist",74,"70"),["使用规则","对于[两个]不同的[地址区域]，首先从高位开始找出连续的[3]位，能区别这两个地址","把这三位当作[CBA]，去表[1-8]去找对应输出的是[@\\overline{Y_i}]","地址里[1]是代表输出[高]电平，[0]代表输出[低]电平"]]}]],["专业名词",[["专业词","系列机: 是指一个厂家生产的具有相同系统结构、不同组成和实现的一系列不同型号的[机器]。它们应在[指令系统、数拓格式、字符编码、中断系统、控制方式、输入/输出控制方式]等方面保持统一，从而保证软件的兼容性。","阿姆代尔定律〈Amdahl'sLaw): 阿姆代和尔定律是指系统优化某部件所获得的系统性能的[改善程度]，取决于该部件被使用的频率，或占用总执行时间的比例。该定律很好地刻画了改善[系统瓶颈]性能的重要性。","基准测试程序：基准测试程序是专门用来进行[性能评价]的一组程序,这些程序能够很好地反映机器在运行实际负载时的性能。可以在不同机器上运行相同的[基准测试程序]来比较不同机器的运行时加，从而比较其性能。"],["有效位和有效字节","[最低有效位]：一个二进制数中的最[低]位，如二进制数[1110]中的[0]。","[最高有效位]: 一个二进制数中的最[高]位，如二进制数[0111]中的[0]。","[最低有效字节]:一个二进制数中的最[低]字节，如二进制数[0000 0000 1111 1111 1111 0000]中的[1111 0000]。","[最高有效字节]: 一个二进制数中的最[高]字节，如二进制数[1111 1111 0000 0000 1111 0000]中的[1111 1111]"],["基数","若进位计数制的[基数]为[R]，第[n]位数的权即为[@R^{n-1}]","则只要将各位数字与它的[权]相乘，并将其积[累加]，和数就是[十进制数]。","例如，二进制数的基数是[2],十进制数的基数为[10]，十六进制的基数为[16]"],["逻辑数据","逻辑数据用来表示命题的[真]和[假],分别用[1]和[0]来表示。","进行逻辑运算时，应按[位]进行。",["逻辑运算表达式","异或符号：[@A\\bigoplus B]","与符号:[@A\\cdot B]","或符号:[@ A+B]","非符号:[@\\overline{A}]","*.[@\\href{https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7%E8%A1%A8}{逻辑符号表}]"]],["与[字、字长]相关的那些名词","[@1B=8bit]，这个是规定，没有错误。","但是很多考生认为一个[字]等于[两个]字节，因为他们脑海中的固有概念：一个汉字占用两个字节。","但是计算机中的[字]和[汉字]中的字的概念并不一样。计算机中的[字]通常由[一个或多个]〈一般是字节的整数倍)字节构成。现在常用的都是32位(4个字节)字长的机器。","以前是[存储字长]等于[机器字长]，因为[机器字长]是机器一次能处理的[比特数]，这样一次取个等长的[存储字]便于机器处理。现在的[机器字长]一般[大于]存储字长。","[字长=机器字长=存储字长]"],["与[周期]相关的名词","指令周期: 从一条指令的[启动]到下一条指令启动所经历的时间，通常由多个[机器周期]组成","时钟周期(节拍周期):计算机主频周期，通常将一个时钟周期定义为一个节拍。时钟周期即[CPU]频率的[倒数]，是最基本的时间单位","总线周期: CPU通过总线对存储器或[I/O]端口进行一次[访问]所需要的时间",["机器周期(CPU周期)","在计算机中，为了便于管理，常把一条指令的执行过程[划分]为若干个阶段","每一个阶段完成一项工作，如取指令、存储器读、存储器写等，每一项工作称为一个基本操作。","完成一个基本操作所需的时间称为[机器周期]。一般情况下，一个机器周期由若干个[时钟周期]构成"],"微指令周期: [读出]微指令的时间加上[执行]该条微指令的时间。注意，微指令周期常取成和机器周期[相等]",["存储周期(存取周期)","需要和存取时间分开。存取时间又称为存储器的[访问时间]，指启动一次存储器操作(读或写)到[完成]该操作所需的全部时间,存取时间分为[读出]时间和[写入]时间两种","存取周期指存储器进行[连续两次]独立的存储器操作(要么连续两次[读]操作，要么连续两次[写]操作)所需的[最小]间隔时间，通常[存取周期]大于[存取时间]"]]]]],note:[["高电平和低电平","高电平表示电压高的状态,记为[1]，一般规定高电平为[3.5~5V]","低电平表示电压低的状态, 记为[0]，一般规定低电平为[0~0.25V]"],["高电平有效、低电平有效概念","低电平有效是针对某一[输入端口]而言的，简单的说：在芯片的某一端口加入[低电平0]后，可以使芯片的逻辑运算[功能启动]，就称这个端口是[低电平有效]。简而言之低电平有效，就是施加低电平的时候，对应[功能被触发]（有效）。","如果在这个端加的是[高电平1]，则该芯片是没有被启动，那么该芯片的其他引脚将不被使用，也就不能进行相应逻辑运算。这种情况下就称这个端口为[低电平有效]。"],["为什么一般推荐使用[低电平有效]","因为低电平时电路的[阻抗低]，噪声造成的[电平变化小]，也就是说，抗干扰能力更强。","换句话说：低电平有效时干扰把它变成高电平，比高电平有效时干扰把它变成低电平要困难。就是因为低电平阻抗低，所以说低电平有效抗干扰能力强。","在数字系统中，比较容易出现在低电平上叠加一个噪声正脉冲。如果采用高电平有效的方式，就可能在无效的低电平上，出现高电平噪声，从而使某个信号在不应当有效的时候，出现有效的高电平。所以在数字系统中，大多数信号的有效电平为低电平。"]]}]},num:{top:[["考点",""],["题型",""],["内容","数值的各种转换和运算","校验码的校验过程"]],article:[{tit:"数据的表示",compare:[["数据的表示",[["*定点小数",["进制转化","小数转二进制：[乘2取整，由上而下]"],"定点小数加减法","定点小数乘法","定点小数除法","溢出处理"],["常见的二进制数","[@ 2^8=128\\hspace{1em}2^{10}=1024\\hspace{1em}2^{20}=1048576 \\hspace{1em}2^{16}=65536]"],["机器数","[3]种机器数的最高位均为符号位。","当真值为正数时，[原码、补码和反码]的表示形式均相同","当真值为负数时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“每位求反加1”，反码是原码的“每位求反”。需要注意的是，上面所谓的“每位求反”[均不包括符号位]，只是对数值部分进行求反，且原码除了符号位为“1”，数值部分仍然与真值相同。"],["为什么计算机中会有补码呢？",["背景","计算中有了[加法]，为了节约成本，避免不必要的开销，用[加法代替减法]，如[@1-1=1+(-1)]","如此，计算机的硬件只需要支持加法即可。如果用加法来算减法，以[@1-1]为例： 用原码来计算[@0000 0001 +1000 0001 =1000 0010] 计算的结果[@1+(-1)=-2]","与实际不符，所以直接用[原码]计算肯定是不行的，因为[符号位]参与计算，且计算机又不会[区分]最高位为符号位。 所以用到了[补码]进行计算。为了理解补码，下面介绍几个数学上的概念"],["模","是指一个计量系统的[计数范围]。 如时钟的计量范围是[0~11]，[模=12]。","[模]是计量器产生[溢出]的量。它的值在计量器上表示不出来，计量器上只能表示出模的[余数]，如12的余数有[0,1,2,3,4,5,6,7,8,9,10,11]"],["补数","假设当前时针指向[11]点，而准确时间是[8]点，[调整]时间可有以下两种拨法","一种是[倒拨]3小时，即：[@11-3=8]","另一种是[顺拨]9小时：[11+9=12+8=8]（11+1筹够一个模，从头开始重新计数，计数到指定位置8）","在以模为[12]的系统中，[加9]和[减3]效果是一样的，因此凡是减3运算，都可以用加9来代替。 对[模12]而言，[9]和[3]互为[补数]（二者相加等于模）。"],["*.总结","所以我们可以得出一个结论，即在[有模]的计量系统中，减一个数等于加上它的补数，从而实现将减法运算转化为加法运算的目的。 即[@11-3=11+9=20]，因为模是[12]，所以[@11-3=11+9=20-12=8]","计算机中的运算，就是[取补码]进行[加运算]，运算[结果再取补码]，就是正确的值。 [反码]只是计算时用到的一个[临时数]，没有实际意义"]]]],["浮点数",[["*浮点数的表示","[@ N = M\\times r^E]","[M尾数]：用定点小数，[E阶码]:用补码或阶码表示",si("consist",17,30,!0)],["浮点数加减法","对阶","尾数求差（加上补数）","规格化:(左规和右规)","舍入处理：对于在右规和对阶的过程中，可能会导致最后一位[1]被舍去，所以尾数要加[1]","溢出判断"],["IEEE754 标准的浮点数（用移码表示阶码）","阶码需要加上[偏置值]","**对于用[移码]表示[阶码]的浮点数，[尾数]其实是可以[多表示一位]的，因为这一位是固定为[1]，所以不需要写出来"],["移码","补码不方便与原码比大小，所以用移码来表示","对于[n+1]位机器数，真值加上[@ 2^n],就是对应的移码，可以说移码就是[补码]的[符号位][取反]，所以对于移码的符号位，[1]是正，[0]是负","只能表示整数"]]]],note:[["关于定点小数和定点整数的[@-1]的补码表示","定点整数: 全[@1]，例如8位,[@\\bold{1}111 \\; 1111]","定点小数: 除符号位外全[@0], [@\\bold{1}.000\\;0000]"]]},{tit:"数据的运算",compare:[["定点数运算",[["运算采取哪个机器数？","在现在的计算机系统中，可以说[99%]都是采用补码运算，这个说明了什么?如果要研究运算方法和运算器，那么讨论的所有运算都应该以[补码]运算为主，但是也不是全部的计算机系统都采用补码，原码也有研究的必要,如[原码乘法]和[原码除法]","两[原码]表示的数[相加减]，首先要[考虑]它们的[符号]。若为[同号]，则数值部分相加，结果的符号取被加数或加数的符号；","若为[异号]，数值部分相减，结果的符号取绝对值大的数的符号。原码一般不用来进行加减运算，而多用来进行乘除运算","进行加减运算时，多用[补码]"],["注意","[符号位]进位[舍去]"]]],["浮点数运算",[]]]}]},memorizer:{top:[["考点","****有关[Cache]的所有知识点.重点掌握存储器的[设计]方法","**[虚拟存储器]的工作原理，可结合操作系统课程中的内存管理部分","双端口[RAM]和多模块存储器的工作原理"],["题型"],["基础要点","存储器系统的概念,包括基本结构、工作过程和存储系统的层次化结构。","各种类型存储器的工作原理，包括[SRAM]存储器、[DRAM]存储器和[ROM]存储器的特点。","存储器与[CPU]芯片的地址线连接、数据线连接、读/写命令线连接和片选信号线的连接，并根据给定的存储芯片设计满足要求的存储器系统。","双端口[RAM]和多模块存储器的工作原理。","Cache的工作原理、Cache和主存之间的各种回射方式以及Cache中主存块的蔡换算","虚拟存储器的工作原理。"]],article:[{tit:"存储器概念和结构",explain:[["结构",[["常采用多级存储器结构",si("consist",37,"80"),"寄存器：高速存储部件，它们可用来暂存指令、数据，通常是制作在CPU内。寄存器里的数直接在[CPU]内部参与运算，CPU内可以有十几或几十个寄存器。","层次结构主要体现在[缓存-主存]和[主存-辅存]这两个存储层次上。",si("consist",38,"80"),"显然[CPU]和缓存、主存都能直接交换信息;缓存能直接和CPU、主存交换信息","主存可以和CPU、缓存、辅存交换信息。","[Cache]和[主存]的内容都可以在下一层中找到","[缓存-主存]层次主要解决[CPU]和[主存速度]不匹配的问题。[主存]和[缓存]之间的数据交换是由[硬件]自动完成的，对程序员是透明的。","[主存-辅存]层次主要解决存储系统的[容量]问题。主存和辅存之间的数据交换是由[硬件]和[操作系统]共同完成的"],{tit:"主存",arr:[["概念","主存储器由[DRAM]实现，靠处理器的那一层[Cache]则由[SRAM]实现，它们都属于[易失性]存储器，只要电源被切断，原来保存的信息便会丢失。","[DRAM]的每位价格低于[SRAM]，速度也馒于[SRAM]，价格差异主要是因为制造[SRAM]需要更多的硅。[ROM]属于非易失性存储器。"],{tit:"半导体随机存取存储器",arr:[["半导体存储芯片的[基本结构]","半导体存储芯片主要由[存储矩阵]、[译码驱动电路]和[读/写电路]组成",si("consist",39,"80",!0),"地址线是单向的，数据线是双向的，剩下的属于控制线，控制线有[读/写]控制线和片选线两种","读写控制线用来进行读写操作，片选线用来选择存储芯片。由于一般半导体都是由很多的芯片组成的，因此需要用片选信号来选择要读或写哪一个芯片。"],["半导体存储芯片的[译码驱动]方式","现在仍然有一个问题没有解决,就是地址线送来的[地址信号]怎么转换成对应存储单元的选择信号","译码驱动的方式有：[线选法]和[重合法]",["[线选法]:单译码",si("consist",40,"80",!0),"首先假设该矩阵有[N]行,然后就可以通过公式[@⌈\\log_2N⌉]算出地址线所需要的根数","如图矩阵有[16]行，需要[4]根地址线[@A_0、A_1、A_2、A_3],值[@0000，0001，0010，1111]共[16]个数，分别代表矩阵的16行","由于图中[@A_0、A_1、A_2、A_3]的值都为[0]，因此选中了第[0]行","选中之后再由[读/写]控制电路进行读写操作即可","另外，由每行有8位，因此需要8根[数据线]"],["[重合法]:双译码",si("consist",41,"80",!0),"线选法是选中矩阵的一行(在计算机中称为选中一个[字])，而重合法比线选法更细，它可以选中矩阵的某一个元素(在计算机中称为选中一位)。","如图所示，存储和矩阵可以看成是[@32 \\times 32]的和矩阵。由线性代数可知，要想在矩阵上定位一个元素，需要[行列]的坐标，故此时不但需要行地址线，还需要列地址线。","[32]行里选中一行需要[5]根地址线，[32]列里选中一列也需[5]根地址线","图中10根地址线全为0，就选中了和矩阵的[(0，0)]"]]]}]}]],["概念",[["基础知识",si("consist",36,"80",!0),"*.一个完整的存储系统应该包括[主存储器]、[高速缓冲存储器]、[Cache]和[辅助存储器]"],["按[存取方式]分类",["随机存取存储器[RAM]","在随机存取存储器中，存取信息，存取时间和存储位置没有关系。其优点是读写方便，使用灵活，缺点是[断电]信息丢失。","[RAM]分为静态[RAM(SRAM)]和动态[RAM(DRAM)],[静态RAM]常用作[高速]缓冲存储器,动态RAM常用作[主存]。","[随机存取]是表示可以[随时随地——直接]访问存储器的[任意单元地址]，就好像[数组]可以通过下标直接访问需要的元素，而[链表]就需要一个个地找过去，因此数组是随机存取，而链表不是随机存取。"],["只读存储器[ROM]","只读存储器的内容只能[随机读出]而不能写入，并且其内容[断电]之后仍可保留，所以一般把一些固定的、不变的程序存放在这里。","只读存储器[ROM]与随机存取存储器[RAM]一起构成了[主存]。","只读存储器主要包括掩膜型只读存储器[MROM]、可编程只读存储器[PROM]、可擦除可编程只读仔储器[EPROM]、电可擦除可编程只读存储器[EEPROM]和快擦除读写存储器[FlashMemory]","[ROM]的存取方式和[RAM]是一样的，都是通过[对地址进行译码],[选择]某个单元进行读写。所以，两者采用的都是[随机]存取方式。不同的是，[ROM]是[只读的]，[RAM]是可读可写的","[ROM]是只读存储器,是一种只能读出事先[所存]数据的固态半导体存储器。其特性是一旦存储资料就[无法]再将之改变或删除。通常用在不需经常变更资料的计算机系统中，其所存储资料并不会因为电源的关团而消失。"],["串行访问存储器","对存储单元进行[读/写]操作时，需要按照[物理位置]的[先后顺序]依次访问","主要包括[顺序]存取存储器〈磁带)和[直接]存取存储器《磁盘)。","磁盘是属于[半串行]的，因为在磁盘寻找数据时，先要寻道，这个寻道是直接找磁道的，不需要顺序寻找，所以寻道属于随机访问，寻道之后需要在磁道旋转，顺序寻找需要的信息，因此又是串行访问。将这种前段是直接访问、后段是串行访问的存储器称为直接存取存储器。"]],["[Flash 存储器]","闪存是[Flash]存储器的一个别称。闪存虽然属于内存的一种，但是又不同于内存。","众所周知，如果[没有]电流供应，则计算机内存的内容即刻消失。而闪存在没有电流供应的条件下也能够长久地保持数据，其存储特性[相当于]硬盘，这项特性正是闪存得以成为各类便携型数字设备的存储介质的基础，","简单来说就是，闪存集合了[ROM]和了[RAM]的长处。一般来讲，Flash存储器都是[按块]来读取数据的，而不是[字节]。"],["性能指标","存储器主要有三个性能指标:[存储容量、单位成本和存储速度]。","一般来说，速度越高，价格就越高，容量越大，价格就越低，且容量越大，速度必定越低，而理想的存储器应该是[大容量、高速度、低价格]。",["相关计算","[存储容量=存储字数x字长]。<br>存储字数表示存储器的[地址空间]大小,即存储器的存储[单元数目]，[字长]即存储字长，表示一次存取操作的数据量。","单位成本: 每位价格=总成本/总容量。","存储速度: [数据传输率=数据的宽度/存储周期]。<br>存储周期又称为读写周期或访问周期，指连续两次独立地访问存储器操作之间所需的最小时间间隔。","注意: 有些题目中出现存取时间的概念，存取时间是指启动一次存储器操作到完成该操作所经历的时间，一般小于存取周期。"]]]]],compare:[["[DRAM]存储器",["*.[动态]随机存储器需要[每隔]一段时间[刷新]一次。",{tit:"工作原理",arr:[si("consist",46,"80"),["保持存储信息","常见的[DRAM]的基本存储电路可以分为[多管型]和[单管型],它们的共同特点就是[遵循电容存储电荷]的原理","电容上有电荷表示存[1],电容上无电荷表示存[0]。由于电容上的电和从基本只能维持[1~2ms]，因此即使电源不掉电，和信息也会自动动消失","因此，在电荷消失之前必须对其[恢复],该过程被称为[刷新或再生](后面将会讲解[3种]刷新方式)","考研主要考查单管型，如图所示。由于[@Z]线初始状态为[低]电平，因此[T]为低电平，即[T]截止。存储信息和[读/写线路]隔离了，即信息[保持]了。"],["读数据","仍然[先送]地址，此时[@Z]线为[高]电平，[@T]导通","怎么判断读出的是[0]还是[1]?","如果存储的是[1]信号，则表示电容有电荷，有电荷应该会产生电流。因此，如果[@W]有电流读出，则说明读出的是[1]信号","如果[没有]电流，则说明读出的是[0]信号。"],["写数据","假设此时存储信号[0]生机与入[1]上，如图所示。","首先[送地址]，[@Z]线为[高]电平，[@T]导通，然后[送]数据。那么[@W]应该是[高]电平写[1]，还是[低]电平写[1]?","那就只能用代入法试试试了。假设传送数据给[@W]之后，[@W]为[高]电平，说明[A]点就是[高]电平，而此时[@C]存储信号[0]，也就是没有电荷，[A]点和[C]形成电势差，即可以给[C]充电，有电[C]就存储了[1]。因此，当存储信号[0]时，[@W]为[高]电平写[1],[@W]为[低]电平写[0]","扩展一下:如果此时存储信号[1]，则需要写入[1],情况又是怎样呢？如果此时存储信号[1]，[@W]为高电平，则说明[A]和[C]没有电势差，此时写[1];如果[@W]为[低]电平，则[C]就要放电，此时写[0]。因此,[@W]为高电平写[1],[@W]为低电平写[0],和上一种情况一致"]]},{tit:"刷新",arr:[["[DRAM]存储信息的原理","采用[电容式]存储，电容中[充满了]电荷和电容中没有电荷正好对应了两种状态:[1]和[0]","根据电路基本知识可知，电容中存储的电荷不能永久保留，随着时间的流逝会消失，这个时间是多长呢?","考研中只要不特殊说明，默认为[2ms]（即每个基本[存储单元]在每2ms内必须要刷新一次，否则就会使电荷[流失]，进而导致存储信息[出错])"],["通常有[3]种刷新方式:[集中]刷新、[分散]刷新和[异步]刷新。","集中刷新。把刷新操作[集中]到一段时间内集中进行〈集中[歼灭])。","分散刷新。将刷新操作分散进行，[周期性]地进行（分散[歼灭]）。","异步刷新。是一个[折中]方案，既不会像集中刷新那么[大费]周章，产生集中的固定时间，也不会像分散刷新那么[频繁]地刷新，而是[有计划]地刷新，时间分配十分合理。","*.注意:由于存储体是矩阵形式，因此每次刷新都是对[行]进行刷新。","刷新的[实质]就是[读出]后再按原样[写入]（不要误以为仅仅是读操作)。考研题目中如果不特殊说明，则[刷新一行]的时间[等于]一个存储周期。根据上面的讲解可知，此处的[存储周期]就是读周期或者写周期。上面不是说刷新的实质是先读出后再按原样写吗?那应该是[读周期+写周期=两倍存储周期]才对。那刷新一行到底是等于存储周期还是两倍的存储周期？这里给出统一的结论:只要题干没有特别说明刷新的具体细节，，刷新一行所需的时间就是一个存储周期","如果题目本意就说明了刷新操作由读操作和写操作一起执行?，那么刷新一行的时间按照两倍的存储周期计算。"],["集中刷新","一般来说[电容]上的电荷基本只能维持[2ms],在2ms内必须要刷新一次。将2ms(2000us)看成一个刷新周期。","假设存储周期为[0.5us]，那么在一个刷新周期里有4000个存储周期。假设该存储矩阵有[32]行，则对[32行]集中刷新需要[16us]","如图3-12所示。刷新的时候是不能进行[读/写]操作的，故称刷新这段时间为[死时间]，又称为访存[死区]。可以计算出死区的占用比例为[@32/4000=0.8%],称为[死时间率]",si("consist",49,"80")],["分散刷新","在分散刷新中，存储周期已经[不再是]传统的存储周期了。也就是说，此时存储周期不再等于读(写)周期，而这里扩展了操作的定义","即[存储周期=读或写周期+刷新一行的时间]","从这个公式可以看出，此时存储周期为[读或写]周期的两倍。此处[刷新一行]的时间又看成是等于存储周期的。如图[3-13]所示，[@t_C]为变异的存储周期，[@t_M]为普通的读写周期,[@t_R]为刷新一行所需的时间。","从[图3-13]中可看出，每[128]个存储周期就可刷新一遍。另外，分散刷新将存储器的存储周期人为地[延长了]，因此严重降低了系统的速度。分散刷新的[死时间]降低到[0]，是否真的降低到了0?具体讲解可参考本节最后的知识点补充。",si("consist",50,"80")],["异步刷新","异步刷新是把存储矩阵的每行分散到[2ms]时间内刷新，但不是集中刷新，而是平均地分配。这就能保证当刷新完第一行后，再过[2ms]又可完成对第一行的下一次刷新。这样就不会像分散刷新那样每个存储周期都刷新某一行。如图[3-14]所示，对于[@128\\times 128]的存储芯片，如果要在2ms内刷新一遍，即每隔[@15.6us(2000hs/128\\approx 15.6us)]刷新一行，而每行刷新的时间仍然等于一个[读/写周期],异步刷新的[死时间]为一个[读/写]周期",si("consist",51,"80")],["*.刷新是一个一个芯片[按顺序]完成的吗?[刷新]和[再生]是一回事吗？","不是，刷新按行进行。每一行中的[记忆单元]同时被刷新，仅需要[行地址]，不需要列地址。刷新行号由[DEAM]芯片的[刷新控制电路]中的刷新计数器产生，整个存储器中[所有]芯片的相同行同时进行刷新。所以不是一个一个芯片按顺序进行的，而是单个芯片的所有行按顺序定时一行一行进行的。","刷新和再生[不是]一回事。对某个单元的刷新和再生的操作过程是一样的，即读后恢复，但再生操作是[随机的]，只对[所读单元]进行，而刷新操作是[按顺序]定时一行一行进行的。"]]}]],["[SRAM]存储器",[{tit:"工作原理",arr:[["保持存储信息",si("consist",42,"80",!0),"[SRAM]主要使用六管静态[MOS]存储单元电路，利用触发器来保存信息","规定：[@T_1]通、[@T_2]止，存[0]；[@T_1]止、[@T_2]通，存[1]",`符号${si("consist",43,3)}为初始为[高电平]，加了信导就变成[低]电平`,`符号${si("consist",44,3)}表示初始为[低电平]，加了信号就变成[高]电平。`,"[@\\overline{W}]线用作读[0]或写[0]，即当要读[0]或写[0]时，[@\\overline{W}]是高电平。[@W]线用作读[1]写[1],即当要读[1]写[1]时，[W]线是[低电平]。","[@Z]表示[字线]，连接的是[地址线]，[@\\overline{W}]和[@W]表示[位线],连接的是[数据线]","另外,[@T_1\\backsim T_6]为[MOS]管，如果为[高]电平，[MOS]管就[连通];如果为[低]电平，[MOS]管就[截止]",["*只要不访问存储单元,信息就可以一直保持下去.不访问是什么意思?",`符号${si("consist",44,3)}表示初始为[低]电平，不访问就肯定[不会]改变低电平的性质`,"这样，[@T_5]和[@T_6]就是[低]电平，即[@T_5]和[@T_6]截止了。这样[@\\overline{W}]和[@W]就完全和记忆单元[隔离]了，即[高阻状态]（[三态门]的有关知识可参考辅助知识点2）","既然[读/写]线都被隔离了,那么信息就肯定不会改变了，也就保持住了。"]],["读数据",si("consist",45,"80",!0),"读数据只要[送地址]并且发[读命令]就可以了，以读[0]信和号为例","如图所示,首先[送地址]，些时[@Z]线变成[高]电平，这样[@T_5]和[@T_6]就[导通]了，[@\\overline{W}]和[@W]就和[记忆单元]连起来了。","由于此记忆单元存储的是信号[0]，根据[@T_1]通、[@T_2]止，存[0]，此时[@T_1]是通的，[@T_2]是截止的。","由于[@T_1]是导通的，且[@T_1]一端接地，[@\\overline{W}]为高电平，因此[@\\overline{W}]就和地产生了[电势差](物理知识)，有电势差就有电流通过，于是产生[读]电流，读数据成功。"],["写数据","写数据朋定要分为两部分:一部分是[写在哪里]，另一部分是[写什么]","此时，不但需要传输[地址信号]，还需要传输[数据信号]","以写[1]信号为例，首先传送地址，[@Z]线变成[高]电平，此时，[@T_5]和[@T_6]就导通了，[@W]是读[1]写[1]线，应该将待写数据[1]送到[@W]线，[@W]线就变成[低]电平。由于[@T_6]是导通的，因此[B]点就为[低]电平，[B]点低电平使得[@T_1]低电平，使[@T_1]截止","由于[@\\overline{W}]没有数据送入，因此一直是[高]电平。[@\\overline{W}]是高电平，且[@T_5]导通，就使得[A]点是高电平，[A]点高电平就使得[@T_2]高电平，使[@T_2]导通。[@T_1]止、[@T_2]通，就将[1]存进去了。","[SRAM]的[时序]电路图不太重要，然而需要从中了解一些内容，即[读周期]和[读时间]之间的关系和具体内容可参考[DRAM]存储器。"]]}]]],note:[{tit:"读/写周期、读/写时间、存储周期和存储时间之间的关系总结",arr:[`${si("consist",47,"45")} ${si("consist",48,"45")}`,"[读周期]：是指对芯片[两次连续读操作]的[最小时间间隔](对应图3-10中的[@t_{RC}])，[读时间]：表示进行一次存储器[读操作]的时间(对应图3-10中的[@t_A]），显然读时间[小于]读周期。","[写周期]：是指对芯片[两次连续写操作]的[最小时间间隔](对应图3-11中的[@t_{WC}])，[写时间]：表示进行一次存储器写操作的时间(对应图3-11中的[@t_W]），显然写时间[小于]写周期。","存储器[带宽]是指单位时间内从存储器[读出或写入]存储器的最大[信息量]",["讲解","众所周知，计算机的[时序控制]是十分严格的，不能出一点差错，那么可以看到，图[3-10]中[@t_A]这段时间完成以后，实际上[有效数据]已经输出到了数据线上，需要这些数据的部件可以得到数据了，那么[读操作]是不是就该立刻结束呢?","不行，读操作[远没有]结束，因为根据实际各种因素的需要，这些数据信号要在线路上停留一段时间，即[@t_{OTD}]。地址线上的地址[失效时刻]才是读周期真正完成它使命的时刻，换句话说，就是地址信号在，读周期在，地址信号亡，读周期亡。综上所述，读时间[@t_A]应当小于读周期[@t_{RC}]","有了上面的描述，相信大家已经了解[读时间]和[读周期]之间的关系了，其实[写周期]和[写时间]之间的关系也是一样的，和虽然[时序]上不同，但是道理是一样的。[存储周期]和[存储时间]就更好理解了,[读/写]周期都是存储周期,而存储时间可以是[读时间]，也可以是[写时间]"]]},{tit:"对[死时间]的概念总结",arr:["集中刷新：[死时间]很好求解，就算那段集中刷新的时间","分散刷新：从[图3-13]中可以看出，刷新占据了时间，而且刷新时太不能进行读写操作，那不就是[死时间]吗。但是有些教材上说[分散刷新]没有死时间，这是怎么回事？下面根据做题的经验，给[死时间]下定义，即[死时间]是存储周期外的不能进行[读写]操作的刷新时间，而且这段[死时间]要连续不能累积。因此，对于分散刷新来说，由于刷新时间被存储周期包含了，它在内，而不在外，因此[死时间]不存在。","异步刷新：由于[死时间]不是累加的，因此异步刷新的死时间就算一个[读/写]周期，或者是没有[变异]的存储周期。","*.缩短死时间的方式有很多种，如在[CPU]指令译码结点进行刷新"]}]},{tit:"主存储器与CPU的连接",compare:[["存储器容量的扩充",[["存储器容量扩充的概念","由于[单片]存储芯片的容量总是有限的，不可能满足实际的需要，因此必须将[若干]存储芯片连接在一起才能组成足够容量的存储器，称为存储器容量的扩充。","存储器容量的扩充通常有[3]类:[位扩充、字扩充和字位扩充]。","介绍存储器容量的扩充之前，先补充一个求芯片数量的公式，如下:如果要求将容量为[@a\\times b]的芯片组成容量为[@c\\times d]的芯片，假设需要芯片的数量为[n]，则[@n=\\dfrac{c\\times d}{a\\times b}](该公式就是整个存储器的容量除以单个芯片的容量","[axb]中[a]是[字]线，连接的是地址线；[b]是位线，连接的是[数据线]"],["[位]扩充——增加[axb]后面的[b]","[位扩充]指增加[存储字长]，例如，现要将[1Kx4]位的芯片组成[1Kx8]位的存储器，整个过程应该如何?假设以上都是[RAM芯片]","第一步，需要几片芯片?[@\\dfrac{2k \\times 8}{1k \\times 8} = 2]","第二步，需要多少根[地址线]?由于了[axb]中[a]是字线，且连接的是地址线，因此[地址线的数量]只和[a]有关。由于[@2^{10}=1K]因此需要[10]根地址线","第三步，需要多少根数据线?由于需要组成[1Kx8]位的存储器，[8]代表了数据线的位数，故需要[8]根数据线，每片芯片占用[4]根线。","以上[3步]了解之后，现在就需要知道这些[线和芯片]应该怎么连接了，如图[3-15]所示。首先，[@\\overline{CS}]为[片选]信号线(有些教材中片选信号线为[@\\overline{CE}]，[@\\overline{WE}]为[读/写]信号线(有些教材中读/写信号线为[@\\overline{WE}/\\overline{OE}])，并且两者都是[低电平]有效(至于高电平写还是低电平写，题目一定会说清楚)。","另外，由于存储器的容量是[1Kx8]位，故每次应该取出[8位]，从图[3-15]中可以看出，第一片提供高4位，因为连接在[@D_7\\backsim D_4]，第二片提供低[4]位，因为连接在[@D_3\\backsim D_0]",si("consist",52,"80")],["字扩充——增加[axb]前面的[a]","[字扩充]是增加[存储单元]的个数，例如，现要将[1Kx8]位的芯片组成[2Kx8]位的存储器，整个过程如何,假设以上都是[RAM]芯片)?","*.注意，考生应当在看完字扩充后自己总绝出规律，即位扩充和字扩充的不同之处。","第一步，需要几片芯片?[@\\dfrac{2k \\times 8}{1k \\times 8} = 2]","第二步，需要多少根[地址线]?由于[@2^{11}=2K]，因此需要[11根]地址线","第三步，需要多少根[数据线]?由于需要组成[2Kx8]位的存储器，因此需要[8]根数据线。",["[位]扩充和字扩充有[3点]不同，分析如下","[位扩充]操作中，所有存储芯片的[片选信号]线是连在一起的，因为对由多个[位数小]的芯片构成的一个位数大的芯片进行操作时，需要把这些小芯片[同时]选中才能操作大芯片中的一个字。而[字扩充中]需要[片选信号线]来区分不同的芯片，因此与位扩充不同，片选信号线是分开连接的。如图[3-16]所示，当片选信号为[0]时,即地址线[@A_{10}]为[0]，选中左边的芯片；反之即地址线[@A_{10}]为[1]，选中右边的芯片。","[在字扩充]中，每个芯片都应当和所有数据线连接。在字扩充中，因为要[选择不同]的芯片，而选择不同的芯片需要使用[多出]的地址线来选择，所以[CPU]的地址线往往比[存储芯片]的地址线多(往往将CPU地址线的[低位]与存储芯片的[地址线]相连)，多出的地址线用作[片选信号]。图3-16中[@A_{10}]就是多出的地址线，用作片选信号。",`可能疑问点，符号${si("consist",54,3)}是什么意思?解析，前面介绍过，[@\\overline{CS_i}]表示[低]电平有效。因此，当[@A_{10}]为低电平时，[@\\overline{CS_0}]被选中，而低电平经过${si("consist",54,3)}([非]门，可参考辅助知识点1）时变成了[高]电平，故[@\\overline{CS_1}]就不被选中;反之，当[@A_{10}]为高电平时，只有[@\\overline{CS_1}]被选中。`],si("consist",53,"80")],["[字位]扩充——增加[axb]中的[a]和[b]","*注意:在进行[字位]扩充时，一定是先进行[位扩充]，再进行[字扩充]。","第一步，需要几片芯片?需要芯片的数量[@=\\dfrac{4K \\times 8}{1K \\times 4}]","第二步，需要多少根[地址线]?由于[@2^{12}=4K]，因此需要[12]根地址线。","第三步，需要多少根[数据线]?由于需要组成[4Kx8]位的存储器，因此需要[8]根数据线",["字位扩充相关内容分析如下:","如图3-17所示，先将8个[1Kx4]位的芯片[两两一组]进行[位]扩展，组成了4个[1Kx8]的芯片,用点画线框标记出来了,组内两芯片的片选信号线要连在一起;然后将这4个[1Kx8]位的芯片字扩展成一个[4Kx8]位的芯片,每组的片选信号线连接在片选译码器上来进行组的区分,片选译码器需要[两位信号]作为输入,这两位信号由多余的两条地址线[@A_11]和[A_12]提供，信号取值范围为[@00、01、10、11]","由于每组里面都是和[位扩充]讲的一样，因此每组[第一片]的数据线连接[高4位]，[第二片]的数据线连接[低4位]〈当然也可以反过来)","[读/写]信和号线每片都连接[@\\overline{WE}]即可([ROM]可不连，[RAM]一定要连，以上讲解都假设为[RAM]芯片)。","*.注意，有些[CPU]的[读/写]命令线是分开的，此时[CPU]的[读命令线]应与存储芯片的[允许]读控制端相连，而[CPU]的写命令线则应与存储芯片的允许读控制端相连。","该片选译码器属于[2:4]译码器，而[@A_{11}、A_{10}]为[@00、01、10、11]分别对应[@\\overline{CS_0}、\\overline{CS_1}、\\overline{CS_2}、\\overline{CS_3}]有效，则选中了相应的芯片。","*.以上扩充没有考虑[ROM]和[RAM]的性质，有些题目可能会说明某地址[存放系统程序]或各类常数，某地址在放[用户程序],在选片时就需要根据[ROM]和[RAM]的特性来选择。列如，存放[系统程序]或各类常数使用[ROM]芯片，存放[用户程序]应该选用[RAM]芯片等。",si("consist",55,"80"),"将图[3-17]中左边的线[用圈]圈起来就是[CPU]了，如图[3-18]所示。",si("consist",56,"80")],"存储器的[校验]一般使用[汉明码]校验，关于汉明码的知识在[第2章]已经详细讲解过"]]],["双口[RAM]和[多模块]存储器",[["双口[RAM]","具有[两组]相互独立的地址线、数据线和读/写控制线，如图3-19所示。由于它可以进行[并行]的独立操作,因此是一种[高速工作]的存储器","很有可能在[同一时间]两个端口同时操作存储器的同一存储单元,这样就发生了冲突。为了解决此问题，特设置了[BUSY]标志。在这种情况下，当某[存储单元]被某端口访问时,就对另一个端口设置[BUSY]延迟，另一个端口就无法访问该存储单元。","扩展: [双端口]存储器可以同时对[同一区间、同一单元]进行读操作。另外，[一方读]、[一方写]也不能同时对[同一区间、同一单元]进行操作，否则将会发生冲突。总之，只要有[写操作]，就不能同时进行","众所周知，[CPU]的功能在不断增强，[IO设备]的数量也在不断增多，这导致主存的存取速度已成为计算机系统发展的瓶颈。","为了解决此问题，除了寻找更高速的元件和采用存储器[层次结构]外，调整主存的结构也可提高访存速度，如[单体多字]存储器和[多体并行]存储器（多模块存储器）。",si("consist",57,"80")],["单体多字存储器","要使[单体]多字系统能够很好地发挥其预期的作用，需要有一个[前提]，即[指令]和[数据]在主存内必须[连续存放]，一旦遇到[转移指令]，或者操作数不能连续存放，这种方法的效果就不明显了。","由图3-20可以看出，[单体多字]存储器把存储器的存储字字长增加[n倍](图3-20中[n]取[4]，数据线的宽度也必须随之增加[4]倍),以存放[n]个[指令字]或[数据字]，于是单体多字存储器的最大带宽比[单体单字]存储器的最大带宽提高[n]倍。","因为程序使用[指令字]和[数据字]也存在一定的[随机性]，所以一次读取的[n]个字很有可能是最近不需要的，正常情况下[不可能]达到最大带宽。","单体多字存储器的[缺点]: 由于单体多字存储器必须是[凑齐]了[n个]数据字之后才能作为一个[存储字]一次写入存储器，因此需要先把属于一个存储字的[n个]数据字读到数据[寄存器]中，等数据寄存器达到了[一个存储字]的长度，再将其写入存储器",si("consist",58,"80")],{tit:"多体并行存储器",arr:[["概念","[多体]并行存储器就是采用[多个模块]组成的存储器,每个模块有着[相同]的容量和存取速度，各模块都有[独立]的地址寄存器、数据寄存器、地址译码器和读/写电路,就是第1章讲过的存储器基本结构。每个模块都可以看作[一个独立]的[存储器]。","多体并行存储器分为两种，[高位]交叉编址的多体存储器和[低位]交叉编址的多体存储器。"],["[高位]交叉编址的多体存储器。","图3-21为[高位]交叉编址的多体存储器（其实这里说交叉不是很准确，说[顺序存储]更好理解)。","从图3-21中可以看出，由于每个模块内的[体内地址]顺序是连续的,一个体存满后，再存入下一个体)，因此又称为[顺序存储]。这种安排存储单元的顺序和进位很像。",["假设现在有[4]个体，每个体有[8个]存储单元，则应该有[5位]来确定唯一的存储单元，如下:","第[0]个体的地址应该是[@\\underline{00}000\\backsim \\underline{00}111]（加1之后进位）","第[1]个体的地址应该是[@\\underline{01}000\\backsim \\underline{01}111]（加1之后进位）","第[2]个体的地址应该是[@\\underline{10}000\\backsim \\underline{10}111]（加1之后进位）。","第[3]个体的地址应该是[@\\underline{11}000\\backsim \\bold{11}111]"],"综上分析，[高位]交叉编址显然是[高位地址]表示[体号]（带下划线的部分)，[低位]地址来定位[体内]地址。按这种方式，可以在同一时间使得不同的请求源同时访问不同的体，如在某一时刻，CPU在和第[0]个体交换数据，而此时第[1]个体正在和[I/O]交换数据)，进而实现个体的并行工作。","高位交叉编址的优点：非常有利于存储器的扩充，只需将存储单元的编号往后加即可。","高位交叉编址的缺点：由于各个模块一个接一个地[串行]工作，因此存储器的[带宽]受到了限制。",si("consist",59,"80")],["*[低位]交叉编址的多体存储器[重点中的重点]","从图3-22中可以看出，由于程序是存放在[相邻]的体中，因此又称为[交叉]存储。",["假设现在有[4]个体，每个体有[8]个存储单元，则应该有[5]位来确定唯一的存储单元,如下:","第[0]个体的地址应该是[@000\\underline{00}\\backsim 111\\underline{00}]","第[1]个体的地址应该是[@000\\underline{01}\\backsim 111\\underline{01}]。","第[2]个体的地址应该是[@000\\underline{10}\\backsim 111\\underline{10}]","第[3]个体的地址应该是[@000\\underline{11}\\backsim 111\\underline{11}]"],"注意，只是最高[3位]加[1](考生应该发现[第3位]一直[加1]其实就是加[4]，和图3-22恰姑)，低位[两位]不参与加[1]","综上分析，[低位地址]可用来表示[体号]，[高位地址]可用来[定位]体内地址。这样，[连续地址]分布在相邻的不同模块内，而同一个模块的地址都是[不连续]的。","定性分析：对连续字的[成块传送]，[低位]交叉编址的多体存储器可以实现[多模块]流水线式(流水线的概念可以参考第5章)并行存取，大大提高了存储器的带宽。[CPU]的速度比主存快，如果能同时从主存取出[n]条指令，那么必然会提高机器的运行速度。低位交叉编址束是基于这种思想提出来的。",si("consist",60,"80"),["下面详细分析低位交叉编址的基本结构","如[3-23]所示(此图为[4]模块低位交叉编址的基本CPU结构框图)。主存被分为[4个]相互独立、容量相同的模块[@M_0、M_1、M_2、M_3],每个模块都有目己的[读/写]控制电路、地址寄存器和数据寄存器,各自以[等同]的方式与CPU传送信息","在理想的情况下，如果[程序段]或[数据块]都是[连续地]在主存中存取，那么将大大提高主存的[访问速度]。",si("consist",61,"80"),["定量分析","讨论的[前提]是模块的字长[等于]数据总线的宽度，假设模块存储周期为[@T]，总线传送周期为[@\\tau]，且存储器由[m]个模块组成，为了实现流水线方式存取，应当满足[@T=m\\tau]","即每经过[@\\tau]时间延迟后启动下一个模快。图[3-24]表示[m=4]时的流水线方式存取示意图。如果[@T=m\\tau]，那么要求低位交叉存储器的模块数必须[大于或者等于m]以保证经过[@m\\tau]的时间后[再次]启动该体时，它的上次存取操作已完成。图[3-25]错误[小于n]，当然也可以[大于n]，一般默认图[3-24]为标准格式",si("consist",62,"80")]]],["总结","可见，若采用[低位]交叉编址的多体存储器，连续读取[n]个[字]所需要的时间[@t_1 = T + (n-1)\\tau]","若采用[高位]交叉编址的多体存储器,连续读取[n]个[字]所需要的时间[@t_2=nT]","要特别注意[高位]交叉编址和[低位]交叉编址中[并行]的概念","*[高位]交叉编址中的[并行]体现在不同的[请求源]，[并行]地访问[不同]的体","*[低位]交叉编址中的[并行]体现在[同一]请求源并行地访问[不同]的体。"],["补充知识点","一般来说，要求访存的请求资源很多，而且访问都是随机的，这样有可能在[同一时刻]出现[多个]请求源请求访问[同一个]存储体","为了防止发生两个及两个以上的请求源同时[占用]同一个存储体，并防止将代码[错送]到另一个请求源等各种错误的发生，需要设置一个[排队器]，由它来确定请求源的[优先级别]","确定规则如下：[Cache]访存的优先级最高，其次是严重影响[CPU]工作的请求源"]]}]]],note:[["有时候[RAM]芯片的[片选信号]由译码器输出信号与地址线信号[一起]决定，为什么会出现这种情况?","首先，需要介绍一个术语，即[部分译码]。通俗的意思就是对于某个芯片，不是[所有地址线]都用上了","例如，针对一个[1Kx8]位的用户程序区，地址范围[6800H一6BFFH)]，现在有[16]根地址线，其中高位的[5]根地址线[@A_{15}\\backsim A_{11}]作为片选信号线以及与译码器其他输入端口,如[辅助知识点3]中的[@G_1、\\overline{G_{2A}}、\\overline{G_{2B}}]等输入端口)的连接线。","下面将该芯片的[十六进制]范围写成[二进制]地址码，如下","[@\\def\\arraystretch{1.5}\\begin{array}{cccccccccccccccc} A_{15} & A_{14}  &A_{13} &A_{12} &A_{11} &A_{10} &A_{9} &A_8 &A_7 &A_6 &A_5 &A_4 &A_3 &A_2 &A_1 \\\\ 0 & 1 &1&0&1&0&0&0&0 &0& 0& 0& 0 &0 & 0 \\\\ 0 & 1 &1&0&1&0 &1&1&1&1&1&1&1&1&1\\end{array}]","可以看出，[低位]只需要[@A_0\\backsim A_9]就可以表示其[1K]的字地址，地址线[@A_{10}]对于该芯片来说就等于是多余的地址线。地址线一旦多余，就会出现歧义，因为不管[@A_{10}]为[0]还是为[1]，该芯片都会被选中，但是只能[@A_{10}]为[0]时才选中","从该芯片的二进制地址码可以看出，[@A_{10}]为[0]。因此，此时仅由[@{A_13}、A_{12}、A_{11}]输入[译码器]后，用其输出信号来选择芯片是不具有唯一性的，故一定要用[@A_{10}]共同诀定。","*.具体请看[天勤视频-存储器与CPU的连接]"],["画主存储器的逻辑图的示例",si("consist",78,"80")]]},{tit:"存储器",note:[["程序员是否需要知道高速缓存的访问过程?","[不需要]。高速缓存(Cache)的访问过程对程序员来说是[透明的]。执行到一条指令时需要到[内存取指令]，有些指令还要访问内存[取操作数]或[存放运算结果]。","采用[Cache]的计算机系统中，总是[先到Cache]去访问指令或数据，没有找到才到主存去访问。这个过程是[CPU]在执行指令过程中[自动完成]的。","程序员不需要知道要找的指令和数据是否在[Cache]中，若在[Cache]中是在[Cache]的哪一块中，也不需要知道[Cache]的访问过程，只要在指令中给定[内存单元]的地址就行了。"],["首先区分一下[IO空间]和[内存空间]","[cpu]会访问的设备一般有[内存]和[外设寄存器]，如下图所示。[x86]架构采用独立编址将[内存操作]与[外设IO操作]分开了，才有了内存空间和IO空间的区分","[x86平台cpu]内部对内存和外设寄存器访问的指令也是不同的。[arm]等其他平台都采用统一编址，不区分内存和外设的访问","[IO空间]：访问外部设备寄存器的地址区域，[x86]平台为[64k]","[内存空间]：访问内存的地址空间，[32]位平台为[4G]",si("consist",77,"80")],"[@\\href{https://blog.csdn.net/vavid317/article/details/110946947}{主存地址和cache地址的位数划分及其计算}]"],compare:[["高速缓冲存储器",[{tit:"[Cache]的基本工作原理",arr:[["Cache 产生的背景","在多体并行存储器中讲过，外部设备的[优先级]最高这样就会导致[CPU]等待外部设备访存的现象，致使[CPU]空等一段时间，甚至可能等待[几个]主存周期，从而降低了CPU的工作效率。","为了避免CPU 与[I/O]设备争抢访存，可在[CPU]与[主存]之间加一个[Cache]。这样一来，如果外部设备正在和主存交换信息，[CPU]就可以不用等待，直接从[Cache]中取所需信息。当然，考生会提出质疑，Cache那么小，每次访问CPU的数据都有吗？"],["局部性原理","通过大量典型程序的分析，发现[CPU]从主存取指令或取数据，在一定时间内，只是对主存[局部地址]区域的访问（如循环程序、一些常数)。于是人们就想到一个办法,将[CPU]近期需要的程序提前存放到[Cache]中。这样[CPU]只需访问[Cache]就可以得到所需要的数据了。","一般[Cache]采用高速的[SRAM]制作（主存一般使用[DRAM]），其[价格]比主存高,容量远比主存小。 ",["局部性原理一般有两种，即[时间]局部性原理和[空间]局部性原理。","[时间]局部性原理。如果某个数据或指令被使用，那么不久将可能再被使用。","[空间]局部性原理。如果某个数据或指令被使用，那么附近数据也可能被使用"],"注意：大纲已经将程序访问的局部性原理删除，但是局部性原理对于理解[Cache]的工作原理及[虚拟]存储器都是很重要的，因此仍然保留此部分内容作为背景了解。"]]},{tit:"主存和[Cache]的编址",arr:["*.图[3-26]为[Cache-主存]存储空间的基本结构。前提:如果[主]存要和[Cache]映射，那么至少要保证[主存]中每块的[大小]应与[Cache]中每块的大小相同，这样才可以对应起来。",si("consist",63,"80"),["主存","从图[3-26]中可以看出，主存由一个个的[字块]组成，当然每个字块包含[N]个字。","主存的地址应该分为两部分:一部分用来[寻找]某个[字块];另一部分用来[寻找]该字块中的[字或字节](至于是字还是字节，需要看是哪种[寻址方式]，在后面例题中会详细讲解)。","从图[3-26]中可以看出，主存的地址分为两部分:高[m]位表示主存的[块]地址，低[b]位表示其块内的[字或字节]数","则[@2^m=M]表示主存的总块数。"],["[Cache]","同样，[Cache]的地址也应该分为[两部分](图3-26):高[c]位表示[Cache]的[块号]，低[b]位表示其抉内的[字或字节数]，则[@2^c=C]表示[Cache]的总块数，当然[Cache]的块数[C]应当远远小于主存块数[M]。","既然[C]远远小于主存块数[M]，一个缓存块不能唯一地、永久地对应一个主存块（因此在图3-26中给[Cache]设置了标记，相当于主存块的编号），那么肯定会存在一种情况开即某时刻[CPU]要访问的信息不在Cache中,那应该怎么办?这种情况称为[Cache]不命中,或者[Cache]缺失。通常使用[命中率]或者[缺失率]来衡量[Cache]的效率。","[命中率]的概念：[CPU]要访问的信息在[Cache]中的比例。","[平均访问]时间的概念：假设命中率为[h]，[@t_c]为命中时访问Cache的时间，[@t_m]为未命中时的主存访问时间，则[Cache-主存]系统的平均访问时间[@t_a]为[@t_a=ht_c+(1-h)t_m]","[Cache-主存系统]效率的概念: 用[e]表示效率，则有[@e=\\dfrac{t_c}{t_a}]"],["[Cache]的命中率只和[Cache]的[容量]、[Cache]的[字块长度]有关","往意: [CPU]与[Cache]之间传送数据的基本单位是[字]，而[主存]与[Cache]之间传送数据的基本单位是[块](一块包括多个字)。","CPU访间主存时，会将地址同时送给[Cache]和[主存]，[Cache]控制逻辑依据[地址]判断此[字]是否在[Cache]中，若此字在[Cache]中，立即传送给[CPU]，否则，用主存[读周期]把此[字]从主存读出并送到[CPU]，与此同时，把含有这个[字]的整个[数据块](是[整个]包含此字的数据块，不仅仅是这个[字])，从主存读出并送到Cache中。"]]},{tit:"Cache 的基本结构",arr:[["[Cacbe]的基本结构应该由[哪几]大部分组成?","首先，[CPU]送来的主存地址怎么能转换成[Cache]地址? 这需要一个[地址映射变换机构]","其次如果[Cache]内容已满，无法接受来自主存的块时，怎么去给[Cache]腾出位置来? 这需要一个[替换机构]。后面将介绍这两个机构,[Cache]的基本结构如图[3-27]所示"],["可能疑问点:[指令]和[数据]都是放在同一个[Cache]中吗?","答:在现代计算机系统中，一般采用[多级Cache系统]。[CPU]执行指令时，先到速度最快的一级[Cache(L1 Cache)]中寻找指令或数据,找不到时,再到[速度次快]的二级[Cache(L2 Cache)]中找。以此类推，[最后]到主存中找。一级[Cache]的指令和数据一般分开存放，而二级[Cache]的指令和数据是放在一起的,因此，有[L1 data Cache]和[L1 code Cache]"],["在[CPU]和[主存]之间加入了多个[Cache]，计算机总存储量就增加了，对吗?","答:不对。虽然[Cache]是存储器，具有[几百KB]甚至[几MB]的容量，但因为它存放的是[主存]信息的[副本]，所以并不能增加系统的存储容量。"],si("consist",64,"80")]},{tit:"[Cache]和主存之间的映射方式",arr:[["[地址映射]变换机构","是将[CPU]送来的[主存地址]转换为[Cache]地址。","由于主存和[Cache]的[块大小]相同，[块内]地址都是相对于块的[起始地址]的[偏移量](即低位地址相同)，因此地址变换主要是[主存块号]与[Cache块号]之间的转换。","地址变换主要有[3]种转换方式，即[直接映射、全相联映射和组相联映射]。"],{tit:"直接映射",arr:[si("consist",65,"80"),"图[3-28]为直接映射方式主存与[Cache]中字块的对应关系，其中[Cache]分为[8]行，主存分为[256]行,由于[Cache]被分为[8]块，因此在主存中可以将每[8]块看成一个[轮回]，这样[主存]就可以被分为[32]个[轮回]。","而每个[轮回]中的第[i]块只能映射到[Cache]的第[i]块，类似于生活场景中的个位数为[n]的学生只能坐到讲台上的[n]号位置。","如果要用一个数学表达式来表示，则很快会想到用[取模]来对应，如下:[ i=j mod C]其中，[i]为[Cache]中的[块号]；[j]为[主存]中的[块号]；[C]为[Cache]的[块数](图 3-28中[C]等于[8])。","上面的公式表示将[主存]第[i]块内容[复制]到[Cache]的第[i]块中。 ","[优点]: 实现简单。只需要利用[主存地址]的[某些位]直接判断,即可确定所需字块是否在[Cache]中",["缺点","不够灵活。因为每个主存块只能[固定]地对应某个[Cache]块，即使[Cache]内还空着许多位置也[不能]占用，所以导致[Cache]的存储空间得不到充分利用","[冲突概率高](抖动)。抖动就是某个块[频繁]地进行交换"],"应用场合:适合大容量[Cache]",["操作原理","首先，[CPU]访存指令指出一个[内存地址]，该[内存地址]包含[tag]、[块号]、[字]等字段。","然后，根据内存地址中的[块号c]找到[Cache]中对应的块号(用[ i mod C]找到)，找到[Cache]中对应的块号之后，将该块中的[标记]和内存地址中的[t]位[tag标记]送入[比较器]进行比较。","若相符且有效位为[1]（[有效位]用来识别[Cache]存储块中的数据是否有效，因为有时候[Cache]中的数据是无效的，例如，在初始时刻 Cache 应该是空的，其中的内容是无意义的），即表示[命中]","然后用内存地址的低[b]位在[Cache]中读取所需要的[字]即可。","若[不符合]或有效位为[0](即不命中)，则需要从主存中读取所需要的块(该块包含此时需要读的字)来[换Cache]中旧的块，同时将信息送往[CPU]，并修改[Cache]的标记，如果原来有效位为[0]，还得将有效位置[1]，如图[3-29]所示。"],si("consist",66,"80")]},{tit:"全相联映射",arr:[si("consist",67,"80"),"全相联映射[允许]主存中[每一个]字块映射到[Cache]中的[任何]一块的位置上。","前面讲过，如果是[全相联映射]，那么每个人需要举着[两位数]号码的牌子才能识别这个人。","在图[3-30]中，主存有[256]块，[Cache]需要[8]位([@2^8 = 256])来作为标记位，这样才能识别[每一个]主存块。","返回图[3-28]，因为[直接映射]只需要识别每个[组号]即可，所以[主存]大小是[Cache]的32倍(也就是说，主存需要分为[32]组)，即[Cache]需要[5位]来作为标记位，这样才能识别该块属于哪一组",["优点","由于全相联映射允许主存的每一字块映射到Cache中的任何一个字块因此[Cache]的[命中率]可以提高","通俗地说,全相联映射就是[有位置就可以坐]，减小了块的[冲突率],进而提高了[Cache]的利用率。"],"缺点: [tag]的位数[增加]了，访问[Cache]时[主存字块标记]需要和[Cache]的全部[标记]进行比较，才能判断所访问[主存地址]的内容是否已在 [Cache]内。这种比较通常采用[按内容寻址]的[相联]存储器来完成","应用场合: 适用于[小容量]的 Cache。",["操作原理","如图[3-31]所示。首先，[CPU访存指令]指出一个内存地址，该内存地址包含[块号、字]等字段。为了[加快]检索速度，[Cache]所有[行]的标记位和内存地址的[块号]一同送入比较器中比较","如果块号[命中]，则直接从[Cache]命中的块号中读取所需的字，如果块号不命中，则按内存地址[读取]这个字，同时把内存块读入[Cache]行中。","细心的考生可能会问，这里不需要考虑[有效位]吗?考虑最好，不考虑也行。至于当[Cache]满时，从[Cache]中替换哪一块出来,可参考后面[Cache 替换]机构的讲解。",si("consist",68,"80")]]},{tit:"组相联映射",arr:["图[3-32]为组相联映射方式主存与Cache中字块的对应关系。可以看出，[组相联映射]是对[直接映射]和[全相联映射]进行[折中]的一种方式","假设把[Cache]分为[Q]组，每组有[R]块，现在考生需要做的事情是把[组相联映射]的一组[看作]直接映射中的一块。同理，可以得到和直接映射中一样的公式为:[ i = j mod Q]","其中，[i]为[Cache]中的组号；[j]为主存中的[块号]；[Q]为[Cache]的[组数](图3-32中[Q]等于[4])","通俗地说，上面的公式就是主存第[i]块内容[复制]到[Cache]的[i]组中，至于是第[i]组的[哪一块]那就可以[随意放了]","由于[Cache]分为[4]组，因此主存的[256]块应该分成[@256/4=64]个[轮回]，故需要[6]位[tag]来表示是哪一个[轮回]",si("consist",69,"80"),["补充","当[组相联]只有[一组]时，此时组相联映射就等同于[全相联映射]，当[每组]只有[一块]时，此时[组相联映射]就等同于[直接映射]","在组相联映射中，[主存地址]高位到低位划分成[3]部分: [标记tag]、[组号]和[块内字地址]",["这[3个]字段[位数]求解步骤如下: ","块内字地址=[@log_2](块大小)","组号=[@log_2] ([Cache]组数)","[标记tag]=主存地址的[其余位]",["特别的解法","主存[129]号单元，主存块大小[32B],[Cache]总共[16]块，每组[2]块","将[129]转换成二进制，即[@10000001]。块内[32B]需要占[5]位","[Cache]总共[16]块[8]组，需要[3]位索引组号；其余位为[Tag]","因此，[@1000001\\implies 0,100,00001]，即组号为[4]，组内[偏移]为1，[Tag]为[0]"]],"假设每组有[N]块，则称为[N]路组相联。图[3-32]可以称为[二路]组相联。"],["操作原理","如图[3-33]所示。首先，[CPU访存指令]指出一个内存地址,该内存地址包含[tag组号、字]等字段","然后，通过[组号]找到[Cache]中对应的[组]，然后将[Cache]该组中每一块的[tag]和内存地址的[tag]送入[比较器]中进行比较。","如果[Cache]中有某块的[tag]与之符合,则表示[Cache命中]，通过内存地址的低[b]确定需要[该块中]的哪一个字，然后进行[存取]操作","如果[Cache]中每行的[tag]都与之[不相符]，则[不命中]，需要去[内存]取需要的字，并将内存中该字所在的块送入[Cache]中","至于当[Cache]满时，从[Cache]中[替换]哪一块出来，可参考[Cache替换算法]。",si("consist",70,"80")],["另外一种组相联映射方式","该方式是先将主存块按[Cache]大小分区，再将[各个]分区中的块进行[分组]，同样[Cache]内也分组，[组内分块]","主存中[不同区]的[相同序号]的组和[Cache]同序号的组采用[直接映射](如主存的第[X]区的第[0]组只能映射到[Cache]的第[0]组)","主存和[Cache]同序号的[组内]各块采用[全相联映射]，不同序号的组[没有]映射关系。",si("consist",75,"80").split("1")]]},["总结","三种映射方式下的主存地址结构",si("consist",71,"80"),["[Cache]标记项的概念。","每一个[Cache]行对应一个[标记项](包括有效位、标记位Tag、一致性维护位、替换算法控制位)，","对于组相联映射方式来说，每一组的标记项放在一起构成一行，将各组从上而下排列，成为一个标记项阵列，图[3-37]是四路组相联的标记阵列示意图","对于全相联映射和直接映射来说，标记项一行就是一组","对于每个[标记项]来说，其结构如图[3-38]所示","其中括[1bit]有效位，[1bit]一致性维护位(脏位)，替换控制位的位数与采用的替换算法有关，[标记位]的位数等于[主存地址]的[标记字段]位数。",si("consist",72,"80"),si("consist",73)],"*.[tag]位表示轮回"]]},{tit:"[Cache]中主存块的[替换]算法",arr:["*.注意:替换机构的常用算法在操作系统高分笔记》中有详细讲解，本书只介绍相关概念",["[Cache]的工作原理要求它尽量保存最新数据。","当一个新的主存块需要复制到[Cache]，而允许存放此块的行位置都[已占满]时，就要产生替换。替换问题与 [Cache]的组织密切相关。","当[Cache]使用直接映射时，因为直接映射方式一个主存块只能放在一个特定的位置，所以只要把此特定位置上的主存块换出[Cache]即可。","对于[全相联]和[组相联Cache]来说，因为[一个主存块]可以映射到[多个Cache]块，所以就要通过规定的[替换方式]从[Cache]中替换出一块。至于如何选取就涉及替换策略，又称为[替换算法]","理想的替换算法应该是把[未来很少]用到的或者[很久才用到]的数据块替换出来,但实际上很难做到常用的替换算法有[先进先出]算法、[近期最少使用]算法和[随机法]"],["先进先出[FIFO]算法","[FIFO]算法选择[最早]调入[Cache]的字块进行替换，它[不需要]记录各字块的使用情况，比较容易实现，开销小","但没有用到访存的[局部性原理]，故不能提高[Cache]的命中率。最早调入的信息可能以后还会用到，或者经常要用到，如循环程序。"],["近期最少使用[LRU]算法","[LRU]算法比较好地[利用]访存局部性原理替换出[近期用得最少]的字块","它需要随时[记录][Cache]中各字块的使用情况，以便确定哪个字块是近期最少使用的字块。","[LRU]算法实际是一种[推测]方法，比较复杂，一般采用简化的方法，只记录每个块最近一次使用的时间(考试一般说的近期最少使用算法是使用该种判别方式)。[LRU]算法的[平均命中率]比[FIFO]算法高"],["随机法","随机法是[随机地]确定被替换的块，比较简单，可采用一个[随机数产生器]产生一个随机被替换的块，但它也没有用到访存的局部性原理，故不能提高[Cache]的命中率。"]]},{tit:"[Cache]写操作策略",arr:["*.由于[Cache]的内容只是[主存部分内容]的副本，因此它应当与主存内容保持一致。而[CPU]对[Cache]的写入更改了[Cache]的内容，就会导致[Cache]的内容和主存的内容不一致。如何能让[Cache]的内容与主存的内容[保持一致]就是[Cache写操作策略]需要完成的事情。Cache 写操作策略有如下3种形式。",["写回法","写回法要求: 当[CPU]写[Cache命中]时，只修改[Cache]的内容，而不立即写入[主存]，只有当此行[被换出时]才写回主存","这种方式可以减少访问主存的次数。问题来了，那当[换出]此块时怎么能知道此块被修改过?实现这种方式时需要对[Cache]的每行都必须设置一个[修改位](或者称为[脏位])。","当某行被换出时，根据此行的修改位是[0]还是[1](可以规定[1]代表修改过，[0]代表没有修改，来决定将该行内容写回主存还是简单弃去","注意: 上面考虑的是[Cache]命中时，那[不命中]呢?如果[CPU]要对[Cache]中某块的某字进行修改，此时恰好此字不在[Cache]中，就需要从主存中找出[包含]此字的数据块","千万注意，[CPU]不会在主存中直接修改，而是找到之后直接复制到[Cache]中进行修改，等从[Cache]中换出此块时，再复制到主存。","当使用写回法时，求[Cache]的位数。此时，一些考生可能不会加上修改位(隐含条件，有[多少行]就加多少[修改位])。"],["全写法","全写法要求: 当写[Cache]命中时,[Cache]与主存同时发生[写修改]，因而较好地保持了Cache与主存内容的一致性","很明显，此时[Cache]不需要[每行]都设置修改位。当写[Cache]未命中时直接在主存中修改(和写回法不同)。至于在主存中修改后需不需要复制到[Cache]中，这个视情况而定，可以复制也可以不复制。"],["写一次法","写一次法是基于[写回法]并结合[全写法]的写策略的一种形式(这种情况好像看得比较多每次都是先介绍两种方式，第3种就采取折中方式，如[Cache]的映射方式就是如此)","[写命中]与[写未命中]的处理方法与写回法基本相同，仅仅是[第一次]写命中时要[同时]写入主存。"]]}]],["其他存储器",[{tit:"虚拟存储器",arr:["*.参考[操作系统]",["页式虚拟存储器","页式虚拟存储器就是将其[基本单位]划分为[页]，且将主存的物理空间划分为与虚拟存储器[等长]的页","划分的页称为页面，主存的页称为实页，虚拟存储器的页称为虚页","系统基本信息的传送单位是定长的页，需要通过地址变换机构实现访存过程，当访问页面不在主存时，通过页面置换算法将需要的页面调入主存。","[优点]: 由于页面的起点、终点地址是固定的，因此页表简单，调入方便，主存空间浪费小","[缺点]: 由于页面不是逻辑上的独立实体，因此处理、保护和共享都不如段式虚拟存储器方便。"]]},{tit:"外存储器",arr:["*.外存储器的主要知识点包括硬盘存储器、磁盘阵列和光盘存储器",{tit:"硬盘存储器",arr:[["问题一:硬盘存储器是怎么记录数据的?(如图3-40)","归零制[(RZ)]：记录[1]时，通[正向]脉冲电流，记录[0]时，通[反向]脉冲电流。[0]和[1]信息之间驱动[电流归零]","不归零制[(NRZ)]：记录[1]时，通[正向]脉冲电流，记录[0]时，通[反向]脉冲电流。 只有当[相邻]信息代码[不同]时，电流才[改变]方向，故称为[见变就翻]。","见[1]就翻的不归零制[(NRZ1)]：只有记录[1]时，电流才[改变]方同",si("consist",76,"80")],["硬盘存储器的磁道记录格式和工作原理","*.硬盘存储器的磁道记录格式分为[定长]记录格式和[不定长]记录格式，考研主要考查定长记录格式，非定长记录格式不作要求。","一个具有[n]个盘片的磁盘组，可将其[n]面上[同一半径]的磁道看成一个[圆柱面]，这些磁道存储的信息称为柱面信息","在移动磁头组合盘中，磁头定位机构一次定位的磁道集合正好是一个柱面。信息的交换通常在圆柱面上进行，[柱面个数]正好等于[磁道数]，故[柱面号]就是[磁道号]，而[磁头号]是[盘面号]，如图[3-44a]所示","每个盘面又分为若干[扇区]，每条[磁道]被分割成若干个扇区(或者称为扇段)，数据在盘面上的布局如图[3-44b]所示","[扇区]是磁盘寻址的[最小单位]。在定长记录格式中，当[台号](什么是台号?一般来说，一个系统可挂[多组]磁盘组，每个磁盘组都有一个号码，即台号)确定后磁盘寻址定位先确定[柱面](寻道时间)，再选定[磁头](找到盘面)，最后找[扇区](等待时间)","因此，要在某磁盘组内找到所需数据，磁盘地址的设计应该包含[4]个字段:台号、磁道号盘面号和扇区号(或者扇段号)，地址格式如图[3-44c]所示",si("consist",79,"80",!0)],["相关数据传输时间计算","不管一个磁道有多少个扇区，对于[访问一个扇区]的时间就算按旋转[半圈]的时间算"]]}]}]]]}]},hardware:{top:[["考点",""],["题型",""],["内容","数值的各种转换和运算","校验码的校验过程"]],article:[{tit:"数据的表示",compare:[["数据的表示",[["*定点小数",["进制转化","小数转二进制：[乘2取整，由上而下]"],"定点小数加减法","定点小数乘法","定点小数除法","溢出处理"],["常见的二进制数","[@ 2^8=128\\hspace{1em}2^{10}=1024\\hspace{1em}2^{20}=1048576 \\hspace{1em}2^{16}=65536]"],["机器数","[3]种机器数的最高位均为符号位。","当真值为正数时，[原码、补码和反码]的表示形式均相同","当真值为负数时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“每位求反加1”，反码是原码的“每位求反”。需要注意的是，上面所谓的“每位求反”[均不包括符号位]，只是对数值部分进行求反，且原码除了符号位为“1”，数值部分仍然与真值相同。"],["为什么计算机中会有补码呢？",["背景","计算中有了[加法]，为了节约成本，避免不必要的开销，用[加法代替减法]，如[@1-1=1+(-1)]","如此，计算机的硬件只需要支持加法即可。如果用加法来算减法，以[@1-1]为例： 用原码来计算[@0000 0001 +1000 0001 =1000 0010] 计算的结果[@1+(-1)=-2]","与实际不符，所以直接用[原码]计算肯定是不行的，因为[符号位]参与计算，且计算机又不会[区分]最高位为符号位。 所以用到了[补码]进行计算。为了理解补码，下面介绍几个数学上的概念"],["模","是指一个计量系统的[计数范围]。 如时钟的计量范围是[0~11]，[模=12]。","[模]是计量器产生[溢出]的量。它的值在计量器上表示不出来，计量器上只能表示出模的[余数]，如12的余数有[0,1,2,3,4,5,6,7,8,9,10,11]"],["补数","假设当前时针指向[11]点，而准确时间是[8]点，[调整]时间可有以下两种拨法","一种是[倒拨]3小时，即：[@11-3=8]","另一种是[顺拨]9小时：[11+9=12+8=8]（11+1筹够一个模，从头开始重新计数，计数到指定位置8）","在以模为[12]的系统中，[加9]和[减3]效果是一样的，因此凡是减3运算，都可以用加9来代替。 对[模12]而言，[9]和[3]互为[补数]（二者相加等于模）。"],["*.总结","所以我们可以得出一个结论，即在[有模]的计量系统中，减一个数等于加上它的补数，从而实现将减法运算转化为加法运算的目的。 即[@11-3=11+9=20]，因为模是[12]，所以[@11-3=11+9=20-12=8]","计算机中的运算，就是[取补码]进行[加运算]，运算[结果再取补码]，就是正确的值。 [反码]只是计算时用到的一个[临时数]，没有实际意义"]]]],["浮点数",[["*浮点数的表示","[@ N = M\\times r^E]","[M尾数]：用定点小数，[E阶码]:用补码或阶码表示",si("consist",17,30,!0)],["浮点数加减法","对阶","尾数求差（加上补数）","规格化:(左规和右规)","舍入处理：对于在右规和对阶的过程中，可能会导致最后一位[1]被舍去，所以尾数要加[1]","溢出判断"],["IEEE754 标准的浮点数（用移码表示阶码）","阶码需要加上[偏置值]","**对于用[移码]表示[阶码]的浮点数，[尾数]其实是可以[多表示一位]的，因为这一位是固定为[1]，所以不需要写出来"],["移码","补码不方便与原码比大小，所以用移码来表示","对于[n+1]位机器数，真值加上[@ 2^n],就是对应的移码，可以说移码就是[补码]的[符号位][取反]，所以对于移码的符号位，[1]是正，[0]是负","只能表示整数"]]]],note:[["关于定点小数和定点整数的[@-1]的补码表示","定点整数: 全[@1]，例如8位,[@\\bold{1}111 \\; 1111]","定点小数: 除符号位外全[@0], [@\\bold{1}.000\\;0000]"]]},{tit:"数据的运算",compare:[["定点数运算",[["运算采取哪个机器数？","在现在的计算机系统中，可以说[99%]都是采用补码运算，这个说明了什么?如果要研究运算方法和运算器，那么讨论的所有运算都应该以[补码]运算为主，但是也不是全部的计算机系统都采用补码，原码也有研究的必要,如[原码乘法]和[原码除法]","两[原码]表示的数[相加减]，首先要[考虑]它们的[符号]。若为[同号]，则数值部分相加，结果的符号取被加数或加数的符号；","若为[异号]，数值部分相减，结果的符号取绝对值大的数的符号。原码一般不用来进行加减运算，而多用来进行乘除运算","进行加减运算时，多用[补码]"],["注意","[符号位]进位[舍去]"]]],["浮点数运算",[]]]}]},software:{top:[["考点","指令的各种寻址方式的原理","指令的执行过程","控制器的工作流程"],["题型",""],["内容","控制器的功能和工作原理"]],article:[{tit:"指令系统",compare:[["指令格式",["*.指令：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。",["指令格式设计",si("consist",80,"80"),si("consist",81,"80"),"[操作码]字段的[位数]要根据需要执行的[操作数量]来确定","[寻址方式字段]的[位数]根据支持的[寻址方式数量]确定","[地址码字段]位数根据需要访存的[空间的大小]来确定。"],["*操作码分类","定长操作码：一般n位操作码字段的指令系统最大能够表示[@2^n]条指令。","扩展操作码（不定长操作码）：最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加","*.产生的指令数量由操作码和地址码的不同来组合。注意把一种形式的操作码当作[扩展码]的情况。具体看[例4-1]"],["操作类型",si("consist",82,"95")]]],["寻址方式",[["指令寻址和数据寻址","指令寻址: 找到下一条将要执行指令的地址",si("consist",83,"80",!0),{tit:"数据寻址: 找到当前正在执行的指令的数据地址",arr:[si("consist",84,16),"立即寻址：通常用于对某寄存器或内存单元赋初值",si("consist",85,16),"直接寻址：",si("consist",86,22),"*间接寻址",si("consist",87,"80",!0),"寄存器寻址",si("consist",88,"50",!0),"寄存器间接寻址：第二次要找的地方是主存","基址寻址",si("consist",89,"80",!0),"变址寻址",si("consist",90,"80",!0),"相对地址: 用于转移类指令",si("consist",91,"80",!0)]},si("consist",92,"90",!0),"*.注意间接寻址中[地址]和[内容]，别把[地址]当作[内容]了"]]]]},{tit:"中央处理器",compare:[["CPU功能和结构",[si("consist",94,"80"),["cpu介绍","功能：[_操作控制_、_时间控制_、_数据加工_、_中断处理_]","CPU的[-工作过程-就是_周而复始地执行指令_]，计算机各部分所进行的工作都是由CPU根据指令的要求来启动的","在一个[_机器周期_]结束时，查询是否有[DMA请求]","在一个[_指令周期_]结束时，查询是否有[中断请求]",si("consist",95,"60")],["CPU寄存器","运算器中的寄存器","控制器中的寄存器","[用户_可见_寄存器]是指用户可以[|通过程序|去访问]的寄存器"],["数据通路","定义：[_数据_在|功能部件之间|传送的^路径^称为_数据通路_]",["数据通路的基本结构",si("consist",101,"80"),"CPU内部[_总线_方式]：一般简称[BUS]","[_专用_数据]通路方式"],["常见的数据通路之间的数据传送","寄存器之间：一般是CPU内部总线","主存与CPU之间：一般是CPU内部总线",["执行算术或逻辑运算","实现加法操作的工作流程和控制信号",si("consist",102,"80")]]]]],["指令执行过程",[["指令周期",si("consist",96,"80",!0),"[CPU]每[_取出并执行_一条指令]所需的[全部时间],即[CPU]完成一条指令的时间，称为[-指令周期-]。","指令周期被划分为[_几个不同_的阶段]，每个阶段所需的时间称为[-机器周期-]，又称为[CPU工作周期或基本周期]，通常等于[取指时间](或访存时间)。","[-时钟周期-]是时钟频率的倒数，也可称为[_节拍脉冲_]或[_T周期_]，[是^处理操作^最基本的_单位_]","一个[-指令周期-]由若干个[-机器周期-]组成，每个[-机器周期-]又由若干个[-时钟周期-]组成",`${si("consist",99,"40")}${si("consist",100,"60",!0)}`,`${si("consist",97,"60")}${si("consist",98,"40",!0)}`],["指令执行方案","单指令周期","多指令周期","流水线方案"],{tit:"控制单元的功能",arr:[["微操作命令",""]]}]]]}]}};var li={top:[["基本类型","字符串","数字"],["定义","常量定义","结构体、类定义","函数定义","引用其他函数、类、，或其他文件里的"],["复合类型","数组","引用","指针"]],article:[{explain:[["Vim",["正则使用","*.[@\\href{https://www.jianshu.com/p/3abd6fbc3322}{VIM正则结束}]",["替换变量","在正规表达式中使用[(]和[)]符号括起正规表达式，即可在后面使用[\\1、\\2]等变量来访问[( )]中的内容。"],["关于magic","vim中有个magic的设定。设定方法为：",'$@vim@\n               :set magic " 设置magic \n               :set nomagic " 取消magic \n               :h magic " 查看帮助\n               $']]]]}]};var hi={basic:{top:[["基本类型","字符串","数字"],["定义","常量定义","结构体、类定义","函数定义","引用其他函数、类、，或其他文件里的"],["复合类型","数组","引用","指针"]],article:[{tit:"事件机制",compare:[["宏任务、微任务",["各种定时器",["执行顺序","[@\\href{https://mp.weixin.qq.com/s/1iBEjoZeA7bUmpAA1KEYhA}{async、await 魔鬼细节}]"],"队列关系","对组件联合更新的影响","$@typescript@\n              setTimeOut();\n              setImmediate();\n              Promise();\n            $"]],["事件循环机制",[]]],explain:[["各种标准",[["JS模块规范","JS模块规范：[AMD、UMD、CMD、commonJS、ES6 module]","[@\\href{https://segmentfault.com/a/1190000012419990}{模块规范}]"]]]]},{tit:"主流框架",compare:[["React",[["[keep-alive]的原理"],["[fiber]和[vdom]",si("js",1,"90"),"[vdom]结构是[树形结构]，使用[栈]来进行[递归]，实现数据流[@子\\rightarrow 父]，不能被[打断](自己理解不能被打断，因为递归终止当前调用后，会返回到上一个调用栈中，此时函数仍然在执行。)","[fiber]结构是[链表]，不需要用[栈]，就可以实现数据流[@子\\rightarrow父]","*.仔细注意两种数据结构"],["React 18 并发机制的原理","[@\\href{https://juejin.cn/post/7171231346361106440}{彻底搞懂 React 18 并发机制的原理}]"],["子向父通信的方式",["父组通过传递带有函数参数的函数[prop]给子组件","$@ts@\n               // 父组件\n                {\n                  getChild: null,\n                  bindChildMethods(childMethod:()= >any){\n                    this.getChild = childMethod;\n                  }\n                  render(){\n                    return <子组件 bindChildMethods={this.bindChildMethods} />\n                  }\n                }\n              \n              // 子组件\n              {\n                data: {},\n                getData(){\n                  return this.data;\n                }\n                constructor(props){\n                  props.bindChildMethods(this.getDta)\n                },\n              }\n              $","传递起来麻烦，父组件要设置[传递函数]和[接收函数]才能通信，一旦通信可以，随时随地通信，如同属于自己"]]]],["事件机制",[["数据更新合并机制","React 会在[事件处理、生命周期方法和 useEffect 中]执行的代码块中进行[批量更新]。","需要注意的是，并非所有情况都会触发合并更新。例如，在[^异步代码^]"]]]],compare1:[["Vue",[["[keep-alive]"],["响应式",["$ref()$与$reative()$探究"]],["子向父通信的方式",["子组件主动调动$@ts@ this.￥emit $，来向父组件传递","$@html@\n                  // 父组件\n                    <template>\n                      <子组件  getChild={getChild} />\n                    </template>\n                    <script>\n                      const getChild = (childData)=>{\n                        console.log(childData);\n                      }\n                    <\/script>\n\n                  //子组件\n                    <template>\n                      <button  handle={change} />\n                    </template>\n                    <script>\n                      const data = {};\n                      const change = ()=>{\n                        this.$emit('getChild', data)\n                      }\n                    <\/script>\n                $"]]]]],explain:[["框架结构",[["概念讲解","何为[声明式]渲染","响应式数据 [VS] 不可变数据","什么是双向绑定、为什么需要双向绑定"]]],["React与Vue对比",[["区别文章","[@\\href{https://mp.weixin.qq.com/s/Z_FHSi1uGHj9as9bkhDgaQ}{React 和 Vue 全方位对比总结}]"]]]]},{tit:"系统和浏览器自带的那些模块",compare:[["常见APi",[["复制粘贴操作","*注意浏览器只对[_localhost_和_https_安全策略]才有$navigator.clipboard$",'$@ts@\n              fucntion copyToClip(copyText : string) {\n                  if (navigator.clipboard) {\n                    navigator.clipboard.writeText(copyText).then(\n                      // 复制成功callback\n                      function () {\n                        notice.add("复制成功！");\n                      },\n                      // 复制失败callback\n                      function () {\n                        notice.add("复制失败", "warn");\n                      },\n                    );\n                  } else { // 兼容浏览器只对 localhost 和 https 安全策略才有 navigator.clipboard 时，的兼容\n                    const input = document.createElement(\'input\');\n                    document.body.appendChild(input);\n                    input.setAttribute(\'value\', copyText);\n                    input.select();\n                    if (document.execCommand(\'copy\')) {\n                      document.execCommand(\'copy\');\n                      notice.add("复制文件链接成功！");\n                    } else {\n                      notice.add("复制失败");\n                    }\n                    document.body.removeChild(input);\n                  }\n                }\n              \n              $'],["原生请求",["[|XMLHttpRequest|]",'$@ts@\n                  const data = new FormData();\n                  const xhr = new XMLHttpRequest();\n                  xhr.open("post", "/document/uploadFile", false); // 同步请求\n                  xhr.send(data);\n                $'],["[|Fetch Api|]","$@ts@\n                  fetch\n                $"]]]],["冷门APi",[["MutationObserver"]]]]},{tit:"文件流的处理",compare:[["前端文件流",[["文档流下载$URL.createObjectURL(blob)$","$@js@\n                  const { data, headers } = res;\n                  const fileName = headers['content-disposition']\n                  .replace(/\\w+;filename=(.*)/, '$1');\n                  // 此处当返回json文件时需要先对data进行JSON.stringify处理，其他类型文件不用做处理\n                  //const blob = new Blob([JSON.stringify(data)], ...)\n                  const blob = new Blob([data], {type: headers['content-type']});\n                  let dom = document.createElement('a');\n                  let url = window.URL.createObjectURL(blob);\n                  dom.href = url;\n                  dom.download = decodeURI(fileName);\n                  dom.style.display = 'none';\n                  document.body.appendChild(dom);\n                  dom.click();\n                  dom.parentNode.removeChild(dom);\n                  window.URL.revokeObjectURL(url);\n               $"],["base64转文档流",'$@ts@\n                // base64 编码的字符串\n                const base64String = "data:image/png;base64,iVBORw0KGg.....";\n                // 将 base64 编码的字符串转换为原始二进制数据\n                const binary = atob(base64String.split(",")[1]);\n                // 创建一个空的 Uint8Array\n                const array = new Uint8Array(binary.length);\n                // 将原始二进制数据拷贝到 Uint8Array 中\n                for (let i = 0; i < binary.length; i++) {\n                  array[i] = binary.charCodeAt(i);\n                }\n                // 创建一个新的 Blob 对象\n                const fileBlob = new Blob([array], {type: "application/octet-stream"});\n\n                // 创建一个新的 URL 对象\n                const url = URL.createObjectURL(file);\n                // 使用新的 URL 下载文件\n                window.location.href = url;\n              $',"***.注意上面的产生的[-Blob-]对象不是与[^input:file^]类型一样的文件流，使用[-File-]才是。","$@ts@\n                const base64ToFile = (base:string) => {\n                  let arr = base.split(',')!;\n                  // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec\n                  let mime = arr[0].match(/:(.*?);/)![1];\n                  let suffix = mime.split('/')[1];\n                  let bstr = atob(arr[1]);\n                  let n = bstr.length;\n                  let u8arr = new Uint8Array(n);\n                  while (n--) {\n                    u8arr[n] = bstr.charCodeAt(n);\n                  }\n                  return new File([u8arr], \"文件名\", { type: mime });\n                };\n              $"]]]]},{tit:"组件库",compare:[["组件库系列文章",[["怎样开发组件库","[@\\href{https://mp.weixin.qq.com/s/KWuL60xfI2nohx0-PpgYAQ?poc_token=HCWRJ2WjX7WCSvqvuluk8xBH5utv8-7tciSUoXg7}{如何开发一个人人爱的组件}]","[@\\href{https://mp.weixin.qq.com/s/82GAuTnjd1thQiKXWnS5JQ}{这才是现代 JavaScript 库打包指南！}]","[@\\href{https://mp.weixin.qq.com/s/J3wS_5hY9458GjJUP-2TbQ}{一文揭秘 Vue3 组件库的优雅打包与细节}]"],["组件库的本地调试","[@\\href{https://juejin.cn/post/7033400734746066957}{yalc: 可能是最好的前端link调试方案}]"]]]]},{tit:"Dom",compare:[["Dom性质属性",[["元素位置",["计算[_任意_两个元素]之间的[^间隔距离^]","*.[@\\href{https://cloud.tencent.com/developer/article/2101333}{获取元素到文档区域document的(横向、纵向)坐标的两种方法}]","[_循环递加_-offsetParent-]方法实现","$@js@\n                // 获取元素到文档区域的坐标\n                function getPosition(element) {\n                  var actualLeft = element.offsetLeft,\n                  actualTop = element.offsetTop,\n                  current = element.offsetParent; // 取得元素的offsetParent\n                  // 一直循环直到根元素\n                  while (current !== null) {\n                    actualLeft += current.offsetLeft;\n                    actualTop += current.offsetTop;\n                    current = current.offsetParent;\n                  }\n                  // 返回包含left、top坐标的对象\n                  return {\n                    left: actualLeft,\n                    top: actualTop\n                  };\n                }\n              $","$getBoundingClientRect()$方法实现","$@js@\n                // 获取元素到文档区域的坐标\n                function getPosition(element){\n                  var dc = document,\n                  rec = element.getBoundingClientRect(),\n                  _x = rec.left, // 获取元素相对浏览器视窗window的左、上坐标\n                  _y = rec.top;\n                  // 与html或body元素的滚动距离相加就是元素相对于文档区域document的坐标位置\n                  _x += dc.documentElement.scrollLeft || dc.body.scrollLeft;\n                  _y += dc.documentElement.scrollTop || dc.body.scrollTop;\n                  return {\n                    left: _x,\n                    top: _y\n                  };\n                }\n              $"]]]]]},{tit:"安全措施",compare:[["概念",[["浏览器安全","什么是同源策略","CORS:[CORS _预检请求_]","相关链接[@\\href{https://mp.weixin.qq.com/s/GkN8_jw74P0r2NpDpu-NYg}{post为什么会发送两次请求}]"]]]]}]},ts:{top:[["基本类型","字符串","数字"],["定义","常量定义","结构体、类定义","函数定义","引用其他函数、类、，或其他文件里的"],["复合类型","数组","引用","指针"]],article:[{tit:"类型的定义",compare:[["基础类型",[["有关字符串",["固定[前缀]的字符串","$@ts@\n                type a = `data-${string}`;\n                $"]],["枚举[enum]","*.数字枚举、字符串枚举、异构枚举",["反向映射","TS内的[枚举], 在编译的时候,会同时将[_key_和_value_]分别[|颠倒|]编译一次","只有[^非常量^枚举]才有","$@ts@\n                  enum Pages {\n                    ONE,  // 0\n                  }\n                  console.log(Pages.ONE)  // 0\n                  console.log(Pages[0])   // 'ONE'\n                $"],["常量枚举","*.$@ts@ const enum Pages {...}$","是在枚举的基础上,再加上[-const-关键字]来修饰","会在编译的时候, 把枚举内容删除, 只保留编译结果","[不支持]反向映射能力, 只能利用[key]来访问"]],["对象",["指定某些[可选属性]为[^属性必填^]",["用[-?问号-设置_可选只读_]，[|-|号]可以[移除-可选-和-只读readonly-]，所以将[可选]的属性进行传参。 实现思路具体如下：","[去除可选属性]得到新的对象类型（必填属性对象）","抽取出除去必填的属性生成新的代谢（可选属性对象）","交叉合并"],"$@ts@\n                  interface Employee {\n                    id?: number;\n                    name: string;\n                    salary?: number;\n                  }\n\n                  type WithRequiredProperty<Type, Key extends keyof Type> = Type & {\n                    [Property in Key]-?: Type[Property];\n                  };\n                $"],"让[所有]属性[_必选_]$Required<...>$","让[所有]属性[_可选_]$Partial<...>$"]]],["TS[类型]函数",[["字面量类型$@ts@<const>$",'$@ts@\n              // 把自己本身的值当作类型，而不是值所属于得类型。\n              const str = <const> "a";\n              let obj = <const> {a: "a", b: 4};\n              const arr = <const> ["a", 34];\n              obj.a = "b"; // 错误，只能 obj.a = "a"\n              type d = typeof obj;\n            $'],["有关$@ts@extend$的用法"],["$@ts@infer$类型函数里的变量",'$@ts@\n                type Replace <Str extends string, \n                From extends string, \n                To extends string> = \n                Str extends `${infer Left}${From}${infer Right}` ? \n                `${Left}${To}${Right}` : Str;\n                \n                type res = Replace<"哈哈你地方", "你", "我">\n              $']]]],compare1:[["数组",[["数组类型声明","通过$@ts@ ReadonlyArray<T>$声明的数组[不能]被修改","[对象]的普通属性[不可]赋值给[readonly]只读属性","数组[readonly]只读数组 [不可]赋值给常规数组","$@ts@arrType[number] 或 arrType[0]$获取[_数组成员_类型]","$@ts@\n                // 字面量方式声明数组\n                let myArr2: number[] = [20,30]\n\n                // 内置泛型方式\n                // 注释Array<> 使用的是泛型的<>  不是构造函数的()\n                let myArr3: Array<string> = ['hello', 'world']\n\n                let arr:string[] = ['无人机', '车辆','巡逻车']\n                let device: ReadonlyArray<string> = arr\n                // 可以简写为\n                let device2: readonly string[] = ['无人机', '车辆','巡逻车']\n\n                device[0] = '自行车'  // error\n                // 类型“readonly string[]”中的索引签名仅允许读取\n\n                device.push('aa')    // error\n                // 但是ReadonlyArray 类型的数组在新增时报错\n                // 类型“readonly string[]”上不存在属性“push”, 也及时没有push方法。\n              $"]]],["元组",[["特殊的Array类型","除了那些长度检查之外, 像这样[简单的元组类型]等价于[Array]为特定索引声明属性类型的版本, 同时[length]属性使用明确的数字文字类型声明","$@ts@\n              // 元组类型\n              type StringNumberArray = [string, number] \n\n              // 特殊的Array类型\n              interface StringNumberObj {\n                  length: 2\n                  0: string\n                  1: number\n              }\n            $"],["元组的其他属性","元组的[可选]属性","元组的[剩余]运算符,剩余运算符元素是[任意个],当然也包含[0]个, 因此类型中boolean类型的值可以没有","元组类型也有[readonly]只读类型,可以通过在元组前面添加$@ts@readonly$修饰符来指定","使用$@ts@as const$断言的数组,[TypeScript]会将其推断为[readonly]元组类型","$@ts@\n                // 可选元组类型\n                type OptionalTuple = [number,number, number?]\n\n                //其前两个元素分别是string和number，但后面可以有任意数量的boolean\n                type StringNumberBooleans = [string, number, ...boolean[]];\n                //第一个元素是string，中间任意数量的boolean类型,但结尾必须是number类型\n                type StringBooleansNumber = [string, ...boolean[], number];\n                //BooleansStringNumber元组，起始元素是任意数量的boolean类型,但结尾必须是string和number类型。\n                type BooleansStringNumber = [...boolean[], string, number];\n\n                function example(...args:[string,number,...boolean[]]){\n                    const [name,version,input] = args\n                    console.log('args',args)\n                    // parameter) args: [string, number, ...boolean[]]\n                }\n                function example(name:string,version:number,...input:boolean[]){\n                    //...\n                }\n                example('hello',10,true)\n\n                // 使用断言为const TypeScript将会推断为readonly [3,4]元组类型\n                let arr = [3,4] as const // let arr: readonly [3, 4]\n                arr[0] = 10 //  readonly 元组赋值报错\n                // 无法分配到 \"0\" ，因为它是只读属性\n              $"]]]],explain:[["怎样写类型文件",[["自定义的类型的文件",["给没有类型文件的模块，另起一个类型文件","通过声明该[-模块名称-(就是引入的_文件名_)]来定义","并且在$@ts@declare$声明里可以[引入_其他模块_]的类型","$@ts@\n                  declare module 'highlightjs-line-numbers2.js'  {\n                    import { HLJSApi } from \"highlight.js\"; \n                    export function init(obj:HLJSApi):void;\n                  }\n                $"],{tit:"在项目的[全局类型文件]里写,供整个项目使用",arr:["一般放在[|typings/|目录下],并且在[tsconfig.jons]里通过[file、include、exclude]字段来配置，这样就可以读取其目录下得所有类型文件，并且作为全局类型使用","一般命名[|globals.d.ts|文件名]","同时可以在这里[_重写_或_覆盖_或_扩展_]一些类型的声明，如下图同一个模块在其他两个库里面都定义过",si("js",2,"80")]},"$@ts@\n                  // globals.d.ts\n                  interface AnyObj {\n                    [k:string]: any;\n                  }\n\n                  // 覆盖 Immutable 模块里 fromJS的类型\n                  declare namespace Immutable {\n                    function fromJS<T, O>(\n                      jsValue: O,\n                      reviver?: (\n                        key: string | number,\n                        sequence: Collection.Keyed<string, unknown> | Collection.Indexed<unknown>,\n                        path?: Array<string | number>\n                      ) => any\n                    ): T;\n                  }\n                $",["在[其他]的类型文件里，使用$@ts@declare global$写[^全局^]的声明",'$@ts@\n                 // main.d.ts\n                 export interface INoticeItem {\n                    "model_id": string,\n                    "title": string,\n                  }\n                  // 不需要导出\n                  declare global {\n                    type IImmutalbeMap<\n                      DataType extends MapTypeAllowedData<DataType>,\n                      origin extends AnyObj = DataType\n                    > = ImmMap<DataType, origin>;\n\n                    interface Window {\n                      CKSource: {\n                        Editor: Editor & {create(e:HTMLElement, config?:EditorConfig):Editor},\n                      }\n                    }\n                  }\n                $'],["三斜线指令",["用法概念","描述[多个模块]之间的[_相互依赖_]关系","表示该声明文件依赖了$types='...'$中对于$...$的依赖，在进行了上述的声明后我们就可以在[自己的声明文件]中使用$types='...'$中声明的[变量]了","比如[-jquery-]中声明了对应的$@ts@declare namespace JQuery$",'$@ts@\n                /// <reference types="jquery" />\n                declare function foo(options: JQuery.AjaxSettings): string;\n                $'],["主要特别注意的是，如果使用了三斜线指令引入一个[^模块^]时",'比如$/// <reference types="axios" />$',"因为[-Axios-]是一个[模块]，所以我们[无法直接]在声明文件中使用任何[模块_内部_声明的变量]","之所以上边的用例能通过[三斜线指令]正常的使用[-JQuery-]全局变量，是因为在[jquery]的声明文件中声明了[^全局^的|namespcae JQuery|]"],["一个库是[模块文件]，但使用[使用三线指令]依赖的[模块]，[不是]模块声明文件，有全局的[namespace]。则用[三线指令]引入这个库时，三斜线指令并不会认为这个库是[模块]",'$@ts@\n                  // node_modules/@types/jquery/index.d.ts\n                  /// <reference types="sizzle" />\n                  /// <reference path="JQueryStatic.d.ts" />\n                  /// <reference path="JQuery.d.ts" />\n                  /// <reference path="misc.d.ts" />\n                  /// <reference path="legacy.d.ts" />\n                  export = jQuery;  \n                $','简单来说[jquery]根声明文件是一个[模块]，而它内部使用的[三斜线指令]引入的$@ts@/// <reference path="misc.d.ts" />$ 并非是一个[模块]而是声明了一个[全局命名空间]。'],"其中用到了[types]和[path]两种不同的指令。它们的[^区别^]是：[-types-]用于声明对[另一个_库_]的依赖，而[-path-]用于声明对[另一个_文件_]的依赖。"]]]],["类型文件的[^语法^]使用",[["声明语法",["[-declare-]声明","我们可以通过[declare]关键字结合对应的类型，从而在[任意|.d.ts|]中进行[-全局类型-]的声明","在[npm]包的声明文件中，使用[declare]不再会声明一个[_全局变量_]，而只会在[当前文件中]声明一个[-局部变量-]","模块内部通过$@ts@declare global$进行全局声明"],["[-namespace-和-module-、-三线指令-]的区别","$@ts@export namespace$用来导出一个拥有子属性的对象：","通常在我们可以利用$@ts@declare module$语法在进行[_新模块_的|声明|]的同时，也可以使用它来对于已有的[第三方库类型文件]进行类型文件的[|扩展|]。",["[模块-声明-和模块-扩展-]","模块声明：[declare]的是[|.js|]文件，[import]在里面","模块扩展：[declare]针对的是[_类型文件_]","$@ts@\n                  // 模块声明\n                  declare module 'highlightjs-line-numbers2.js'  {\n                    import { HLJSApi } from \"highlight.js\"; \n                    export function init(obj:HLJSApi):void;\n                  }\n                  // 模块扩展\n                  import { Chart as C } from \"./InsertChart\";\n                  declare module 'jodit/types/modules/index'  {\n                    export class Chart extends C  {}\n                  }\n                $"],"在进行[-模块扩展-]时，需要额外注意如果是需要[扩展^原有^模块]的话，需要在类型声明文件中[先引用]原有模块，再使用 $@ts@declare module$扩展原有模块。","通常，我们可以利用[-三斜线指令-]的[types]来声明对于全局变量的依赖，从而避免使用[import]语句将[_声明文件_变为_局部_模块。]"]],["使用事项","文件后缀使用[|.d.ts|]","使用$@ts@export$导出类型,在使用时再$@ts@import$导入","尽量少使用[^全局^]的类型，让每个使用的类型都有明显的[^出处^]","*需要注意的是[|d.ts|]的声明文件中[^禁止^定义具体的_实现_]"],["[@\\href{https://www.tslang.cn/docs/handbook/declaration-merging.html}{声明合并}]","接口合并","命名空间的合并","命名空间与其他的合并","将命名空间与类、函数和枚举合并","模块扩充","函数的合并","[@\\href{https://zhuanlan.zhihu.com/p/542379032}{声明拓展}]"],["[@\\href{https://zhuanlan.zhihu.com/p/45744835}{模块解析}]",["概念","[Typescript-模块解析-]就是指导[ts]编译器查找导入[import]内容的流程","模块解析供有两种策略：[-Classic-和-Node-]"],["[_export_与_import_]","当解析[import]导入的的时候，会优先选择[|.ts|]文件而不是[|.d.ts|]文件，以确保处理的是最新的文件","如果[^最顶上^不是import或者export]，这个文件就[不会]被当成一个[模块]，也就无法进行[模块扩展]，而是变成了[重新声明]一个模块。",'需要额外注意的是在[ts]中若要导入一个使用了$@ts@export=$的模块时，必须使用TypeScript提供的特定语法$@ts@import module = require("module")。$']]]]]},{tit:"实际应用",compare:[["React",[["*怎样通过[父组件]的属性的类型来[^限制^][子组件]的属性类型?"]]]]}]},css:{top:[["基本类型","字符串","数字"],["定义","常量定义","结构体、类定义","函数定义","引用其他函数、类、，或其他文件里的"],["复合类型","数组","引用","指针"]],article:[{tit:"css特殊概念用法",compare:[["概念",[["基础概念","特异性：就是[css权重]"],["position位置详解",["CSS 中的[静态定位]是什么","是每个元素的[_默认值_]","静态定位的元素[不受 |top、bottom、left 和 right|] 属性的[影响]。"],["CSS 中的[相对定位和绝对定位]是什么","relative 属性和 absolute 属性的工作原理是一样的，不同在于，我们使用 relative 来标识[^父类^]，使用 absolute 来标识[^子类^]。"],["CSS 中的[固定定位]是什么","这个值会将元素[^固定^]在屏幕上的某一位置，即使[浏览器发生_滚动_]"],["CSS 中的[粘性定位]是什么","当[滚动到]屏幕[某个点]后，这个值会将元素[固定在屏幕上]，不再移动。","[这个点]就是[_设置该属性_的元素的^位置^]时"]]]],["特别属性用法",[["背景：background","多重背景","[block]和[inline]元素在渐变设置下表现效果不一样","最佳实践：[@\\href{https://mp.weixin.qq.com/s/gNhhE7q1hbAmHC_1bk1oHg}{单标签下多色块随机文字随机颜色动画}]"],["css自动序号 —— 利用[-counter#reset-和伪类]","$@scss@\n              .par{\n                counter-reset: 名称;\n              }                      \n              .child:before {\n                content: counter(名称); \n                counter-increment:名称;\n              }\n              $"],["@starting-style 规则","[@\\href{https://mp.weixin.qq.com/s/lxWTSKOSSOCZtUSKAvk7QA}{快速了解 CSS @starting-style 规则}]","transition 需要有[_状态_的改变]才能触发过渡效果","animation 无需状态改变，因为可以自动运行","@starting-style 可以改变元素的初始状态，让元素在[_初次渲染_]也有过渡效果","@starting-style 可以在[元素添加时]直接添加过渡效果","@starting-style 可以让[|display:none|]也支持过渡","$@scss@\n                div{\n                  display: none;\n                  transition: 1s;\n                  transform: scale(0)\n                }\n                div.show{\n                  display: block;\n                  transform: scale(1)\n                }\n                /*仅需添加一个初始状态*/\n                @starting-style {\n                  div{\n                    transform: scale(0);\n                  }  \n                }\n              $"]]]]},{tit:"Scss语法",compare:[["函数",[["遍历函数",'$@scss@\n                  @import "compass/reset";\n\n                  // variables\n                  $colorGreen: #008000;\n                  $colorGreenDark: darken($colorGreen, 10);\n\n                  @mixin container {\n                      max-width: 980px;\n                  }\n\n                  // mixins with parameters\n                  @mixin button($color:green) {\n                      @if ($color == green) {\n                          background-color: #008000;\n                      }\n                      @else if ($color == red) {\n                          background-color: #B22222;\n                      }\n                  }\n\n                  button {\n                      @include button(red);\n                  }\n\n                  div,\n                  .navbar,\n                  #header,\n                  input[type="input"] {\n                      font-family: "Helvetica Neue", Arial, sans-serif;\n                      width: auto;\n                      margin: 0 auto;\n                      display: block;\n                  }\n\n                  .row-12 > [class*="spans"] {\n                      border-left: 1px solid #B5C583;\n                  }\n\n                  // nested definitions\n                  ul {\n                      width: 100%;\n                      padding: {\n                          left: 5px; right: 5px;\n                      }\n                    li {\n                        float: left; margin-right: 10px;\n                        .home {\n                            background: url(\'http://placehold.it/20\') scroll no-repeat 0 0;\n                      }\n                    }\n                  }\n\n                  .banner {\n                      @extend .container;\n                  }\n\n                  a {\n                    color: $colorGreen;\n                    &:hover { color: $colorGreenDark; }\n                    &:visited { color: #c458cb; }\n                  }\n\n                  @for $i from 1 through 5 {\n                      .span#{$i} {\n                          width: 20px*$i;\n                      }\n                  }\n\n                  @mixin mobile {\n                    @media screen and (max-width : 600px) {\n                      @content;\n                    }\n                  }\n                $']]]]},{tit:"动画",compare:[["概念",[["css补间动画和逐帧动画","补间动画：设置关键帧的初始状态，然后在另一个关键帧改变这个状态，比如大小、颜色、位置、透明度等，电脑将[自动]根据二者之间帧的值创建的动画。","逐帧动画：没有补间效果的，它不是电脑根据初始和结束状态的差异自动生成中间的过渡帧，而是每一帧都是关键帧，需要[自己定义]每一帧的状态。"],["实现方式",["Canvas","Canvas 通过[JavaScript]来绘制[2D]图形,内存占用恒定,只有一个[dom]节点,不支持事件处理器,弱的文本渲染能力","Canvas 是逐像素进行渲染的,依赖分辨率,随着屏幕大小的增大，[canvas]将开始降级，因为需要绘制更多的像素。","最适合图像密集型的游戏","一旦图形被绘制完成，它就不会继续得到浏览器的关注,如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象"],["div","包括[CSS]控制的DOM动画","[JS]控制的DOM动画"],["svg","处理矢量图，不失真,不依赖分辨率,支持事件处理器","随着屏幕上的[对象数目]增多，[SVG]将开始降级，因为我们正不断将这些对象添加到[DOM]中。"]]]]]}]},vim:li,svg:{top:[["基本类型","字符串","数字"],["定义","常量定义","结构体、类定义","函数定义","引用其他函数、类、，或其他文件里的"],["复合类型","数组","引用","指针"]],article:[{explain:[["svg",[]]]}]},node:{top:[["基本类型","字符串","数字"],["定义","流"],["复合类型","数组","引用","指针"]],article:[{tit:"流",explain:[["流的处理",[""]],["流的类型",[["什么是流？","[@\\href{https://www.cnblogs.com/Qooo/p/14097341.html}{流的定义}]"]]]]},{tit:"文件系统",compare:[["文件处理",["文件的各种操作"]]]}]},reg:{top:[["基本类型","字符串","数字"],["定义","常量定义","结构体、类定义","函数定义","引用其他函数、类、，或其他文件里的"],["复合类型","数组","引用","指针"]],article:[{tit:"位置匹配",explain:[["swvg",[["相关文章","[@\\href{https://blog.csdn.net/qq_41831345/article/details/100185589}{正则表达式位置匹配}]"]]]]},{tit:"模式匹配",explain:[["asdf",[]]]}]},utilPack:{top:[["打包",""],["设计"],["字体",""]],article:[{tit:"webpack",explain:[["配置",[["特别的配置","[@\\href{https://www.cnblogs.com/hanshuai/p/13524720.html}{webpack生产环境保留某些console.log}]"]]]],compare:[["插件",[]]]},{tit:"babel",compare:[["基础概念",[["系列文章","[@\\href{https://juejin.cn/post/7190312484492804156}{想弄懂Babel？你必须得先弄清楚这几个包}]","[@\\href{https://juejin.cn/post/7197666704435920957}{Babel配置详解}]"],["[|core-js|]与[|preset-env|]"]]]]},{tit:"vite",compare:[["配置",[]]]},{tit:"gulp",compare:[["配置",[]]]},{tit:"npm和yarn",compare:[["[-npm-]",[["运行",["[-NPM-]命令[^传递^]参数","*.[@\\href{https://blog.csdn.net/qq_33715850/article/details/123209669}{NPM 命令传递参数}]",["在命令行使用[-## ##-]","$@shell@ npm run dev -- --port=8099$","注意后面的参数必须是两个[|## ##|key=value]","然后在[_执行文件_]里使用$@js@ process.argv $获取所有参数","$@js@\n                    process.argv[0] // node执行文件路径\n                    process.argv[1] // 正在执行的JavaScript文件的路径\n                    process.argv[2] // 参数 key=value\n                  $"],["在[|package.scripts|]里用变量[|npm#1config_-key-|]接收，那个[key]是自己定义的",'$@json@\n                    {\n                      ...,\n                      "scripts":{\n                        "build": "node index.js "${npm_config_revision}""\n                      }\n                    }\n                  $',"$@shell@ npm run demo   --revision=1.2.3$","这种方法就是使用[-npm#1config_-]来[动态]获取[参数]"],["使用[-cross#env-]搭配[|scripts|]使用",'$@json@\n                    {\n                      ...,\n                      "scripts":{\n                        "build":"cross-env NODE_ENV=pro node index.js "${npm_config_revision}""\n                      }\n                    }\n                  $',"然后在[_执行文件_]里使用$@js@ process.argv $获取所有参数","$@js@\n                    console.log(process.argv);\n                    console.log(process.env.NODE_ENV); // pro\n                  $"]]]]],["[-yarn-]",[]]],explain:[["解释说明",[["--legacy-peer-deps解决[^依赖冲突^]","首先理解：[-peerDependency-、-devDependencies-和-dependencies-]","如果用户在根目录的[|package.json|]文件里[显式依赖了]核心库，那么各个子项目里的[peerDepenedencies]声明就可以[_忽略_]","如果用户[没有显式]依赖核心库，那么就按照子项目的[|peerDepenedencies|]中声明的版本将依赖安装到项目根目录里"]]]]},{tit:"git",compare:[["配置",[]]]}]}};var ui={basic:{top:[["考题程序设计","手写代码的规范","三段式的考题形式"],["定义及操作","结构体的定义",""],["算法","算法的复杂度分析","KMP算法"]],article:[{tit:"数据结构概念",explain:[["数据",[{tit:"*.数据结构的形式定义",arr:[["$@txt@\n                  #ADT = (D,S,P)\n                  ADT定义是一组逻辑特性描述\n                  [D]: 是数据对象\n                  [S]: 是D上的关系集\n                  [P]: 是对D的基本操作(算法)\n                  // ADT <抽象数据类型名> {\n                    数据对象：<数据对象的定义>\n                    数据关系：<数据关系的定义>\n                    基本操作：<基本操作的定义>\n                  }\n                  *数据对象和数据关系的定义采用[数学符号]和[自然语言]描述，*\n                  *也就是[伪代码]*\n                  基本操作的定义格式为：\\函数也就是这种格式由来\n                  <基本操作名>(参数表)\n                  初始条件：(初始条件描述〉\n                  操作结果：(操作结果描述〉 $"]]},["在试卷上写代码时，有些基本语句不用写","上面的，整个$int main()$函数都可以不用，只要有接口，也就是[功能函数],","[1-3],这些常用的定义语句也不需要","最终只需要","$\n                // 省略了函数主体内容，参照上面代码\n                void RCR(int R[], int n, int p);\n                void Reverse(int R[], int l, int r);\n              $"]]],["数据结构",["*.通常要求既要存储各[数据元素的数据]，又要存储[数据元素之间的逻辑关系]，数据元素在计算机内用一个结点来表示。",["逻辑结构",si("structrue",1,"90",!0)],["存储结构","[顺序]存储-线性。顺序存储结构是借助元素在存储器中的[相对位置]来表示，所有的元素依次存放在[一片连续]的存储空间中","[非顺序]存储-[链式]存储结构。而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加[指针字段]，用于存放[后继元素]的存储地址"],["应用","算法的[设计]取决于所选定的[逻辑结构]","算法的[实现]依赖于所采用的[存储结构]",["抽象数据结构[ADT]",'基本操作有两种参数：1. 赋值参数只为操作提供[输入值]；2. 引用参数以["&"]打头，除可提供输入值外，还将[返回操作结果]。',"[”初始条件”] 描述了操作执行之前数据结构和参数应满足的条件，若初始条件为空，则省略。","[”操作结果”] 说明了操作正常完成之后，数据结构的变化状况和应返回的结果","数据结构的运算:[增删改查]—[Create、Destroy、Delete、Insert、Access、Modify、Sort、Search]"]],["存储方法","顺序存储方法","链式存储方法","索引存储方法","散列存储方法"],["判断是否与数据的存储结构无关","只需要看这种结构到底有没有[具体]到使用[顺序存储]还是[链式存储]"]]]],note:["一般不要使用[c++]标准库里面提供的现成的方法，提倡用[C]实现","机试时用[C++]可以","用[C]去实现一些经典的算法","[1字节(Byte) = 8位(bit)]","线性表里，[字符串]和[广义表]不考"]},{tit:"算法概念",compare:[["算法",[["定义","算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。",["一个算法必须满足以下五个重要特性。","有穷性、确定性、可行性","输入。一个算法有零个或多个输入。","输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用[返回值]或[引用类型]的形参表示。"]],["评价","简单明了，[阅卷好阅]"],{tit:"算法分析",arr:[["时间复杂度","将算法中[基本操作]的[执行次数]作为算法时间复杂度的度量。","这里所讨论的时间复杂度不是执行完一段程序的总时间，而是其中基本操作的总次数。因此，对一个算法进行时间复杂度分析的要点，无非是明确算法中[哪些操作]是基本操作，然后计算出基本操作重复执行的次数即可。","在考试的算法题目中你总能找到一个[n]，可以称为[问题的规模]，如要处理的数组[元素的个数为n]，而基本操作所执行的次数是[n]的一个函数[f(n)](这里的函数是数学中函数的概念，不是C或C++语言中函数的概念)。对于求其基本操作执行的次数，就是求函数[f(n)]。","求出以后就可以取出[f(n)]中随[n]增大而增长[最快]的项，然后将其[系数变为1]，作为时间复杂度的度量，记为[T(n)=O(f(n))]中增长最快的项/此项的系数)。","例如，[@f(n)=2n^3+4n^2+100]，则其时间复杂度为[@T(n)=O(2n^3)=O(n^3)]。实际上计算算法的时间复杂度就是给出相应的[数量级]","*注意：有的算法中基本操作的执行次数不仅跟初始输入的数据规模有关，还和数据本身有关。例如，一些排序算法，同样有n个待处理数据，但数据初始有序性不同，则基本操作的执行次数也不同。一般依照使得基本操作执行次数最多的输入来计算时间复杂度，即将最坏的情况作为算法时间复杂度的度量。"],["空间复杂度","计算机在运行时所需存储空间大小的度量。记作[S(n) = O(f(n))]","包括[指令、 常数、 变量和输入数据]外，还需要一些对数据进行操作的[辅助存储空间](中间变量)，所以他是常量级的空间[O(1)]","一维数组[a(n)]：空间复杂度[O(n)]","二维数组[a(n)(m)]：空间复杂度[O(n*m)]","*主要考虑在算法运行过程中临时占用的存储空间的大小(和时间复杂度一样，以数量级的形式给出)"]]}]],["算时间复杂度",[{tit:"一般函数",arr:["$\n                for(i=2;i<=n;i++){\n                  for(j=2;j<=i-1;++j){\n                    ++x;\n                    a[i,j] = x;\n                  }\n                } \n                // i = 2, j =0, 计算 0\n                // i = 3, j =1, 计算 1\n                // i = 4, j =2, 计算 2\n                // i = n, j = n- 2, 计算 n - 2\n                // 总共： 1 +2 +3 + ... + n-2 $",["计算步骤","找基本操作,确定[规模n]","多数情况下取[最深层循环内]的语句所描述的操作作为基本操作","确定规模, 循环执行的次数","计算出[n]的函数[f(n)]",["修正参数[K]","方便计算重复的次数","比如[@i=1;\\;i+=2],则过了[m]次后，[i]的值与[n]相差[1],不够完成下一步，于是有[@1+2m+K = n]"]]]},{tit:"递归函数的时间复杂度",arr:[["$\n                    void mergesort(int arr[], int low ,int high){\n                    if(low < high){\n                      int mid = (low + high) / 2;\n                      mergesort(arr, low ,mid);\n                      mergesort(arr, mid,high);\n                      merge(arr, low, mid, high); // O(n)\n                    }\n                    }\n                  $","设$mergesort$的时间复杂度为[@T(n)]","则 [@T(n) = 2T(n/2) + O(n)](O(n)可等同于cn)","把[T(n/2)]用第2步的表达式带进去。得[@T(n) = 2(2T(n/2/2) + cn) + cn = 4T(n/4)+2cn]","再把[@T(n/2/2)]用第二步得表达式带进去，得[@T(n) =  = 2^3T(n/2^3) + 3cn]","得出[T(n) =  = 2^kT(n/2^k) + kcn]","[@k]越大，[@n/k]越小，[n/k<=1]时，相当于 [@low > higt] ,只执行一条语句。","令[@T(1) = c (常数),当 n 为 1 时，显然是一个常数]，得出[@ n/2^k = 1, k = log_2 n],则[T(n) = cn + cnlog_2 n]","[@T(n) = O(nlog n)]（对数的底数可不计,不影响）",si("consist",7,"50",!0)]]}]]]},{tit:"字符串",compare:[["结构类型",[]],["算法应用",[{tit:"KMP算法",arr:["对于模式串[t]，在发现不匹配时，若[t]往后移动[x]个位置后","此时[比较指针](指向模式串和主串要比较的位置的指针)的左边的长度，应该是模式串中，最长[相同前后缀]的长度，可以是[0]。","认真理解这句话，就可以很好明白怎么获取模式串的[next]数组",si("structrue",51,"63",!0),`${si("structrue",52,"55",!0)}<span style="display:inline-block;width: 40%">${si("structrue",53,"100",!0)}${si("structrue",54,"100",!0)}</span>`,"*.[next]数组和存放模式字符串的数组，第[0]位都不放数据。","$\n                void getNextArr(Str subStr, int &next[]){\n                  int i = 1, // 用于next的索引\n                  j = 0;     // 用于当前subStr索引所对应的 最大公共前后缀的长度 + 1\n                  next[1] = 0; // 注意 为0是特殊情况，代表主串索引指针往下移动，从下个位置与模式串第一个字符比较。其他都是当前位置与模式串比较\n                  while(i < subStr.length){\n                    //在模式串中，找出当前位置F的相同前缀F_t与后缀F_j，\n                    if(j == 0 || subStr.str[i] == subStr.str[j]){\n                      // 若是F_t+ 1 == F_j+ 1 ，说明相同部分又增加了一位 \n                      i++; \n                      j++;\n                      next[i] = j;\n                    }else{\n                      // 若是F_t+ 1 != F_j+ 1 ，则又可以把F 当作是一个主串， F_t是模式串，递归式的回到原本的问题上。 而j < i,所以next[j]肯定是存在的\n                      j = next[j]\n                    }\n                  }\n                }\n              $"]}]]]},{tit:"数组",compare:[["矩阵",[["邻接表示法",si("structrue",48,"60")],["十字链表表示法",si("structrue",47,"60")]]],["广义表",[["存储结构",si("structrue",49,"60",!0),si("structrue",50,"60",!0)]]]]}]},treeBinary:{top:[["考题程序设计","*二叉树的确定","二叉树表达式求值","二叉树的估计"],["核心","完全二叉树","*线索二叉树","二叉排序树","*赫夫曼树和赫夫曼编码","森林与二叉树的转换"],["算法","*二叉树的遍历算法","克鲁斯卡尔"]],article:[{tit:"二叉树基础知识",explain:[["存储结构",[["树的存储结构",["顺序存储结构","简单的定义$inttree[maxSize]$，即用一个[整型数组]就可以存储一棵树的信息","用数组[下标]表示树中的结点，数组元素的[内容]表示该结点的[双亲结点]，这样有了结点(下标)以及结点之间的关系(内容)，就可以表示一棵树了",si("structrue",13,"60"),"*用这种存储结构来存储的树，当知道一个结点后就很容易找到其双亲结点，因此称为[双亲存储结构]","树的双亲存储结构在[克鲁斯卡尔]算法中有重要应用。"],["链式存储结构","孩子存储结构:图的[邻接表]存储结构","孩子兄弟存储结构：与[树和森林与二又树]的相互转换关系密切"]],["二叉树",{tit:"二叉树性质",arr:[["性质1 非空二叉树上[叶子结点数](度为0)等于[双分支](度为2)结点数加1。","证明:设二叉树上叶子结点数为[@n_0],单分支结点数为[@n_1],双分支结点数为[@n_2]则总绪点数为[@ n_0+n_1+n_2];。","在一棵二叉树中，[所有结点]的[分支数]等于单分支结点数加上双分支结点数的两倍，即总的分支数为[@ n_1十2n_2]。","由于二又树中除根结点之外，每个结点都有[唯一]的一个分支[指向它]，因此二又树中有总分支数=总结点数-1〈显然这一条结论对于任何树都是适用的，而不仅仅是针对二又树)。","由此可得:[@ n_0+n_1+n_2-1=n_1+2n_2]，化简得:[@ n_0=n_2+1]"],["性质2 二叉树的第[i]层上最多有[@2^{i-1}， i\\geqslant 1 ]个结点","结点最多的情况即为[满二叉树]的情况，此时二叉树每层上的结点数构成了一个首项为[1]、公比为[2]的等比数列。通项为[@2^{i-1}]，[i]为层号。"],["性质3 高度(或深度)为[k]的二叉树最多有[@2^k-1\\;(k\\geqslant 1)]个结点。换名话说，满二叉树中前[k]层的结点个数为[@2^k-1]","其实本条性质描述的即为[性质2]中[等比数列]的[前k项和]的问题，由等比数列的求和公式可得结果，即[@\\dfrac{1-2^k}{1-2}=2^k-1]"],["性质4 有[n]个结点的[完全二叉树]，对各结点从上到下、从左到右依次编号〈编号范围为[@1\\backsim n]，则结点之间有如下关系。若[i]为某结点[a]的编号，则:","如果话[@i\\neq 1]，则[a]双亲结点的编号为[⌊i/2⌋]","如果[@2i\\leqslant n]，则[a左孩子]的编号为[2i];如果[@2i>n]，则[a无]左孩子。","如果[@2i+1\\leqslant n]，则[a右孩子]的编号为[2i+1];如果[@2i+1>n]，则[a无]右孩子。","*.编号从[0]开始，计算方法为:某结点[a]的编号为[i],则其[左孩子]结点编号为[2i+1]，[右孩子]结点编号为[2i+2];[a]的[双亲结点]编号为[@⌈i/2⌉ -1]。"],"性质5 函数[Catalan()]: 给定[n]个结点，能构成[h(n)]种不同的二叉树，[@\\dfrac{C_{2n}^n}{n+1}]",["性质6 具有[@n(n\\geqslant 1)]个结点的[完全二叉树]的高度(或深度)为[@⌊\\log_2n⌋+1]。","证明，由[性质3]可知[@ 2^{h-1} -1 < n \\leqslant 2^h-1]，其中[h]为完全二叉树的高度。又可以写为[@2^{h-1} < n \\geqslant 2^h]","对其取对数得[@h-1\\leqslant \\log_2n<h],由于[h]为整数","因此对[@\\log_2n]向下取整即得到一个等式:[@h-1=⌊\\log_2n⌋]，即[@h=⌊\\log_2n⌋+1]","*.说明:上述完全二又树高度公式是在考研数据结构中出现最多的形式，但有些学校的考题中，尤其是选择题中给出的表达式是:[@h=⌈ \\log_2(n+1)⌉]"]]},{tit:"二叉树的存储结构",arr:[["顺序存储结构","顺序存储结构即[用一个数组]来存储一棵二叉树，这种存储方式最适合于[完全二叉树]，用于存储一般二叉树会当费大量的存储空间。","将完全二叉树中的结点值按编号依次存入一个一维数组$BTree[]$中，即完成了一棵二又树的顺序存储。",si("structrue",16,20)],["链式存储","顺序存储结构不便于存储[任意形态]的二叉树。因此设计了含有[一个数据域]和[两个指针域]的链式结点结构，具体如下，",si("structrue",17,20),"[data]表示数据域，用于存储对应的数据元系;[lchild]和[rchild]分别表示[左指针域]和[右指针域]，分别用于存储左孩子结点和右孩子结点的[位置]","$\n                    typedef struct BTNode \n                    {\n                      char data;\n                      struct BTNode *lchild;\n                      struct BTNode *rchild;\n                    }BTNode:\n                  $",si("structrue",18,"76")]]}]]],["基本概念",[["树的基本术语","结点","结点的[度]:结点拥有的子树个数或者分支的个数","树的度:树中各结点度的最大值","叶子结点:又叫作终端结点,指度为[0]的结点","非终端结点","孩子、双亲、兄弟","祖先、子孙","层次:从根开始，根为第一层，根的孩子为第二层，根的孩子的孩子为第三层，以此类推。","树的高度(或者深度)",["结点的深度和高度","结点的深度:从根结点到该结点[路径上]的[结点个数]。","结点的高度:结点到达[最深的]子节点的所经过的节点数","根结点的高度为树的高度"],"堂兄弟:双亲在同一层的结点互为堂见弟","有序树:树中结点的子树从左到右是有次序的，不能交换","无序树:树中结点的子树没有顺序，可以任意交换","丰满树:丰满树即理想[平衡树]，要求除最底层外，其他层都是[满的]","森林:若干棵互不相交的树的[集合]"],["树的性质","树中的[结点数]等于[所有]结点的[度数之和]加[1]","度为[m]的树中第[i]层上至多有[@m^{i-1}]个结点[@i \\geqslant 1)]。","高度为[h]的[m]叉树至多有[@\\dfrac{m^h-1}{m-1}]个结点。","具有[n]个结点的[m]叉树的最小高度为[@\\left⌈\\log_m\\big(n(m-1)+1\\big)\\right⌉]"],["二叉树",["定义","每个结点最多只有两棵子树，即二叉树中[结点的度]只能为0、1、2","子树有[左右顺序]之分，不能颠倒","[双分支]：两个儿子；[单分支]：一个日子，[叶子结点]：没有儿子。","五种形态",si("structrue",14,"",!0)],["特殊二叉树","[满]二叉树:[所有]的分支结点都有左孩子和右孩子结点，并且[叶子结点]都集中在二叉树的最下一层","[完全]二叉树:一棵完全二又树一定是由一课[满二叉树]从右至左、从下至上[挨个]删除结点所得到的。如果[跳着]删除，则得到的不是完全二叉树",si("structrue",15,"",!0),"*.如图，如果删除结点[G和F]，则得到一棵完全二叉树。如果跳着删除，即不删除G，[直接删除]F，则得到的不是完全二叉树",["二叉[排序]树:","[左子树]上所有结点的关键字均[小于]根结点的关键子","[右子树]上的所有结点的关键字均[大于]根结点的关键字","左子树和右子树又各是一棵二叉排序树。"],"[平衡]二又树: 树上任一结点的[左子树]和[右子树]的[深度之差]不超过[1]"],["草图构建完全二叉树","已知[10]个叶结点，画完全二叉树","首先画出[10]个叶结点","然后每[2]个结点向上[合并]","构造一个新的度为[2]的分支结点直到构成如图所示的二又树",si("structrue",20,"80",!0)]]]]],note:["*完全二叉树中,[@n_1]只能取[0]或[1]","对于二叉链表存储结构,[1个]指针对应[1个]分支，[n]个结点的树共有[n-1]个分支，即[n-1]个非空指针，每个结点有[2个]指针域，故空指针数[2n-(n-1)=n+1]","已知完全二叉树有[n]个节点，最后一个[分支节点](非叶节点)的序号[@⌊n/2⌋]",["对于[后序线索二叉树]的遍历,数据结构中出现的题目最多的是手工找出当前结点的[后继]，因此大家只需记住以下3点即可","若结点[X]是二叉树的[根]，则其[后继]为[空]。","若结点[X]是其双亲的[右孩子]，或是其双亲的[左孩子]且其双亲[没有]右子树，则其[后继]即为双亲结点","若结点[X]是其双亲的[左孩子]，且其双亲有[右子树]，则其[后继]为双亲右子树上按[后序遍历]列出的[第一个]结点。"],["线索二叉树里非叶节点[找]前驱、后继","因为二叉树的[链表]存储结构没有存结点的[父节点]指针,所以在线索二叉树中，只要是找[父]节点的都不行。","在[先序]线索二又权中查找一个结点的先序[后继]很简单，就算其左孩子(左指针)，而查找先序[前驱]必须知道该结点的[双亲结点","在[后序]线索二又树中查找一个结点的后序[前驱]也很简单,，而查找后序[后继]也必须知道该结点的[双亲]结点",si("structrue",44,15)]],compare:[["二叉树的遍历算法",[{tit:"深度优先算法",arr:[si("structrue",19,"50"),["先序遍历","如果二叉树为空树，则什么都不做，否则，","访问[根节点]。","先序遍历[左子树]。","先序遍历[右子树]。","$\n                      void preorder (BTNode *p){\n                        if(p != NULL){\n                          Visit(p); //包含对结点p的各种操作\n                          preorder(p->lchild);\n                          preorder(p->rchild);\n                        }\n                      }\n                    $"],["中序遍历","如果二叉树为空树，则什么都不做，否则","中序遍历[左子树]。","访问[根结点]。","中序遍历[右子树]。","$\n                      void inorder (BTNode *p){\n                        if(p != NULL){\n                          inorder(p->lchild);\n                          Visit(p); //包含对结点p的各种操作\n                          inorder(p->rchild);\n                        }\n                      }\n                    $"],["后序遍历","如果二叉树为空树，则什么都不做，否则","后序遍历[左子树]。","后序遍历[右子树]。","访问[根结点]。","$\n                      void postorder (BTNode *p){\n                        if(p != NULL){\n                          postorder(p->lchild);\n                          postorder(p->rchild);\n                          Visit(p); //包含对结点p的各种操作\n                        }\n                      }\n                    $"],si("structrue",28,"")]},["广度优先-层次遍历",si("structrue",21,"40"),"如图所示为二叉树的层次遍历，即按照箭头所指方向","按照[1、2、3、4]的层次顺序，对二叉树中各个结点进行访问。的是自左至右的层次遍历，自右至左的方式类似。","要进行层次遍历，需要建立一个[循环队列]。","先将二叉树[头节点]入队列，然后[出队列]，访问该结点","如果它有左子树，则将左子树[根结点]入队","如果它有右子树，则将右子树的[根结点]入队","然后出队列，对出队结点访问。如此反复，直到队列为空为止。",{tit:"*.层次遍历代码",arr:["$\n                      void level(BTNode *p){\n                          int front,rear;\n                          //定义一个循环队列，用来记录将要访问的层次上的结点\n                          BTNode *que[maxsize];\n                          front=rear=0;\n                          BTNode *q;\n                          if(p!=NULL){\n                            //根结点入队\n                            rear=(rear+1)%maxSize; \n                            que[rear]=p;\n                            while(front!=rear){ //当队列不空时进行循环\n                              front=(front+1) % maxSize;\n                              q=que[front]; //队头结点出队\n                              Visit(q); //访问队头结点\n                              //如果左子树不空，则左子树的根结点入队\n                              if(q->lchild!=NULL){ \n                                rear=(rear+1) % maxSize;\n                                que[rear]=q->lchild; \n                              }\n                              //如果右子树不空，则右子树的根结点入队}\n                              if(q->rchild!=NULL){\n                                rear=(rear+1)%maxsize;\n                                que[rear]=q->rchild; \n                              }\n                            }\n                          }\n                        }\n                      $"]}]]],["遍历改进",[["非递归遍历","*.主要任务就是用[自己定义的栈]来代替[系统栈]的功能",si("structrue",25,14,!0),{tit:"*.先序遍历",arr:[si("structrue",22,"",!0),"$\n                 void preorderNonrecursion(BTNode *bt){\n                  if(bt!=NULL){\n                    BTNode * Stack[maxSize];\n                    int top = -1; //初始化栈\n                    BTNode *p;\n                    Statck[++top] = bt; //根节点入栈\n                    while(top!=-1){ //栈空循环退出,遍历结束\n                      p=Stack[top--]; //出栈并输出栈顶节点\n                      Visit(p);\n                      if(p->rchild!=NULL){\n                        Stack[++top] = p->rchild;\n                      }\n                      if(p->lchild!=NULL){\n                        Stack[++top] = p->lchild;\n                      }\n                    }\n                  }\n                 }    \n                $"]},{tit:"*.中序遍历",arr:[si("structrue",23,"",!0),`$\n                 void inorderNonrecursion(BTNode *bt){\n                  if(bt!=NULL){\n                    BTNode * Stack[maxSize];\n                    int top = -1; //初始化栈\n                    BTNode *p;\n                    p = bt;\n                    //注意如图所示,出栈的过程在第${(0,i.hj)(6)}中会出现空栈的状态,但这时遍历还没有结束,因根节点的右子树还没有遍历,此时p非空,根据这一点维持循环的进行\n                    while(top!=-1 || p!=NULL){\n                      while(p!=NULL){ //左孩子存在,则左孩子入栈\n                        Stack[++top] = p;\n                        p=p->lchild;\n                      }\n                      if(top!=-1){ //在栈不空时,输出出栈节点\n                        p = Statck[top--];\n                        Visit(p);\n                        p=p->rchild;\n                      }\n                    }\n                  }\n                 }    \n                $`]},{tit:"*.后序序遍历",arr:[si("structrue",24,"70"),["*分析","[逆后序]遍历是[先序遍历]中对左、右子树遍历[顺序交换]所得到的结果","所以需要两个栈,一个栈[stack1]用来辅助做逆后序遍历","并将遍历结果序列压入另一个栈[stack2]","然后将[stack2]中的元素全部出栈，得到的序列就是后序遍历序列"],"$\n                 void postorderNonrecursion(BTNode *bt){\n                  if(bt!=NULL){\n                    //定义两个栈\n                    BTNode * Stack1[maxSize]; int top1=-1;\n                    BTNode * Stack2[maxSize]; int top2=-1;\n                    BTNode *p = NULL;\n                    Stack1[++top] = bt;\n                    while(top1!=-1){\n                      p=Stack1[top--];\n                      Stack2[++top2] = p; //注意这里和先序遍历的区别,输出改为Stack2\n                      //注意下面这两个if语句和先序遍历的区别,左、右孩子的入职顺序相反\n                      if(p->lchild!=NULL){\n                        Stack1[++top1] = p->lchild;\n                      }\n                      if(p->rchild!=NULL){\n                        Stack1[++top1] = p->rchild;\n                      }\n                    }\n                    while(top2!=-1){\n                      //出栈序列即为后序遍历序列\n                      p=Stack2[top2--];\n                      Visit(p);\n                    }\n                  }\n                 }    \n                $"]}],["线索二叉树",["由来","非递归遍历算法[避免]了系统栈的调用，提高了一定的执行效率。","[线索二叉树]可以将[用户栈]也省掉，把二叉树的遍历过程[线性化]，进一步提高了效率。","[n]个结点的二叉树有[n+1]个空链域，能不能把这些[空链域]有效地利用起来，以使二叉树的遍历更加高效呢?答案是肯定的，这就是线索二叉树的由来。","在一般的二叉树中，我们只知道某个结点的[左、右]孩子，并不能知道某个结点在某种遍历方式下的[直接前驱]和[直接后继]","如果能够知道[前驱]和[后继]信息，就可以把二叉树看作一个[链表结构]，从而可以像遍历链表那样来遍历二叉树，进而提高效率。","这对[经常]需要进行遍历操作的二叉树而言，无疑是很有用的。"],{tit:"中序线索二义树解析",arr:[["构造",si("structrue",26,"80"),"*.在二叉树[线索化]的过程中会把树中的[空指针]利用起来作为寻找当前结点[前驱]或[后继]的线索","这样就出现了一个问题，即[线索]和树中原有指向孩子结点的[指针]无法区分。上面的结点设计就是为了区分这两类指针",["其中$ltag$和$rtag$为标识域，它们的具体意义如下","如果$ltag=0$，则表示$lchild$为[指针]，指向结点的[左孩子];如果$ltag=1$，则表示$lchild$为[线索]，指向结点的[直接前驱]","如果$rtag=0$，则表示$rchild$为[指针]，指向结点的[右孩子];如果$rtag=1$，则表示$rchild$为[线索]，指向结点的[直接后继]"],"$\n                      typedef struct TBNode{\n                        char data;\n                        int ltag, rtag; //线索标记\n                        struct TBNode *lchild;\n                        struct TBNode *rchild;\n                      } TBTNode;\n                    $","对一棵二叉树中所有结点的[空指针域]按照某种遍历方式[加线索]的过程叫作[线索化],被线索化了的二叉树称为线索二又树",si("structrue",27,"",!0)],["分析","既然要对二叉树进行中序线索化,首先要有[中序遍历]的框架,这里采用二叉树[中序递归]遍历算法，在遍历过程中[连接上]合适的线索即可",["线索化的规则是","图中的中序遍历序列为[@B\\rightarrow D\\rightarrow A\\rightarrow E\\rightarrow C]","[左线索]指针指向当前结点在[中序遍历序列]中的[前驱结点],[右线索]指针指向[后继结点]。","因此我们需要一个指针[p]指向当前正在访问的结点","[pre]指向[p]的前驱结点,[p]的左线索如果存在则让其指向[pre]，[pre]的右线索如果存在则让其指向[p]","因为[p]是[pre]的后继结点，这样就完成了一对线索的连接。","按照这样的规则一直进行下去，当整棵二叉树[遍历完成]时，线索化也就完成"],"上一步中保持[pre]始终指向[p]前驱的具体过程是，当p将要离开一个访问过的结点时，[pre]指向[p],当[p]来到一个新结点时，[pre]显然指向的是此时[p]所指结点的[前驱结点]。"]]},{tit:"*.中序线索二义树",arr:["线索化","$\n                          void InThread(TBTNode *p,TBTNode *&pre){\n                            if(p!=NULL){\n                              InThread(p->rchild, pre); //递归，左子树线索化\n                              if(p->lchild == NULL){ //建立当前结点的前驱线索\n                                p->lchild = pre;\n                                p->ltag=1;\n                              }\n                              if(pre!=NULL && pre->rchild ==NULL){//建立当前结点的后继线索\n                                pre->rchild=p;\n                                pre->rtag=1;\n                              }\n                              pre=p; // pre指向当前的p,作为p将要指向的下一个结点的前驱结点指示指针\n                              p=p->rchild;//p指向一个新结点，此时pre和p分别指向的结点形成了一个前驱后继，为下一次线索的连接做准备\n                              InThread(p,pre);//递归，右子树线索化\n                            }\n                          }\n                        $","主程序","$\n                  void createInThread(TBTNode *root){\n                    TBTNode *pre=NULL; //前驱结点指针\n                    if(root!=NULL){\n                      InThread(root,pre);\n                      pre-rchild=NULL;\n                      pre->rtag=1;\n                    }\n                  }\n                  $","求以[p]为根的[中序线索]二叉树中，中序序列下的[第一个]结点","$\n                    TBTNode *First(TBTNOde *p){\n                      while(p->ltag==0){\n                        p=p->lchild; //最左下的结点\n                      }\n                      return p;\n                    }\n                  $","求在中序线索二叉树中，结点[p]在中序下的后继节点","$\n                    TBTNode *Next(TBTNOde *p){\n                      if(p->rtag==0){\n                        return First(p->rchild);\n                      }else{\n                        return p->rchild; //直接返回后继线索\n                      }\n                    }\n                  $","在中序线索二叉树上执行[中序遍历]的算法:","$\n                    void Inorder(TBTNode *root){\n                      for(\n                        TBTNode *p=First(root);\n                        p!=NULL; \n                        p=Next(p)\n                      ){\n                        Visit(p);\n                      }\n                    }\n                  $"]},{tit:"*.前序线索二叉树",arr:["线索化","*.前序线索化代码和中序线索化代码极为相似，最大的[区别]是把连接线索的代码[提到]了两递归[入口]的，这也符合先序递归遍历的框架。","$\n                    void preThread(TBTNode *p, TBTNode *&pre){\n                      if(p!=NULL){\n                        if(p->lchild == NULL){ \n                          p->lchild = pre;\n                          p->ltag=1;\n                        }\n                        if(pre!=NULL && pre->rchild ==NULL){\n                          pre->rchild=p;\n                          pre->rtag=1;\n                        }\n                        pre=p; \n                        // 注意这里再递归入口处有限制条件，左、右指针不是线索才继续递归\n                        if(p->ltag==0){\n                          preThread(p->rchild,pre);\n                        }\n                        if(p->rtag==0){\n                          preThread(p->lchild,pre);\n                        }\n                      }\n                    }\n                  $","执行前序遍历","$\n                    void preorder(TBTNode *root){\n                      if(root!=NULL){\n                        TBTNode *p=root;\n                        while(p!=NULL){\n                          while(p->ltag==0){ //左指针不是线索，则边访问边左移\n                            Visit(p);\n                            p=p->lchild;\n                          }\n                          Visit(p); //此时p左指针必为线索,但还没有被访问，则访问\n                          p=p->rchild;//此时p左孩子不存在，若右指针非空，则不论是否为线索都指向其后继\n                        }\n                      }\n                    }\n                  $"]},{tit:"*.后序线索二叉树",arr:["线索化","*.后序线索化代码和[中序线索化]代码极为相似，最大的[区别]是把连接线索的代码放到了两递归入口的[后面]","$\n                    void postThread(TBTNode *p, TBTNode *&pre){\n                      if(p!=NULL){\n                        postThread(p->lchild,pre);\n                        postThread(p->rchild,pre);\n                        if(p->lchild == NULL){ //建立当前节点的前驱线索\n                          p->lchild = pre;\n                          p->ltag=1;\n                        }\n                        if(pre!=NULL && pre->rchild ==NULL){ //建立前驱节点的后继线索\n                          pre->rchild=p;\n                          pre->rtag=1;\n                        }\n                        pre=p; \n                      }\n                    }\n                  $"]}],si("structrue",45,"",!0)]]]},{tit:"树和森林",explain:[["树和森林的遍历",[si("structrue",36,"60"),["树的结点定义","$\n                typedef struct Branch{\n                  int cIdx;\n                  Branch* next;\n                } Branch;\n                typedef struct {\n                  int data;\n                  Branch* first;\n                } TNode;\n\n                TNode tree[10] // 定义一棵树\n                Branch* q= tree[0]->first; //根结点的分支\n                tree[q->cIdx]; //根结点的分支的第一个结点\n              $"],{tit:"树的遍历",arr:[["先序遍历","先访问根结点，然后先序遍历每一棵子树","先序遍历的结果为[A、B、E、F、C、G、D、H、I、j]","$\n                    void preOrder(TNode* p, TNode tree[]){\n                      if(p!=NULL){\n                        visit(p);\n                        Branch* q;\n                        q=p->first;\n                        // 和二叉树不同的地方，循环遍历子结点\n                        while(q!=NULL){\n                          preOrder(&tree[q->cIdx], tree);\n                          q=q->next;\n                        }\n                      }\n                    }\n                  $"],["后序遍历","先后序遍历[根结点]的每一棵子树，然后再访问根结","后序遍历的结果为[E、F、B、G、C、H、I、J、D、A]","$\n                    void postOrder(TNode* p, TNode tree[]){\n                      if(p!=NULL){\n                        Branch* q;\n                        q=p->first;\n                        // 和二叉树不同的地方，循环遍历子结点\n                        while(q!=NULL){\n                          postOrder(&tree[q->cIdx], tree);\n                          q=q->next;\n                        }\n                        visit(p);\n                      }\n                    }\n                  $"],["层次遍历","$\n                    void level(TNode* tn, TNode tree[]){\n                      int front, rear;\n                      TNode *que[maxSize];\n                      front = rear = 0;\n                      TNode* p;\n                      if(tn != NULL){\n                        rear = (rear + 1) % maxSize;\n                        que[rear] = tn;\n                        while(){\n                          front = (front + 1) % maxSize;\n                          p = que[front];\n                          visit(p);\n                          Branch* q = p->first;\n                          while(){\n                            rear = (rear + 1) % maxSize;\n                            que[rear] = &tree[q->cIdx];\n                            q=q->next;\n                          }\n                        }\n                      }\n                    }\n                  $"],"*.树[转换]为二叉树后,树的[先序遍历]对应二叉树的[先序遍历],树的[后序遍历]对应二叉树的[中序遍历]"]},{tit:"森林的遍历",arr:["森林的遍历方式有两种:先序遍历和后序遍历。","先序遍历的过程:[先访问]森林中第一棵树的根结点，然后[先序遍历]第一棵树中根结点的子树，最后先序遍历森林中除了第一棵树以外的其他树。","后序遍历的过程:[后序]遍历第一棵树中根结点的子树，然后访问第一棵树的根结点，最后[后序遍历]森林中除去第一棵树以后的森林。","在森林转换为二叉树的过程中，森林的[先序遍历]对应二叉树的[先序遍历]，森林的[后序遍历]对应二叉树的[中序遍历]。"]}]],["树和二叉树相互转化",[{tit:"树转化为二叉树",arr:[["用[二叉链表]存储树","结点中一个指针(假设叫[child])指向一个[孩子]，另一个指针(假设叫[sibling])指同自己的[兄弟结点]","如图所示，最左边是一棵树，最右边是这棵树转化为二叉树后存储在[二叉链表]中的情形。","可以看到,[A]结点的[child]指向了自己的一个孩子[B]结点,[A]结点[没有]兄弟结点,因此[sibling]为空","再看[B]结点，[B]没有孩子结点，因此[child]为[空]，[B]的[sibling]指向了自己的兄弟结点[C]。","如果要找到[A]的孩子结点[D]，只需要$A->chilid->sibling->sibling$即可。",si("structrue",29,"",!0)],["转化为二叉树的过程","将同一节点的各孩子结点用线串起来","除了[第一个]结点以外，其余结点的分支从[左往右]都剪掉",si("structrue",30,"",!0),"调整续点使之符合二又树的层次结构",si("structrue",31,"",!0)]]},{tit:"二叉树转换为树",arr:["先把它从[左上到右下]分为若干层.如[A]是一层，[B、C、D]是一屋，[E、F]是一层,然后调整成水平方向","找到每一层结点在其上一层的父结点,如结点[E、F]在上一层的父结点为[C]","将每一层的结点和其[父结点]相连",si("structrue",32,"",!0)]},{tit:"森林转化为二叉树",arr:[["分析","可以看作由原来的一棵树扩展为多棵树的转化","根据[孩子兄弟表示法]的规则,由于树的根节点一定是[没有]右兄弟的，因此转换为二叉树后，根结点一定是没有右孩子的","那么可以将根节点这个空出来的[右孩子指针]利用起来，即将森林中[第二棵树]转换的二叉树当作[第一棵树根]的[右子树]，第三棵树当作第二棵的右子树。"],["森林转换为二叉树的过程",si("structrue",33,"70",!0),si("structrue",34,"70",!0),si("structrue",35,"70",!0)]]},{tit:"二叉树转化为森林",arr:["只需要不停地将[根结点]有右孩子的二叉树的右孩子链接[断开]","直到不存在[根结点]有右孩子的二叉树为止","然后将得到的二叉树按照[二叉树转化为树]的规则依次转化即可"]}]]]},{tit:"赫夫曼树和赫夫曼树编码",note:[["赫夫曼编码-最短前缀码","编码过程中，每个字符的[权值]是在字符串中[出现的次数]，路径长度即为每个字符[编码的长度]，出现[次数越多]的字符编码[长度越短]","因此就使得其整个字符串被编码后的[前缀码]长度最短。这里就引出了另一个重要结论，赫夫曼编码产生的是[最短前缀码]。"],"对于[同一组]结上点，构造出的赫夫曼树可能[不是唯一的]，但是对于同一组结点，只要按照赫夫曼树以及前缀码的构造规则，得到的赫夫曼树[WPL]都是[相同的]，得到的[前缀码长度]都是最短的"],explain:[["赫夫曼树",[{tit:"构造方法",arr:["*.给定[n]个权值，用这[n]个权值来构建赫夫曼树","将这[n]个权值分别看作只有根结点的[n]棵二又树，这些二叉树构成的集合记为[F]","从[F]中选出[两棵]根结点的[权值最小]的树(假设为a、b)作为[左、右子]树，构造一棵新的二叉树(假设为[c])，新的二叉树的[根结点]的权值为[左、右子树]根结点权值[之和]","从[F]中删除[a、b]，加入[新]构造的树[c]。","重复进行[2、3]两步，直到[F]中只剩下一棵树为止，这棵树就是赫夫曼树。",`${si("structrue",40,"50")}`,si("structrue",41,"30")]},{tit:"赫夫曼树编码",arr:[["编码方法","常见的[.zip]压缩文件和[.jpeg]图片文件的[底层技术]都用到了赫夫曼编码。","如这样一串字符[S=AAABBACCCDEEA]，选[三位二进制]数为各个字符编码",si("structrue",38,"100"),"根据表可以把[S]串编码为:[T(S)=000000000001001000010010010011100100000]","用的时候就可以按照表所示的编码规则，对每三位一个字符进行[解码]得到[S]串。",["[T(S)]长度为[39]，有没有办法使得这个编码串[变短]一些，且能准确地[解码]得到原字符串?我们用赫夫曼编码","首先统计一下各个字符在字符串中[出现的次数]","以字符为[根结点]，以对应的出现次数为[权值]，构造一棵赫夫曼树",si("structrue",39,15),"赫夫曼树每个结点的[左、右]分支进行编号,[左0右1]","则从根到每个结点的[路径上]的[数字序列]即为每个字符的[编码]",si("structrue",42,"100"),"因此[S]串的编码为:[H(S)=00011011001010101110111111110]","[H(S)]串长度为[29]，比[T(S)]串短了很多。"]],["定长编码与不定长编码","对于[定长码]，如每三位就解码一次","对于[不定长码],假如[A]的编码串是[0],[B]的编码串是[00]","对于[00]这个编码串，是应该解码为[AA]还是[B]呢?","这个问题可以用[前缀码]来解决。在前缀码中，[任一字符]的编码串都不是另一字符编码串的[前级]〈这里以被编码的对象是字符为例)。","用前缀码编码，在解码时就不会出现歧义了","观察图,由[赫夫曼编码]规则产生的恰好是[前缀码]","如[H(S)]即是一串前缀码。因为被编码的字符都处于[叶子结点上]","而[根]通往[任一叶子结点]的路径都不可能是通往[其余叶子结点]路径的子路径","因此[任一编码串]不可能是其他编码串的[子串]。"],["解码[H(S)]","对[H(S)]解码需要用到图中的赫夫曼树","以[H(S)]串为指示，一次次沿着[根结点]走向[叶子]结点[并读出字符]的过程即是解码过程","如[H(S)]串第一个字符为[0],从根开始沿着[0]方向走到叶子结点,解码出[A]","回到根，重复上述过程，此时遇到[1]，从根沿着[1]方向走，遇到的[不是]叶子结点，继续读[H(S)]串","下一个字符是[1]，继续沿着[1]走，仍然[不是]叶子结点，继续读[H(S)]串","下一个字符是[0]，则沿着[0]方向走到[叶子]结点，读出[B]","[回到]根结点。如此进行下去，直到将所有字符解码出来。"]]}]],["基本概念",["*.赫夫曼树又叫作[最优二叉树],它的特点是[带权路径最短]。",["首先需要说明几个关于路径的概念。","路径: 路径是指从树中一个结点到另一个结点的[分支]所构成的[路线]。","路径长度: 路径长度是指路径上的分支数目","树的路径长度: 树的路径长度是指从[根]到每个结点的路径长度[之和]。","带权路径长度: 结点具有[权值]，从该结点到根之间的[路径长度][乘以]结点的[权值]，就是该结点的带权路径长度","树的带权路径长度(WPL): 树的带权路径长度是指树中[所有叶子结点]的带权路径长度[之和]。",["解释",si("structrue",37,17,!0),"*重点是要理解最后三个概念","图所示二叉树的4个叶子结点[a、b、c、d]值分别为[7、5、2、4]","因为[a]到根结点的分支数目为[2]，所以[a]的路径长度为[2]，a的带权路径长度为[@7\\times2=14]","同样[b、c、d]的带权路径长度分别为[@5\\times2=10、3\\times2=6、4\\times2=8]","于是这棵二叉树的带权路径长度为[@WPL=14+10+6+8=38]。"]],["赫夫曼树的特点","权值[越大]的结点，距离根结点[越近]","树中没有度为[1]的结点。这类树又吧作[正则严格)二叉树]","树的带权路径长度[最短]。"],["赫夫曼[n]叉树","赫夫曼[二叉树]是赫夫曼[n]叉树的一种[特例]","对于结点数目[大于等于2]的待处理序列，都可以构造赫夫曼二叉树，但却[不一定]能构造赫夫曼[n]叉树。","当发现无法构造时，需要[补上]权值为[0]的结点让整个序列凑成可以构造夫曼[n]叉树的序列。","构造方法和赫夫曼二叉树一样",si("structrue",43,18),"这棵赫夫曼三叉树的[@WPL=(0\\times 2)+(1+3)\\times 2+(4+6)\\times 1=18]"]]]]},{tit:"考点程序设计",compare:[["二叉树",[["[遍历序列]相关问题知识",["*.记住","[前]：[@父\\rightarrow左\\rightarrow右]","[中]：[@左\\rightarrow父\\rightarrow右]","[后]：[@左\\rightarrow右\\rightarrow父]"],["前序遍历","[非叶子]节点的[右边]一定是其[子]结点"],["中序遍历","二叉树中序遍历的[最后]一个结点一定是从[根开始]沿[右子树]指针链[走到底]的结点，和前序遍历[最左边]的那个节点构成成[八字形状]","根节点的左边一定是其[左孩子]，对于其他的节点，按先后顺序来看，已经确定了的去掉，左边是[左子树]，右边是[右子树]"],["后序遍历",""],["总结","[前]序序列、[中]序序列和[后]序序列中，所有叶子结点的[先后]顺序相同","三种序列中，必须有[中序]才可以唯一确定一棵树","前、后序列[相反]: 只有一个[叶子]节点, 即要么只有[一个]结点，要么只有[左或右]孩子。","[前序]序列和[后序]序列不能唯一确定一棵二叉树，但可以确定二叉树中结点的[祖先]关系:"]]]]]}]},complex:{top:[["考题程序设计","插入、删除、归并操作","特殊矩阵的压缩存储","逆置问题","表达式匹配和求值"],["定义及操作","线性表、栈、队列定义和操作","线性表、栈、队列存储结构"],["算法分析","插入删除操作时间"]],article:[{tit:"线性表",compare:[["线性表",[{tit:"顺序存储",arr:[["存储表示","线性表的顺序存储结构示意图",`${si("structrue",2,"80")}`],["顺序表的存储结构","$\n                    // 顺序表可能达到的最大长度\n                    #define MAXSIZE 100 \n                    typedef struct {\n                      int data[MAXSIZE]; \n                      int length; //当前长度\n                    } SqList; \n                    // 顺序表的结构类型为SqList \n                    // 考试一般使用的顺序表，就是最简单的数组\n                    int SeqList2[MAXSIZE]\n                  $"],ai("linetable","SeqList","顺序表")]},{tit:"链接存储",arr:[["单链表",["单链表的定义和表示",si("structrue",3,"70"),"在单链表的第一个结点之前附设一个结点，称之为头结点[L]","*.单链表的存储结构","$\n                    typedef struct LNode {\n                    ElemType data; //结点的数据域\n                    struct LNode *next; //结点的指针域\n                    } LNode,*LinkList; \n                    // LinkList 为指向结构体 LNode 的指针类型 $"],["*6.创建单链表:[尾插法和前插法]","尾插法：与给的数据顺序相同","前插法：与给的数据顺序相反",ai("linetable","singleLink","单链表")]],{tit:"环状链表",arr:[["双向链表","在双向链表的结点中有两个指针域，一个指向直接后继， 另一个指向直接前驱",si("structrue",5,"80"),["*.双向链表的存储结构","$\n                    typedef struct DuLNode {\n                      ElemType data; //数据域\n                      struct DuLNode *prior; //直接前驱\n                      struct DuLNode *next; //直接后继\n                    } DuLNode,*DuLinkList;\n                    $",ai("linetable","doubleLink","双链表")]],["循环链表","其特点是表中[最后一个结点]的指针域指向头结点，整个链表形成一个环。","[循环单链表]和[循环双链表]是由对应的[单链表]和[双链表]改造而来的，只需在[终端结点]和[头结点]间建立联系即可。",si("structrue",4,"80"),"当链表遍历时，判别当前[指针p]是否指向[表尾结点]的终止条件不同。在单链表中，判别条件为[p!=NULL]或$p->next!=NULL$,而循环单链表的判别条件为$p!=L 或 p->next!=L$。"],["静态链表","[一般链表结点]空间来自于整个内存，静态链表则来自于一个[结构体数组]。数组中的每一个结点含有[两个分量]：一个是[数据元素]分量data,另一个是[指针]分量，指示了当前结点的直接后继结点在数组中的[位置](这和一般链表中next指针的地位是同等的)。","静态链表中的[指针]不是我们通常所说的C语言中用来[存储内存地址]的指针型变量，而是一个存储[数组下标]的整型变量，通过它可以找到后继结点在数组中的位置，其功能类似于真实的指针，因此称其为[指针]。","如图所示[静态链表]和[普通的链表]",si("structrue",6,"80"),"*静态:一次分配。动态：多次分配","$\n                        typedef struct {\n                         int data; //数据域\n                         int next; // 索引\n                        } SLNode\n                        SLNode arr[maxsize];\n                        int p = 0; // p 类似于静态链表 arr 的指针\n                      $"]]}]}]],["操作",[["各个操作需注意",["插入","[尾插法]：[新]结点[挂在]当前[尾指针]的后面[next]，再把[尾指针]指向新节点。相当于[尾指针]在不断往后移动","[头插法]：[新]结点[插在]当前[头指针]的与它后面的结点[之间]，[头指针]一直没动",si("structrue",7,"80",!0),"*.要有容错提醒，比如没找到，超出范围等等",[],"数据结构要求的排序类型","[非递减]有序排列: 就是[关键字递增]序排列，但是并非[单调]递增(因为有重复的关键字)，比如[0,2,2,3,6,7,7,9]。"]],{tit:"非顺序表节点操作图示",arr:[["单链表","[s]插入[p]之后",si("structrue",7,"80",!0),"删除节点,还要释放节点$free(b)$",si("structrue",8,"60",!0)],["双链表","插入节点，先处理新节点的链接",si("structrue",9,"70",!0),"删除节点,还要释放节点$free(b)$",si("structrue",10,"70",!0)]]},["考点","有：1.特性对比问题 2.建表 3.划分 4.插入删除 5.移动次数计算和静态链表 6.归并 7.逆置 8.取最值","移动次数：举例法，算出，[@(n+n-1+n-2+\\cdots+1)],总的，平均的","[n]个元素的插入的概率：[@p=\\dfrac{1}{n+1}]"]]]],note:[["插入操作思想说明","在插入算法实现思路的思考中，有一点需要注意，人们喜欢见缝插针，所以一般新手同学在对一个顺序表实现插入算法时，往往把[元素之间的位置]作为[插入位置]，这是不好的","因为顺序表元素[之间的位置]在相关的程序语言中没有明确的描述方法，因此我们要[直接]以表中[元素所在的位置]作为插入位置，假设位置为[i](i是某元素在以数组为存储结构的顺序表的[下标])，并统一规定插入元素把[i]位置上的元素以及其后的元素[往后移动]一个位置。"],"*若没有特别说明，链表都是带有[头节点]的链表"]},{tit:"栈",compare:[["栈",[["共享栈"]]]]},{tit:"队列",compare:[["队列",[{tit:"顺序队",arr:[["状态判断","由图[3-5]可以看出，循环队列必须[损失]一个存储空间，如果右图中的[空白处]也存入元素，则[队满]的条件也成了[front==rear]，即和队空条件相同，那么就[无法区分]队空和队满了。",si("structrue",46,"80",!0)]]},{tit:"链队",arr:[["状态判断","链队是不会满的，除非内存满了，所以链队的逻辑结构就是一条[直线]，不用像循环队列那样的[环]"]]},["双端队列"]]]]}]},graph:{top:[["考题程序设计",""],["核心"],["算法","*最短路径","关键路径"]],article:[{tit:"图的基础知识",compare:[["图概念",[]],["图结构",["*.主要考邻接矩阵和邻接表",["邻接矩阵-顺序存储",si("structrue",55,"80",!0),"定义：[-邻接矩阵-]是一个[二维数组]，用于表示图中[_顶点之间_的连接关系]。如果图中的顶点[v]和顶点[w]之间[^存在边^]，则邻接矩阵中对应位置的值为[1]；否则，为[0]","存储结构：邻接矩阵可以使用[二维数组]来表示，其中数组的[行和列]分别对应图中的[顶点]。对于有[n][个顶点的图，邻接矩阵的大小为[@ n×n]","*.有向图中,方向是指的是[@ i\\longrightarrow j]","$\n                typedef struct {\n                  int n; //编号\n                  char info; //其他信息\n                } VertexType;\n                // 图的定义\n                typedef struct {\n                  int edges[MaxSize][MaxSize]; // 边\n                  int n,e; //顶点数、边数\n                  VertexType vex[MaxSize];\n                } MGraph;\n              $"],["邻接表-链式存储",si("structrue",56,"70",!0),"邻接表由[单链表的[_表头_形成的^顶点表^]和单链表其余结点形成的[^边表^]两部分组","$\n                typedef struct {\n                  int adjvex; //该边所指向的结点的位置(编号)\n                  struct ArcNode *nextarc;\n                  int info; // 其他相关信息\n                }ArcNode;\n                typedef struct {\n                  char data; //顶点信息\n                  ArcNode *firstArc 指向第一条边的指针\n                }VNode;\n                typedef struct {\n                  VNode adjlist[MaxSize];\n                  int n,e; //顶点数、边数\n                } AGraph;\n              $"],["邻接多重表-链式存储",si("structrue",57,"70",!0),si("structrue",58,"70",!0),""]]]]},{tit:"图的算法应用"}]},searchSort:{top:[["考题程序设计",""],["核心"],["算法","*二叉树的遍历算法","克鲁斯卡尔"]],article:[{tit:"排序",compare:[["类型",[]]]}]}};var pi={top:[["大纲要求","计算机网络的概念、功能和组成",""],["难点","计算机网络性能指标计算",""],["考点","OSI参考模型与TCP/IP模型",""]],article:[{tit:"计算机网络概念",note:["[-交换机-]只关注[数据帧的^目标MAC地址^]，而[-路由器-]则关注[数据报的^目标IP地址^]"],compare:[["概念",[["物理组成",si("network",1,"70"),si("network",2,"40")],["传输单位","在[OSI]参考模型中，在[对等层]之间传送的数据的[单位]都称为[协议数据单元(PDU)]","具体而言，在[传输层]称为[报文段(TCP)]或[用户数据报(UDP)]，在[网络层]称为[分组或数据报]，在[数据链路层]称为[帧]，在[物理层]称为[比特]。","[数据帧]（Frame）：是一种信息单位，它的起始点和目的点都是[数据链路层]。","[数据包]（Packet）：也是一种信息单位，它的起始和目的地是[网络层]。","[数据报]（Datagram）：通常是指起始点和目的地都使用[无连接网络服务]的的网络层的信息单元。","[段]（Segment）：通常是指起始点和目的地都是[传输层]的信息单元。","[消息]（message）：是指起始点和目的地都在网络层以上（经常在[应用层]）的信息单元。"],["MAC地址和IP地址","连入网络的每一个计算机都会有[网卡接口]，每一个网卡都会有一个[唯一]的地址，这个地址就叫做[MAC]地址。计算机之间的数据传送，就是通过[MAC]地址来唯一寻找、传送的。","[MAC]地址（Media Access Control Address）的全称叫做[媒体访问控制地址]，也称作[局域网]地址，[以太网]地址或者[物理]地址。"],["带宽","网络带宽是指在单位时间（一般指的是1秒钟）内能传输的[数据量]，即[数据传输率]。"],["集线器","具备多个网口，专门实现[多台]计算机的互联作用，这个微型计算机就是集线器[HUB]。顾名思义，[集线器]起到了一个将[网线]集结起来的作用，实现最初级的网络互通。集线器是通过[网线]直接传送数据的，我们说他工作在[物理层]。",si("network",10,25),"[@\\href{https://www.zhihu.com/question/22007235/answer/1420545927}{路由器和交换机}]"],["中继器","它的作用就是[将已经^衰减^得不完整的信和号经过整理]，重新产生出[完整的]信号再继续传送"],["网桥","网桥工作在[数据链路层]，其特点是据有[过滤帧]的功能",si("network",14,"80")],["交换机","[电脑]接上[交换机]后，交换机会自动学习，把交换机这个[端口]与接入这个端口的电脑的[mac地址]形成[MAC地址转发表]的[一条]新的[记录]","这个[MAC_地址转发表_]记录了所有接入这个交换机[电脑的|MAC|地址]和交换机端口的对应关系，所以这个时候接入这个交换机的所有电脑，在进行通信的时候，可以[点对点]了，并且可以不干扰其他电脑通信。","交换机里面[没有]网卡，只有[端口]。[交换机]只是存在于[局域网]，是为了把[|同一个|网段]的计算机限制在这个交换机上，形成一个[局域网]","[-以太网-交换机]实际上是[^多端口^]的[网桥]",si("network",15,"80")],["路由器","把[网络]分成[片区]，每个片区对应一个[网段]，给[每一台电脑]分配一个属于这个网段的[ip地址]，优点类似身份证前几位的那个一样，[ip]地址前面的那几位就属于网段","[ip地址]主要用来在[公网]上转发数据包，这个工作主要由一个叫[路由器]的设备负责的，这个时候通信规则就变了，所以上网冲浪的时候，电脑发送的数据包中有个请求头，这个请求头中会携带自己的[ip地址]，以及目标地址的[ip地址]，由[交换机]转到路由器，路由器里面有一个[ip映射表]，一看这个目标[ip地址]是属于哪个[网段]的，那么它就会把这个[数据帧]转发到可以达到目标[ip]的下一个路由器（公网上有很多路由器根据[ip地址]转发数据帧）。","路由器的每一个[wan口]都有一个[网卡]。从结构上来说，路由器多了网卡，从功能上说，路由器是为了实现[跨网段]通信。","首先[网关]一个大概念，不具体特指一类产品，只要[连接]两个不同的网络的设备都可以叫网关；而[路由器]一般特指能够实现路由寻找和转发的特定类产品，路由器很显然能够实现网关的功能。","[网关]是一个概念，[路由器]是一个产品。路由器可以做网关，防火墙可以做网关，三层交换机可以做网关，一台普通pc可以做网关，甚至一个智能手机也可以做网关。"],{tit:"相关术语解释",arr:["[ISP]：因特网服务提供者，比如[电信、联通、移动]，他们已经从因特网管理机构申请到了一批[IP]地址"]}]],["体系结构",[["结构",si("network",6,"60",!0),si("network",3,"",!0),si("network",4,"",!0),"*.[@\\href{https://www.zhihu.com/question/49335649}{各个结构之间的用处和关系}]"],["应用层","因此我们需要指定这些数据的[格式规则]，收到后才好解读渲染。"],["*传输层",si("network",7,"80",!0),"也就是说，传输层的功能就是建立[端口到端口]的通信。相比网络层的功能是建立[主机到主机]的通信。","[@\\href{https://zhuanlan.zhihu.com/p/147370653}{TCP/IP 协议}]",si("network",12,"66",!0)],["*网络层","当[源端]和[目的端]位于[不同网络]的时候，直接通信是不可行的，此时就需要由[网络层]解决。","网络层可以把来自[其他]网络中的数据传送到[下一个]途经的网络或[本网络]中的目的节点。","而[路由器]就相当于连接不同城市公路的[中转车站]，起数据中转作用。注意在路由器里有[来回两次]来处理数据。","注意：局域网内部[通过MAC地址]寻址，而网络间的寻址是通过[IP地址]进行的",si("network",5,"",!0),"假如是[同一个子网]，那我们就用[广播]的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据[发给网关]，让网关进行转发。"],["链路层","需要制定[一套规则]来进行[0，1]的传送。例如多少个电信号为一组啊，每一组信号应该如何标识才能[让计算机读懂]。"],["物理层","要把这台计算机与另外的其他计算机[连起来],物理层考虑的是[怎样]才能在连接各种计算机的[传输介质]上传输[数据比特流]，而不是指的具体的传输介质体","不考虑[_数据的结构_或_目标设备_]。物理层只负责传输数据的[物理连接和_电信号_的转换]，例如通过以太网电缆或光纤传输数据。"],["协议","协议由[语法、语义和时序(又称同步)]三部分组成","[语法]规定了通信双方彼此[如何讲]即规定了传输数据的[格式]","[语义]规定了通信双方彼此[讲什么]，即规定了所要完成的[功能]，如通信双方要发出什么控制信息、执行的动作和返回的应答","[时序]规定了信息交流的[次序]。"]]]],explain:[["计算机网络性能指标",[["时延","发送时延","传播时延","处理时延","排队时延"]]]]},{tit:"物理层",note:[{tit:"脉冲、脉冲信号",arr:[["定义","在数字电子系统中，所有传输的信号都是[通/断]的，即只有[两种]电信号。这种电信号称为脉冲信号，是所有数字电路中的基本电信号。","[脉冲信号]是一种瞬时变化的电信号，其特点是在极短的时间内，电压或电流呈现出非常快速的变化","脉冲信号是一种[瞬态]信号，通常在[极短]的时间内（比如纳秒或微秒级别）产生极高的能量峰值","脉冲信号通常由一个[突然的、短暂]的电压或电流变化所组成，这种变化可以由瞬时开关、脉冲发生器、脉冲放大器等器件产生。"],["原理","脉冲信号的原理涉及到电路中的[开关、电容、电感、二极管]等元件，以及信号发生器、放大器等电子器件","一个简单的[脉冲信号电路]可以由一个[电容]和一个[电阻]组成，当电源连接到电路中时，电容会被[充电]，电压会从[0]逐渐上升到电源电压值。当电容[充满]电荷时，电容上的[电压]将达到电源电压值，电路中的电流将[停止]流动。此时，如果[断开]电源电压，电容就会被放电，电压将从电源电压逐渐降低到[0]。当电容的电压[降到]一定程度时，电路中的电流将[重新流动]，电容开始被充电。这个过程[不断重复]，形成了一个简单的脉冲信号。","但是，这样简单的电路只能产生[周期性]的脉冲信号。要产生单次脉冲信号，需要使用更复杂的电路和器件。"],["脉冲信号的特性","[短时性]：脉冲信号持续时间非常短，通常只有纳秒或微秒级别。","[高能量]：脉冲信号的幅度通常很高，可以达到数百伏特或千伏特级别。","[宽带性]：脉冲信号通常具有宽带性，即频率分布在一个宽范围内，可以用于高速数据传输和宽带雷达等应用。","[脉冲宽度可调]：通过调节脉冲信号的宽度，可以控制脉冲信号的特性，比如脉冲重复频率、脉冲幅度和脉冲宽度等。"],["[脉冲]主要是由[石英晶体振荡器]产生的","如果在石英晶片的[两极]上加上一个[交变电压]，晶片就会产生[机械振动]，同时晶片的机械振动又会产生[交变电场],这个[交便电场]就是按照固定周期变化的脉冲信号。在一般情况下，晶片机械振动的振幅和交变电场的振幅非常微小，但当外加交变电压的频率为某一特定值时，振幅明显加大，比其他频率下的振幅大得多，这种现象称为压电谐振，它与LC电路的谐振现象十分相似。谐振频率与晶片的切割方式、几何形状、尺寸等有关。",["利用晶体的压电效应","沿一定方向切割的石英晶片，当受到[机械应力]作用时将产生与应力成正比的[电场或电荷]，这种现象称为[正压电效应]；反之，当石英晶片受到[电场作用]时将产生与[电场成正比]的[应变]，这种现象称为[逆压电效应]。","[@\\href{https://zhuanlan.zhihu.com/p/361975405}{晶振的基本原理及特性}]"],["高频率的信号通向分频器（frequency divider），转化为比较低频的信号。",si("network",9,70),"以上图为例，[分频器]分出来的信号有四个频率。题目中所说[CPU周期信号、节拍周期信号、节拍脉冲信号]本质上都是[时钟脉冲]的[不同分频]，主要区别在于用途上","[@\\href{https://www.zhihu.com/question/20392042/answer/14999333}{CPU 周期信号、节拍周期信号、节拍脉冲信号三者之间的关系}]"]]]},["时钟频率",si("network",8,70),"[Flop]保持数据，[逻辑门]处理数据；处理好了传递给下一个人。逻辑门处理数据需要一定时间，在这个时间里，要[Flop]要保持数据的稳定性。这个过程需要[Clock]这个节奏器来同步，来告诉[Flop]啥时候可以接受新的从上面一个人那里传来的数据，来给自己的逻辑门处理。","任何电路都是[有延迟]的，从[输入]信号输入到电路完成计算[输出]结果是需要[时间]的。但是麻烦的是这个时间对于所有电路都是[不一样]的，所以我们不知道究竟要[等多久]上一个电路才算是完成了运算，可以[读取]输出了。对于人来说这个问题还不大，我们只要多等等保证算完了就好了，但是对于电路来说就麻烦了：[每一级]电路都需要上一级电路的[输出]结果作为[输入]，可是要等多久上一级才能完成计算？就算我知道上一级的计算需要[10ns]时间，但是我该从哪里[开始计时]？用[什么]进行计时？于是电路设计师们不得不加入了非常复杂的[握手信号]来控制数据读取，简单的说就是[前一级]电路在完成运算之后[向下一级]发送一个[可以读取]了的信号，下一级收到这个信号之后才能读取；[下一级]读取完毕之后再发一个[我读完了]的信号返回上一级，上一级才能开始下一个运算。这不仅[浪费]了大量的[电路]在握手上，还极大地加大了设计难度。","为了解决这个问题，工程师们设计了[同步电路]。同步电路加入了[时钟信号]，所有电路模块的[读取]与[输出]都受到时钟信号的控制。比如一个电路模块，每次计算需要至多[100ns]的时间，而电路的时钟周期是[50ns]。那么我就知道这个电路至多需要[两个周期]的时间就能完成运算。为了冗余安全，我将这个模块设计为每三个时钟周期进行一次运算，它的[下一级]电路也[每隔三个]周期执行一次读取即可。[有了时钟信号，我只需要对每个电路设计隔几个周期进行读/写即可，不再需要在所有模块之间都设计握手信号]，这极大地降低了设计难度。"],["同步和异步","为了正确的解释信号，接收方必须确切地知道信号应当[何时]接收和处理，因此定时是至关重要的。在计算机网络中，定时的因素称为[位同步]。同步是要接收方按照发送方发送的每个位的[起止时刻]和[速率]来接收数据，否则会产生误差。通常可以采用[同步]或[异步]的传输方式对位进行同步处理。","[@\\href{https://zhuanlan.zhihu.com/p/74386308}{同步传输与异步传输的术语解释}]"]],compare:[["通信基础",["编码",si("network",11,""),si("network",20,"80"),["曼彻斯特编码的如何进行自同步","彻斯特编码，不论是差分还是非差分，每个码元都有从一个电平到另一个电平跳变的过程，因此可以在任何数据传输过程中，通过判断上升/下降沿和下一个上升/下降沿之间的间隔，来得到[两个]码元之间的时间，从而得到通信使用的频率，也就实现了[自同步]。","[@\\href{https://www.zhihu.com/question/315659425/answer/624682957}{自同步}]"]]],["数据传输",[["数据传输方式",si("network",21,"80",!0),"电路交换","报文交换",["分组交换",["数据报",si("network",22,"70",!0)],["虚电路",si("network",23,"70",!0)]]]]]]}]};var di={top:[["大纲要求","组帧",""],["难点","差错控制、流量控制",""],["考点","",""]],article:[{tit:"数据链路层功能",compare:[["组帧",[["作用",si("network",17,"80"),si("network",18,"80"),"[_为什么要组帧?_]直接传送比特流不就可以了，还免去了[^帧同步、帧定界、透明传输^]等问题。但是反过来思考，万一传送比特流出错了呢?那就得重传全部的比特流","而组帧的[优点是]，如果出错了，只需发送出错的帧即可，这相对于增加了[帧同步、上定界、透明传输]问题是值得的","组帧也不能随意组合，要让接收方看得懂才可以，所以就需要[|依据一定的规则|]将网络层递交下来的[^分组^组装成帧]","通常情况下，只需掌握以下[4种组帧方法]:字符计数法、字节填充的首尾界符法、比特填充的首尾标志法、物理编码违例法"],["帧、报文、报文段、分组、包、数据报的概念区别"]]],["差错控制",[]]]},{tit:"流量控制与可靠传输机制",note:[]},{tit:"局域网和广域网",compare:[["局域网",[]],["广域网",[["PPP点对点协议",["概念","用户想要接入到[因特网]需要先连接到因特网服务提供者ISP","获取ISP分配的合法地址成为因特网上的主机","用户与ISP通信时使用到的协议就是PPP协议"],"工作状态",si("network",13,"")],["HDLC协议","是一种[面向比特]的数据链路层协议，它的主要功能是将传输层提供的[数据分成帧]，并对每一帧进行[校验]，从而保证数据的可靠性和完整性。","除此之外，HDLC协议还具有流量控制、媒体访问控制等功能，可以适应不同的通信环境和需求。"]]]],note:[]},{tit:"数据链路层设备",compare:[["冲突域",[["子网、局域网、网段的关系",["[_二层_]设备和[_三层_]设备","二层设备：物理层-数据链路层，属于[数据链路层]的设备，[只能识别-mac-地址]，如网桥，二层交换机","三层设备：物理层-数据链路层-网络层，属于[网络层]的设备，[能识别-mac-地址和-ip-地址]，如路由器，三层交换机，ip网关"],"[-局域网-]数据链路层的概念，指[二层]可达的网络（也就是不需要三层设备，如路由器，也能到达的网络），通俗得讲就是[小范围]的网络","[-子网-]是网络层的概念，和局域网没有直接的关系，是把一个[|ip|网络]划分为几个小范围的网络，但是在平时[_不要求精确性_]的时候，局域网可以[对应]子网，也就是说，子网也是二层可达，子网之间需要三层设备",["[网段]","*.是物理层的定义，使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分","使用[同一_物理层_的|设备|]之间必然通过相同的传输介质[直接]相互连接，如交叉双绞线直接连接的两台主机，是[一个]网段","两组其传输介质[|并非直接相连|]的网络设备，如果它们的传输介质通过工作在[物理层的_扩展设备_]如[中继器]和[集线器]等[转接连接]，则仍然被视为同一物理层中的设备，是[一个]网段","工作在数据链路层或[更高层]的设备如[_网桥、交换机、路由器_]等等，由它们连接起来的两组设备仍然[^分别^]处于[各自独立]的物理层，是[两个]网段"],"*.[-总结-]在不要求精确性的情况下，子网、局域网和网段可以[理解为^同一个^意思]，但是[-同一个局域网--同一个子网--同一个网段-和-同一个网络-]不是[|同一个概念|]"],["冲突域概念",si("network",16,"80"),"[_黄圈_]是[冲突域]，是[一次载波侦听]发生的范围。[|冲突域的问题|]就是你说话的时候别人不能说话，别人说话的时候你不能说话，一个时刻只有一个人能说话。","[_蓝圈_]是[广播域]，是一次广播发生的范围。[|广播域的范围|]就是你喊了一嗓子别人能听到，别人喊一嗓子你也能听到。大家可以同时说话，但是如果大家都在喊话，就会特别吵。（正常说话，别人可能会听到，也可能听不到）","*.[多个]冲突域用[-网桥-]连接成[一个]广播域，广播可达，冲突被隔离在本冲突域内。","[_绿圈_]是[路由]可达范围，广播被终结在路由器上，[^广播域外^]可以使用[路由表]实现通讯。"],["交换机[^无法跨越^不同的网络]进行数据转发的原因","在于它[_缺乏路由选择_]的能力。交换机只关注[局域网内部的MAC地址]，对于跨越不同网络的数据转发没有足够的信息。","当一个数据帧的目标MAC地址[不在]交换机的MAC地址表中时，交换机[会广播该数据帧]到所有的端口上，以寻找目标设备。","但是，如果目标设备[不在同一个局域网内]，交换机就无法找到正确的路径进行转发。","这时候就需要路由器的帮助。路由器是一种工作在网络层的设备，它具备路由选择的能力，能够根据目标IP地址来确定[数据报的转发路径]"]]]]}]};var fi={basic:pi,forwardData:{top:[["大纲要求","IP地址分类","路由协议"],["难点","路由算法",""],["考点","子网划分和无分类编址CIDR","路由与转发"]],article:[{tit:"网络层结构",compare:[["网络层功能",[si("network",19,"80"),["连接网络的中间设备","*.将网络互连起来肯定需要一些[中间设备]（又称为中间系统或中继系统），根据中继系统所在的层次，可以有以下[_4种_]不同的[^中继系统^]","[物理层]的中继系统：中继器或集线器","[数据链路层]的中继系统：网桥或交换机。","[网络层]的中继系统：路由器。","[网络层以上]的中继系统：网关。","*.当中继系统是[_中继器或网桥_]时，一般并不称之为[-网络互连-]，因为这仅仅是把一个[^网络扩大^]了，仍然是[一个网络]。互联网都是指[用路由器]进行[互连的网络]。"]]]]},{tit:"路由",compare:[["基础介绍",[["概念","路由选择","分组转发"]]]]}]},transformData:di};var mi={top:[["考题程序设计","手写代码的规范","三段式的考题形式"],["定义及操作","结构体的定义",""],["算法","算法的复杂度分析",""]],article:[{tit:"算法概念"}]};var _i={top:[["考题程序设计","手写代码的规范","三段式的考题形式"],["定义及操作","结构体的定义",""],["算法","算法的复杂度分析",""]],article:[{tit:"算法概念"}]};var gi={top:[["考题程序设计","手写代码的规范","三段式的考题形式"],["定义及操作","结构体的定义",""],["算法","算法的复杂度分析",""]],article:[{tit:"算法概念"}]};var vi={basic:{top:[["难点","",""],["大纲要求","发展与分类","**运行环境"],["核心考点","核心态与用户态区别","中断与异常区别"]],article:[{tit:"基本概念",explain:[["基本结构",[["操作系统的五大主要功能",`${si("system",1,"64")}${si("system",2,"36")}`,"处理器管理：对进程的管理","存储器管理：内存分配、内存保护、内存扩充","设备管理：设备分配、设备传输控制、设备独立性","文件管理：文件存储空间管理、目录管理、文件操作管理、文件保护","用户接口：命令接口、程序接口、图形接口"],["操作系统的技术发展","脱机输入输出技术","联机输入输出技术","分时技术"],["操作系统的运行环境","CPU运行模式：[核心态、用户态]","分布式操纵系统"]]],["概念解释",[["脱机","指的是[不需要人为的操作]，用户[不能直接^干预^]作业的执行","用户提交作业后，在获得结果之前几乎不和计算机交互","多用于[批处理]系统","有[脱机命令接口、脱机输入/输出技术]",si("system",3,"80",!0)]]]]}]},process:{top:[["难点","调度算法","经典同步问题"],["大纲要求","进程控制","**处理器调度","同步与互斥"],["核心考点","进程与程序的异同","处理器三级调度","临界区与临界资源"]],article:[{tit:"进程与线程",explain:[["进程",[["概念",["[-进程-]是[_资源分配_]的[基本单位]，也是[^独立运行^]的基本单位","在多道程序环境下，[_程序_的-并发执行-]破坏了程序的[封闭性和可再现性]，程序这种静态概念不能如实地反应程序活动的特征，所以引入一个新的概念-[-进程-]。","进程是[程序在^处理器^上的一次执行过程]，因而是动态的。","每个进程都是由[程序段、数据段和一个进程控制块(PCB)]组成"],["[-PCB-]进程控制块","[PCB的作用]是为了保证程序的[^并发执行^]"]],["*进程的状态与转换",si("system",4,"80",!0),"进程的五种基本状态:[_就绪状态、执行状态、阻塞状态_、创建状态、结束状态]","*.执行状态只能由就绪状态转换，而无法由阻塞状态到就绪状态"],["进程的控制","进程控制的职责是对系统种的[所有进程实施有效的|管理|]","其功能包括[进程的创建、进程的撤销、进程的阻塞与唤醒]，一般是由[操作系统的_内核_]来实现。","只有[-进程-]才可以在[^系统中运行^]","进程切换一定回产生[-中断-]，进行[处理器的^模式切换^]，即从[_用户态进入内核态_]，之后又回到用户态。","[P原语]：阻塞原语、[V原语]：唤醒原语","进程通信的三种[^高级^]方式：[共享存储系统、消息传递系统、管道通信系统]"]]],["区别",[["进程和程序区别",""],["进程和作业的区别"],["就绪状态与阻塞状态区别"],["进程切换语调度的区别"]]]],explain1:[["线程",[["概念","[-线程-]的引入提高了程序的[并发执行的^程度^]，从而进一步提高系统的吞吐量","让线程去完成[被处理器独立调度和分配的单元],让进程完成[拥有资源的独立单元]"],["线程的状态与转换","线程的六种状态:[初始、就绪、运行状态、阻塞、等待、超时等待、终止]",si("system",5,"80")]]],["关系",[["线程与进程比较"]]]]},{tit:"处理器调度",compare:[["调度",[["调度概念",si("system",6,"50"),"一个[作业]从提交开始直到完成，往往要经历[_三级调度_]:[高级调度、中级调度、低级调度]","调度原则中重要的计算:[周转时间]"]]],["调度算法",[["常见的调度算法"]]]]},{tit:"同步与互斥",compare:[["概念",[["同步与互斥概念","[^区分^互斥与同步]时只需记住，只要是[同类进程]即为[互斥关系]，[_不同_类进程]即为[同步关系]，<br>例如，[消费者]与[消费者]就是[互斥]关系，[消费者]和[生产者]就是[同步关系]"],["临界区与临界资源",si("system",7,"50"),"临界区和临界资源是不同的概念，[-临界区-^不是^-临界资源-的_地址_]"]]]]},{tit:"死锁"}]},memory:mi,equipment:gi,file:_i},yi=n("./src/js/util/Notes.tsx");const xi=[["408全国统考",[["数据结构：新增难点，编程代码，11（选择） + 2（大题） = 45(分)","手动，再代码，","学会画图","特例法：不一般变一般","可以使用[c++]写"],["组成原理：完美补齐，从教材入手：11+2 = 45","软硬件协同分析和设计能力","加法器","高级语言与机器级代码的对应","强化：[袁春风]老师的教材，基础：[唐朔飞]老师"],["操作系统：重塑知识，身边入门：10 + 2 = 35","从计算机系统的角度理解并描述应用程序、操作系统内核和计算机硬件协作完成任务的过程。","结合硬件的角度学习","PV操作","地址映射（存储）","文件实现机制","多线程编程"],["计算机网络：有增有减：8+1 =25分，工程实践",["计算机网络的结构、[协议]、应用、典型网络设备的工作原理","工具：wireshark，把协议的语法和语义展示出来","拓扑：packettracer vlan"]],["课程之间联系",'<img  class="img"src="./assert/imgs/consist/2.png"style="width:30em"/>']]],["C++",["[.c]C语言，[.cpp]c++语言","考试时，要写注释，以便阅卷老师看"]],["操作系统"],["计算机网络"],["组成原理"],["数据结构 "]],Ci=()=>{const t=(0,r.UO)().id;return(0,Zr.jsxs)(Zr.Fragment,{children:[(0,Zr.jsx)(ri,{articleData:xi}),(0,Zr.jsx)("div",{className:"wrap-box",children:"exame"===t?(0,Zr.jsx)(yi.o,{data:xi}):(0,Zr.jsx)("iframe",{src:"./assert/language-view/demo/index.html",className:"iframe-box"})})]})};var $i=()=>(0,Zr.jsx)("div",{className:"page-computer",children:(0,Zr.jsxs)(r.Z5,{children:[(0,Zr.jsx)(r.AW,{index:!0,element:(0,Zr.jsx)(ti,{})}),(0,Zr.jsx)(r.AW,{path:"notes/:id",element:(0,Zr.jsx)(Ci,{})}),(0,Zr.jsx)(r.AW,{path:"cpp/:id",element:(0,Zr.jsx)(ii,{dataObj:oi})}),(0,Zr.jsx)(r.AW,{path:"js/:id",element:(0,Zr.jsx)(ii,{dataObj:hi})}),(0,Zr.jsx)(r.AW,{path:"structure/:id",element:(0,Zr.jsx)(ii,{dataObj:ui})}),(0,Zr.jsx)(r.AW,{path:"consist/:id",element:(0,Zr.jsx)(ii,{dataObj:ci})}),(0,Zr.jsx)(r.AW,{path:"system/:id",element:(0,Zr.jsx)(ii,{dataObj:vi})}),(0,Zr.jsx)(r.AW,{path:"network/:id",element:(0,Zr.jsx)(ii,{dataObj:fi})})]})})},"./src/css/computer.scss":function(){}}]);